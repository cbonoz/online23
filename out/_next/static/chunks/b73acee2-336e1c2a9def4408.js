"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[592],{86568:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){function getIterator(J){if("function"==typeof J.next)return J;if("function"==typeof J[Symbol.iterator])return J[Symbol.iterator]();if("function"==typeof J[Symbol.asyncIterator])return J[Symbol.asyncIterator]();throw TypeError('"values" does not to conform to any of the iterator or iterable protocols')}function defer(){let J,Q;return{promise:new Promise((tt,te)=>{Q=tt,J=te}),reject:J,resolve:Q}}function _transform(J,Q,tt){let te=getIterator(tt),tr=[],tn=[],ti=!1,to=!1,ts=0,ta=null;function tl(){for(;tn.length>0&&tr.length>0;){let{resolve:J}=tn.shift();J({done:!1,value:tr.shift()})}for(;tn.length>0&&0===ts&&ti;){let{resolve:J,reject:Q}=tn.shift();ta?(Q(ta),ta=null):J({done:!0,value:void 0})}}async function tu(){if(ti)tl();else if(!(to||ts+tr.length>=J)){to=!0,ts++;try{let{done:J,value:tt}=await te.next();J?(ti=!0,ts--,tl()):async function(J){try{let tt=await Q(J);tr.push(tt)}catch(J){ti=!0,ta=J}ts--,tl(),tu()}(tt)}catch(J){ti=!0,ts--,ta=J,tl()}to=!1,tu()}}let tf={next:async function(){if(0===tr.length){let J=defer();return tn.push(J),tu(),J.promise}let J=tr.shift();return tu(),{done:!1,value:J}},[Symbol.asyncIterator]:()=>tf};return tf}function transform(J,Q,tt){return void 0===Q?(Q,tt)=>tt?transform(J,Q,tt):transform(J,Q):void 0===tt?tt=>transform(J,Q,tt):_transform(J,Q,tt)}__webpack_require__.d(__webpack_exports__,{xk:function(){return Web3Storage}});var commonjsGlobal="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function getDefaultExportFromCjs(J){return J&&J.__esModule&&Object.prototype.hasOwnProperty.call(J,"default")?J.default:J}function getAugmentedNamespace(J){if(J.__esModule)return J;var Q=Object.defineProperty({},"__esModule",{value:!0});return Object.keys(J).forEach(function(tt){var te=Object.getOwnPropertyDescriptor(J,tt);Object.defineProperty(Q,tt,te.get?te:{enumerable:!0,get:function(){return J[tt]}})}),Q}var pRetry$2={exports:{}},retry$2={};function RetryOperation(J,Q){"boolean"==typeof Q&&(Q={forever:Q}),this._originalTimeouts=JSON.parse(JSON.stringify(J)),this._timeouts=J,this._options=Q||{},this._maxRetryTime=Q&&Q.maxRetryTime||1/0,this._fn=null,this._errors=[],this._attempts=1,this._operationTimeout=null,this._operationTimeoutCb=null,this._timeout=null,this._operationStart=null,this._timer=null,this._options.forever&&(this._cachedTimeouts=this._timeouts.slice(0))}var retry_operation=RetryOperation;RetryOperation.prototype.reset=function(){this._attempts=1,this._timeouts=this._originalTimeouts.slice(0)},RetryOperation.prototype.stop=function(){this._timeout&&clearTimeout(this._timeout),this._timer&&clearTimeout(this._timer),this._timeouts=[],this._cachedTimeouts=null},RetryOperation.prototype.retry=function(J){if(this._timeout&&clearTimeout(this._timeout),!J)return!1;var Q=(new Date).getTime();if(J&&Q-this._operationStart>=this._maxRetryTime)return this._errors.push(J),this._errors.unshift(Error("RetryOperation timeout occurred")),!1;this._errors.push(J);var tt=this._timeouts.shift();if(void 0===tt){if(!this._cachedTimeouts)return!1;this._errors.splice(0,this._errors.length-1),tt=this._cachedTimeouts.slice(-1)}var te=this;return this._timer=setTimeout(function(){te._attempts++,te._operationTimeoutCb&&(te._timeout=setTimeout(function(){te._operationTimeoutCb(te._attempts)},te._operationTimeout),te._options.unref&&te._timeout.unref()),te._fn(te._attempts)},tt),this._options.unref&&this._timer.unref(),!0},RetryOperation.prototype.attempt=function(J,Q){this._fn=J,Q&&(Q.timeout&&(this._operationTimeout=Q.timeout),Q.cb&&(this._operationTimeoutCb=Q.cb));var tt=this;this._operationTimeoutCb&&(this._timeout=setTimeout(function(){tt._operationTimeoutCb()},tt._operationTimeout)),this._operationStart=(new Date).getTime(),this._fn(this._attempts)},RetryOperation.prototype.try=function(J){console.log("Using RetryOperation.try() is deprecated"),this.attempt(J)},RetryOperation.prototype.start=function(J){console.log("Using RetryOperation.start() is deprecated"),this.attempt(J)},RetryOperation.prototype.start=RetryOperation.prototype.try,RetryOperation.prototype.errors=function(){return this._errors},RetryOperation.prototype.attempts=function(){return this._attempts},RetryOperation.prototype.mainError=function(){if(0===this._errors.length)return null;for(var J={},Q=null,tt=0,te=0;te<this._errors.length;te++){var tr=this._errors[te],tn=tr.message,ti=(J[tn]||0)+1;J[tn]=ti,ti>=tt&&(Q=tr,tt=ti)}return Q},function(J){var Q=retry_operation;J.operation=function(tt){var te=J.timeouts(tt);return new Q(te,{forever:tt&&(tt.forever||tt.retries===1/0),unref:tt&&tt.unref,maxRetryTime:tt&&tt.maxRetryTime})},J.timeouts=function(J){if(J instanceof Array)return[].concat(J);var Q={retries:10,factor:2,minTimeout:1e3,maxTimeout:1/0,randomize:!1};for(var tt in J)Q[tt]=J[tt];if(Q.minTimeout>Q.maxTimeout)throw Error("minTimeout is greater than maxTimeout");for(var te=[],tr=0;tr<Q.retries;tr++)te.push(this.createTimeout(tr,Q));return J&&J.forever&&!te.length&&te.push(this.createTimeout(tr,Q)),te.sort(function(J,Q){return J-Q}),te},J.createTimeout=function(J,Q){return Math.min(Math.round((Q.randomize?Math.random()+1:1)*Math.max(Q.minTimeout,1)*Math.pow(Q.factor,J)),Q.maxTimeout)},J.wrap=function(Q,tt,te){if(tt instanceof Array&&(te=tt,tt=null),!te)for(var tr in te=[],Q)"function"==typeof Q[tr]&&te.push(tr);for(var tn=0;tn<te.length;tn++){var ti=te[tn],to=Q[ti];Q[ti]=(function(te){var tr=J.operation(tt),tn=Array.prototype.slice.call(arguments,1),ti=tn.pop();tn.push(function(J){tr.retry(J)||(J&&(arguments[0]=tr.mainError()),ti.apply(this,arguments))}),tr.attempt(function(){te.apply(Q,tn)})}).bind(Q,to),Q[ti].options=tt}}}(retry$2);var retry$1=retry$2;let retry=retry$1,networkErrorMsgs=["Failed to fetch","NetworkError when attempting to fetch resource.","The Internet connection appears to be offline.","Network request failed"];class AbortError extends Error{constructor(J){super(),J instanceof Error?(this.originalError=J,{message:J}=J):(this.originalError=Error(J),this.originalError.stack=this.stack),this.name="AbortError",this.message=J}}let decorateErrorWithCounts=(J,Q,tt)=>{let te=tt.retries-(Q-1);return J.attemptNumber=Q,J.retriesLeft=te,J},isNetworkError=J=>networkErrorMsgs.includes(J),pRetry=(J,Q)=>new Promise((tt,te)=>{Q={onFailedAttempt:()=>{},retries:10,...Q};let tr=retry.operation(Q);tr.attempt(async tn=>{try{tt(await J(tn))}catch(J){if(!(J instanceof Error))return void te(TypeError(`Non-error was thrown: "${J}". You should only throw errors.`));if(J instanceof AbortError)tr.stop(),te(J.originalError);else if(J instanceof TypeError&&!isNetworkError(J.message))tr.stop(),te(J);else{decorateErrorWithCounts(J,tn,Q);try{await Q.onFailedAttempt(J)}catch(J){return void te(J)}tr.retry(J)||te(tr.mainError())}}})});pRetry$2.exports=pRetry,pRetry$2.exports.default=pRetry;var AbortError_1=pRetry$2.exports.AbortError=AbortError,pRetry$1=pRetry$2.exports;let last=async J=>{let Q;for await(let tt of J)Q=tt;return Q};var itLast=last,itPipe={exports:{}};let rawPipe=(...J)=>{let Q;for(;J.length;)Q=J.shift()(Q);return Q},isIterable$1=J=>J&&("function"==typeof J[Symbol.asyncIterator]||"function"==typeof J[Symbol.iterator]||"function"==typeof J.next),isDuplex=J=>J&&"function"==typeof J.sink&&isIterable$1(J.source),duplexPipelineFn=J=>Q=>(J.sink(Q),J.source),pipe=(...J)=>{if(isDuplex(J[0])){let Q=J[0];J[0]=()=>Q.source}else if(isIterable$1(J[0])){let Q=J[0];J[0]=()=>Q}if(J.length>1&&isDuplex(J[J.length-1])&&(J[J.length-1]=J[J.length-1].sink),J.length>2)for(let Q=1;Q<J.length-1;Q++)isDuplex(J[Q])&&(J[Q]=duplexPipelineFn(J[Q]));return rawPipe(...J)};itPipe.exports=pipe,itPipe.exports.pipe=pipe,itPipe.exports.rawPipe=rawPipe,itPipe.exports.isIterable=isIterable$1,itPipe.exports.isDuplex=isDuplex;var pipe$1=itPipe.exports,encode_1$1=encode$9,MSB$3=128,REST$3=127,MSBALL$1=~REST$3,INT$1=2147483648;function encode$9(J,Q,tt){if(Number.MAX_SAFE_INTEGER&&J>Number.MAX_SAFE_INTEGER)throw encode$9.bytes=0,RangeError("Could not encode varint");Q=Q||[];for(var te=tt=tt||0;J>=INT$1;)Q[tt++]=255&J|MSB$3,J/=128;for(;J&MSBALL$1;)Q[tt++]=255&J|MSB$3,J>>>=7;return Q[tt]=0|J,encode$9.bytes=tt-te+1,Q}var decode$b=read$1,MSB$2=128,REST$2=127;function read$1(J,Q){var tt,te=0,tr=0,tn=Q=Q||0,ti=J.length;do{if(tn>=ti||tr>49)throw read$1.bytes=0,RangeError("Could not decode varint");tt=J[tn++],te+=tr<28?(tt&REST$2)<<tr:(tt&REST$2)*Math.pow(2,tr),tr+=7}while(tt>=MSB$2);return read$1.bytes=tn-Q,te}var N1$1=128,N2$1=16384,N3$1=2097152,N4$1=268435456,N5$1=34359738368,N6$1=4398046511104,N7$1=562949953421312,N8$1=72057594037927940,N9$1=0x7fffffffffffffff,length$1=function(J){return J<N1$1?1:J<N2$1?2:J<N3$1?3:J<N4$1?4:J<N5$1?5:J<N6$1?6:J<N7$1?7:J<N8$1?8:J<N9$1?9:10},varint$1={encode:encode_1$1,decode:decode$b,encodingLength:length$1},encode_1=encode$8,MSB=128,REST=127,MSBALL=~REST,INT=2147483648;function encode$8(J,Q,tt){Q=Q||[];for(var te=tt=tt||0;J>=INT;)Q[tt++]=255&J|MSB,J/=128;for(;J&MSBALL;)Q[tt++]=255&J|MSB,J>>>=7;return Q[tt]=0|J,encode$8.bytes=tt-te+1,Q}var decode$a=read,MSB$1=128,REST$1=127;function read(J,Q){var tt,te=0,tr=0,tn=Q=Q||0,ti=J.length;do{if(tn>=ti)throw read.bytes=0,RangeError("Could not decode varint");tt=J[tn++],te+=tr<28?(tt&REST$1)<<tr:(tt&REST$1)*Math.pow(2,tr),tr+=7}while(tt>=MSB$1);return read.bytes=tn-Q,te}var N1=128,N2=16384,N3=2097152,N4=268435456,N5=34359738368,N6=4398046511104,N7=562949953421312,N8=72057594037927940,N9=0x7fffffffffffffff,length=function(J){return J<N1?1:J<N2?2:J<N3?3:J<N4?4:J<N5?5:J<N6?6:J<N7?7:J<N8?8:J<N9?9:10},varint={encode:encode_1,decode:decode$a,encodingLength:length},_brrp_varint=varint;let decode$9=(J,Q=0)=>[_brrp_varint.decode(J,Q),_brrp_varint.decode.bytes],encodeTo=(J,Q,tt=0)=>(_brrp_varint.encode(J,Q,tt),Q),encodingLength=J=>_brrp_varint.encodingLength(J),empty=new Uint8Array(0),fromHex=J=>{let Q=J.match(/../g);return Q?new Uint8Array(Q.map(J=>parseInt(J,16))):empty},equals$2=(J,Q)=>{if(J===Q)return!0;if(J.byteLength!==Q.byteLength)return!1;for(let tt=0;tt<J.byteLength;tt++)if(J[tt]!==Q[tt])return!1;return!0},coerce=J=>{if(J instanceof Uint8Array&&"Uint8Array"===J.constructor.name)return J;if(J instanceof ArrayBuffer)return new Uint8Array(J);if(ArrayBuffer.isView(J))return new Uint8Array(J.buffer,J.byteOffset,J.byteLength);throw Error("Unknown type, must be binary type")},fromString$3=J=>(new TextEncoder).encode(J),toString$1=J=>(new TextDecoder).decode(J),create$4=(J,Q)=>{let tt=Q.byteLength,te=encodingLength(J),tr=te+encodingLength(tt),tn=new Uint8Array(tr+tt);return encodeTo(J,tn,0),encodeTo(tt,tn,te),tn.set(Q,tr),new Digest(J,tt,Q,tn)},decode$8=J=>{let Q=coerce(J),[tt,te]=decode$9(Q),[tr,tn]=decode$9(Q.subarray(te)),ti=Q.subarray(te+tn);if(ti.byteLength!==tr)throw Error("Incorrect length");return new Digest(tt,tr,ti,Q)},equals$1=(J,Q)=>J===Q||J.code===Q.code&&J.size===Q.size&&equals$2(J.bytes,Q.bytes);class Digest{constructor(J,Q,tt,te){this.code=J,this.size=Q,this.digest=tt,this.bytes=te}}function base(J,Q){if(J.length>=255)throw TypeError("Alphabet too long");for(var tt=new Uint8Array(256),te=0;te<tt.length;te++)tt[te]=255;for(var tr=0;tr<J.length;tr++){var tn=J.charAt(tr),ti=tn.charCodeAt(0);if(255!==tt[ti])throw TypeError(tn+" is ambiguous");tt[ti]=tr}var to=J.length,ts=J.charAt(0),ta=Math.log(to)/Math.log(256),tl=Math.log(256)/Math.log(to);function tu(J){if("string"!=typeof J)throw TypeError("Expected String");if(0===J.length)return new Uint8Array;var Q=0;if(" "!==J[0]){for(var te=0,tr=0;J[Q]===ts;)te++,Q++;for(var tn=(J.length-Q)*ta+1>>>0,ti=new Uint8Array(tn);J[Q];){var tl=tt[J.charCodeAt(Q)];if(255===tl)return;for(var tu=0,tf=tn-1;(0!==tl||tu<tr)&&-1!==tf;tf--,tu++)tl+=to*ti[tf]>>>0,ti[tf]=tl%256>>>0,tl=tl/256>>>0;if(0!==tl)throw Error("Non-zero carry");tr=tu,Q++}if(" "!==J[Q]){for(var th=tn-tr;th!==tn&&0===ti[th];)th++;for(var tc=new Uint8Array(te+(tn-th)),td=te;th!==tn;)tc[td++]=ti[th++];return tc}}}return{encode:function(Q){if(Q instanceof Uint8Array||(ArrayBuffer.isView(Q)?Q=new Uint8Array(Q.buffer,Q.byteOffset,Q.byteLength):Array.isArray(Q)&&(Q=Uint8Array.from(Q))),!(Q instanceof Uint8Array))throw TypeError("Expected Uint8Array");if(0===Q.length)return"";for(var tt=0,te=0,tr=0,tn=Q.length;tr!==tn&&0===Q[tr];)tr++,tt++;for(var ti=(tn-tr)*tl+1>>>0,ta=new Uint8Array(ti);tr!==tn;){for(var tu=Q[tr],tf=0,th=ti-1;(0!==tu||tf<te)&&-1!==th;th--,tf++)tu+=256*ta[th]>>>0,ta[th]=tu%to>>>0,tu=tu/to>>>0;if(0!==tu)throw Error("Non-zero carry");te=tf,tr++}for(var tc=ti-te;tc!==ti&&0===ta[tc];)tc++;for(var td=ts.repeat(tt);tc<ti;++tc)td+=J.charAt(ta[tc]);return td},decodeUnsafe:tu,decode:function(J){var tt=tu(J);if(tt)return tt;throw Error(`Non-${Q} character`)}}}var src$2=base,_brrp__multiformats_scope_baseX=src$2;class Encoder{constructor(J,Q,tt){this.name=J,this.prefix=Q,this.baseEncode=tt}encode(J){if(J instanceof Uint8Array)return`${this.prefix}${this.baseEncode(J)}`;throw Error("Unknown type, must be binary type")}}class Decoder{constructor(J,Q,tt){if(this.name=J,this.prefix=Q,void 0===Q.codePointAt(0))throw Error("Invalid prefix character");this.prefixCodePoint=Q.codePointAt(0),this.baseDecode=tt}decode(J){if("string"==typeof J){if(J.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(J)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(J.slice(this.prefix.length))}throw Error("Can only multibase decode strings")}or(J){return or(this,J)}}class ComposedDecoder{constructor(J){this.decoders=J}or(J){return or(this,J)}decode(J){let Q=J[0],tt=this.decoders[Q];if(tt)return tt.decode(J);throw RangeError(`Unable to decode multibase string ${JSON.stringify(J)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}let or=(J,Q)=>new ComposedDecoder({...J.decoders||{[J.prefix]:J},...Q.decoders||{[Q.prefix]:Q}});class Codec{constructor(J,Q,tt,te){this.name=J,this.prefix=Q,this.baseEncode=tt,this.baseDecode=te,this.encoder=new Encoder(J,Q,tt),this.decoder=new Decoder(J,Q,te)}encode(J){return this.encoder.encode(J)}decode(J){return this.decoder.decode(J)}}let from$1=({name:J,prefix:Q,encode:tt,decode:te})=>new Codec(J,Q,tt,te),baseX=({prefix:J,name:Q,alphabet:tt})=>{let{encode:te,decode:tr}=_brrp__multiformats_scope_baseX(tt,Q);return from$1({prefix:J,name:Q,encode:te,decode:J=>coerce(tr(J))})},decode$7=(J,Q,tt,te)=>{let tr={};for(let J=0;J<Q.length;++J)tr[Q[J]]=J;let tn=J.length;for(;"="===J[tn-1];)--tn;let ti=new Uint8Array(tn*tt/8|0),to=0,ts=0,ta=0;for(let Q=0;Q<tn;++Q){let tn=tr[J[Q]];if(void 0===tn)throw SyntaxError(`Non-${te} character`);ts=ts<<tt|tn,(to+=tt)>=8&&(to-=8,ti[ta++]=255&ts>>to)}if(to>=tt||255&ts<<8-to)throw SyntaxError("Unexpected end of data");return ti},encode$7=(J,Q,tt)=>{let te="="===Q[Q.length-1],tr=(1<<tt)-1,tn="",ti=0,to=0;for(let te=0;te<J.length;++te)for(to=to<<8|J[te],ti+=8;ti>tt;)ti-=tt,tn+=Q[tr&to>>ti];if(ti&&(tn+=Q[tr&to<<tt-ti]),te)for(;tn.length*tt&7;)tn+="=";return tn},rfc4648=({name:J,prefix:Q,bitsPerChar:tt,alphabet:te})=>from$1({prefix:Q,name:J,encode:J=>encode$7(J,te,tt),decode:Q=>decode$7(Q,te,tt,J)}),base58btc=baseX({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),base58flickr=baseX({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var base58=Object.freeze({__proto__:null,base58btc:base58btc,base58flickr:base58flickr});let base32=rfc4648({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),base32upper=rfc4648({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),base32pad=rfc4648({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),base32padupper=rfc4648({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),base32hex=rfc4648({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),base32hexupper=rfc4648({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),base32hexpad=rfc4648({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),base32hexpadupper=rfc4648({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),base32z=rfc4648({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});var base32$1=Object.freeze({__proto__:null,base32:base32,base32upper:base32upper,base32pad:base32pad,base32padupper:base32padupper,base32hex:base32hex,base32hexupper:base32hexupper,base32hexpad:base32hexpad,base32hexpadupper:base32hexpadupper,base32z:base32z});class CID{constructor(J,Q,tt,te){this.code=Q,this.version=J,this.multihash=tt,this.bytes=te,this.byteOffset=te.byteOffset,this.byteLength=te.byteLength,this.asCID=this,this._baseCache=new Map,Object.defineProperties(this,{byteOffset:hidden,byteLength:hidden,code:readonly$1,version:readonly$1,multihash:readonly$1,bytes:readonly$1,_baseCache:hidden,asCID:hidden})}toV0(){if(0===this.version)return this;{let{code:J,multihash:Q}=this;if(J!==DAG_PB_CODE)throw Error("Cannot convert a non dag-pb CID to CIDv0");if(Q.code!==SHA_256_CODE)throw Error("Cannot convert non sha2-256 multihash CID to CIDv0");return CID.createV0(Q)}}toV1(){switch(this.version){case 0:{let{code:J,digest:Q}=this.multihash,tt=create$4(J,Q);return CID.createV1(this.code,tt)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}equals(J){return J&&this.code===J.code&&this.version===J.version&&equals$1(this.multihash,J.multihash)}toString(J){let{bytes:Q,version:tt,_baseCache:te}=this;return 0===tt?toStringV0(Q,te,J||base58btc.encoder):toStringV1(Q,te,J||base32.encoder)}toJSON(){return{code:this.code,version:this.version,hash:this.multihash.bytes}}get[Symbol.toStringTag](){return"CID"}[Symbol.for("nodejs.util.inspect.custom")](){return"CID("+this.toString()+")"}static isCID(J){return deprecate(/^0\.0/,IS_CID_DEPRECATION),!(!J||!J[cidSymbol]&&J.asCID!==J)}get toBaseEncodedString(){throw Error("Deprecated, use .toString()")}get codec(){throw Error('"codec" property is deprecated, use integer "code" property instead')}get buffer(){throw Error("Deprecated .buffer property, use .bytes to get Uint8Array instead")}get multibaseName(){throw Error('"multibaseName" property is deprecated')}get prefix(){throw Error('"prefix" property is deprecated')}static asCID(J){if(J instanceof CID)return J;if(null!=J&&J.asCID===J){let{version:Q,code:tt,multihash:te,bytes:tr}=J;return new CID(Q,tt,te,tr||encodeCID(Q,tt,te.bytes))}if(null!=J&&!0===J[cidSymbol]){let{version:Q,multihash:tt,code:te}=J,tr=decode$8(tt);return CID.create(Q,te,tr)}return null}static create(J,Q,tt){if("number"!=typeof Q)throw Error("String codecs are no longer supported");switch(J){case 0:if(Q!==DAG_PB_CODE)throw Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);return new CID(J,Q,tt,tt.bytes);case 1:{let te=encodeCID(J,Q,tt.bytes);return new CID(J,Q,tt,te)}default:throw Error("Invalid version")}}static createV0(J){return CID.create(0,DAG_PB_CODE,J)}static createV1(J,Q){return CID.create(1,J,Q)}static decode(J){let[Q,tt]=CID.decodeFirst(J);if(tt.length)throw Error("Incorrect length");return Q}static decodeFirst(J){let Q=CID.inspectBytes(J),tt=Q.size-Q.multihashSize,te=coerce(J.subarray(tt,tt+Q.multihashSize));if(te.byteLength!==Q.multihashSize)throw Error("Incorrect length");let tr=te.subarray(Q.multihashSize-Q.digestSize),tn=new Digest(Q.multihashCode,Q.digestSize,tr,te);return[0===Q.version?CID.createV0(tn):CID.createV1(Q.codec,tn),J.subarray(Q.size)]}static inspectBytes(J){let Q=0,tt=()=>{let[tt,te]=decode$9(J.subarray(Q));return Q+=te,tt},te=tt(),tr=DAG_PB_CODE;if(18===te?(te=0,Q=0):1===te&&(tr=tt()),0!==te&&1!==te)throw RangeError(`Invalid CID version ${te}`);let tn=Q,ti=tt(),to=tt(),ts=Q+to;return{version:te,codec:tr,multihashCode:ti,digestSize:to,multihashSize:ts-tn,size:ts}}static parse(J,Q){let[tt,te]=parseCIDtoBytes(J,Q),tr=CID.decode(te);return tr._baseCache.set(tt,J),tr}}let parseCIDtoBytes=(J,Q)=>{switch(J[0]){case"Q":{let tt=Q||base58btc;return[base58btc.prefix,tt.decode(`${base58btc.prefix}${J}`)]}case base58btc.prefix:{let tt=Q||base58btc;return[base58btc.prefix,tt.decode(J)]}case base32.prefix:{let tt=Q||base32;return[base32.prefix,tt.decode(J)]}default:if(null==Q)throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");return[J[0],Q.decode(J)]}},toStringV0=(J,Q,tt)=>{let{prefix:te}=tt;if(te!==base58btc.prefix)throw Error(`Cannot string encode V0 in ${tt.name} encoding`);let tr=Q.get(te);if(null==tr){let tr=tt.encode(J).slice(1);return Q.set(te,tr),tr}return tr},toStringV1=(J,Q,tt)=>{let{prefix:te}=tt,tr=Q.get(te);if(null==tr){let tr=tt.encode(J);return Q.set(te,tr),tr}return tr},DAG_PB_CODE=112,SHA_256_CODE=18,encodeCID=(J,Q,tt)=>{let te=encodingLength(J),tr=te+encodingLength(Q),tn=new Uint8Array(tr+tt.byteLength);return encodeTo(J,tn,0),encodeTo(Q,tn,te),tn.set(tt,tr),tn},cidSymbol=Symbol.for("@ipld/js-cid/CID"),readonly$1={writable:!1,configurable:!1,enumerable:!0},hidden={writable:!1,enumerable:!1,configurable:!1},version="0.0.0-dev",deprecate=(J,Q)=>{if(!J.test(version))throw Error(Q);console.warn(Q)},IS_CID_DEPRECATION="CID.isCID(v) is deprecated and will be removed in the next major release.\nFollowing code pattern:\n\nif (CID.isCID(value)) {\n  doSomethingWithCID(value)\n}\n\nIs replaced with:\n\nconst cid = CID.asCID(value)\nif (cid) {\n  // Make sure to use cid instead of value\n  doSomethingWithCID(cid)\n}\n",typeofs=["string","number","bigint","symbol"],objectTypeNames=["Function","Generator","AsyncGenerator","GeneratorFunction","AsyncGeneratorFunction","AsyncFunction","Observable","Array","Buffer","Object","RegExp","Date","Error","Map","Set","WeakMap","WeakSet","ArrayBuffer","SharedArrayBuffer","DataView","Promise","URL","HTMLElement","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array"];function is(J){if(null===J)return"null";if(void 0===J)return"undefined";if(!0===J||!1===J)return"boolean";let Q=typeof J;if(typeofs.includes(Q))return Q;if("function"===Q)return"Function";if(Array.isArray(J))return"Array";if(isBuffer$1(J))return"Buffer";let tt=getObjectType(J);return tt||"Object"}function isBuffer$1(J){return J&&J.constructor&&J.constructor.isBuffer&&J.constructor.isBuffer.call(null,J)}function getObjectType(J){let Q=Object.prototype.toString.call(J).slice(8,-1);if(objectTypeNames.includes(Q))return Q}class Type{constructor(J,Q,tt){this.major=J,this.majorEncoded=J<<5,this.name=Q,this.terminal=tt}toString(){return`Type[${this.major}].${this.name}`}compare(J){return this.major<J.major?-1:this.major>J.major?1:0}}Type.uint=new Type(0,"uint",!0),Type.negint=new Type(1,"negint",!0),Type.bytes=new Type(2,"bytes",!0),Type.string=new Type(3,"string",!0),Type.array=new Type(4,"array",!1),Type.map=new Type(5,"map",!1),Type.tag=new Type(6,"tag",!1),Type.float=new Type(7,"float",!0),Type.false=new Type(7,"false",!0),Type.true=new Type(7,"true",!0),Type.null=new Type(7,"null",!0),Type.undefined=new Type(7,"undefined",!0),Type.break=new Type(7,"break",!0);class Token{constructor(J,Q,tt){this.type=J,this.value=Q,this.encodedLength=tt,this.encodedBytes=void 0,this.byteValue=void 0}toString(){return`Token[${this.type}].${this.value}`}}let useBuffer=globalThis.process&&!globalThis.process.browser&&globalThis.Buffer&&"function"==typeof globalThis.Buffer.isBuffer,textDecoder$1=new TextDecoder,textEncoder$2=new TextEncoder;function isBuffer(J){return useBuffer&&globalThis.Buffer.isBuffer(J)}function asU8A(J){return J instanceof Uint8Array?isBuffer(J)?new Uint8Array(J.buffer,J.byteOffset,J.byteLength):J:Uint8Array.from(J)}let toString=useBuffer?(J,Q,tt)=>tt-Q>64?globalThis.Buffer.from(J.subarray(Q,tt)).toString("utf8"):utf8Slice(J,Q,tt):(J,Q,tt)=>tt-Q>64?textDecoder$1.decode(J.subarray(Q,tt)):utf8Slice(J,Q,tt),fromString$2=useBuffer?J=>J.length>64?globalThis.Buffer.from(J):utf8ToBytes(J):J=>J.length>64?textEncoder$2.encode(J):utf8ToBytes(J),fromArray=J=>Uint8Array.from(J),slice=useBuffer?(J,Q,tt)=>isBuffer(J)?new Uint8Array(J.subarray(Q,tt)):J.slice(Q,tt):(J,Q,tt)=>J.slice(Q,tt),concat$2=useBuffer?(J,Q)=>(J=J.map(J=>J instanceof Uint8Array?J:globalThis.Buffer.from(J)),asU8A(globalThis.Buffer.concat(J,Q))):(J,Q)=>{let tt=new Uint8Array(Q),te=0;for(let Q of J)te+Q.length>tt.length&&(Q=Q.subarray(0,tt.length-te)),tt.set(Q,te),te+=Q.length;return tt},alloc=useBuffer?J=>globalThis.Buffer.allocUnsafe(J):J=>new Uint8Array(J);function compare(J,Q){if(isBuffer(J)&&isBuffer(Q))return J.compare(Q);for(let tt=0;tt<J.length;tt++)if(J[tt]!==Q[tt])return J[tt]<Q[tt]?-1:1;return 0}function utf8ToBytes(J,Q=1/0){let tt;let te=J.length,tr=null,tn=[];for(let ti=0;ti<te;++ti){if((tt=J.charCodeAt(ti))>55295&&tt<57344){if(!tr){if(tt>56319||ti+1===te){(Q-=3)>-1&&tn.push(239,191,189);continue}tr=tt;continue}if(tt<56320){(Q-=3)>-1&&tn.push(239,191,189),tr=tt;continue}tt=65536+(tr-55296<<10|tt-56320)}else tr&&(Q-=3)>-1&&tn.push(239,191,189);if(tr=null,tt<128){if((Q-=1)<0)break;tn.push(tt)}else if(tt<2048){if((Q-=2)<0)break;tn.push(tt>>6|192,63&tt|128)}else if(tt<65536){if((Q-=3)<0)break;tn.push(tt>>12|224,tt>>6&63|128,63&tt|128)}else{if(!(tt<1114112))throw Error("Invalid code point");if((Q-=4)<0)break;tn.push(tt>>18|240,tt>>12&63|128,tt>>6&63|128,63&tt|128)}}return tn}function utf8Slice(J,Q,tt){let te=[];for(;Q<tt;){let tr=J[Q],tn=null,ti=tr>239?4:tr>223?3:tr>191?2:1;if(Q+ti<=tt){let tt,te,to,ts;switch(ti){case 1:tr<128&&(tn=tr);break;case 2:128==(192&(tt=J[Q+1]))&&(ts=(31&tr)<<6|63&tt)>127&&(tn=ts);break;case 3:tt=J[Q+1],te=J[Q+2],128==(192&tt)&&128==(192&te)&&(ts=(15&tr)<<12|(63&tt)<<6|63&te)>2047&&(ts<55296||ts>57343)&&(tn=ts);break;case 4:tt=J[Q+1],te=J[Q+2],to=J[Q+3],128==(192&tt)&&128==(192&te)&&128==(192&to)&&(ts=(15&tr)<<18|(63&tt)<<12|(63&te)<<6|63&to)>65535&&ts<1114112&&(tn=ts)}}null===tn?(tn=65533,ti=1):tn>65535&&(tn-=65536,te.push(tn>>>10&1023|55296),tn=56320|1023&tn),te.push(tn),Q+=ti}return decodeCodePointsArray(te)}let MAX_ARGUMENTS_LENGTH=4096;function decodeCodePointsArray(J){let Q=J.length;if(Q<=MAX_ARGUMENTS_LENGTH)return String.fromCharCode.apply(String,J);let tt="",te=0;for(;te<Q;)tt+=String.fromCharCode.apply(String,J.slice(te,te+=MAX_ARGUMENTS_LENGTH));return tt}let defaultChunkSize=256;class Bl{constructor(J=defaultChunkSize){this.chunkSize=J,this.cursor=0,this.maxCursor=-1,this.chunks=[],this._initReuseChunk=null}reset(){this.cursor=0,this.maxCursor=-1,this.chunks.length&&(this.chunks=[]),null!==this._initReuseChunk&&(this.chunks.push(this._initReuseChunk),this.maxCursor=this._initReuseChunk.length-1)}push(J){let Q=this.chunks[this.chunks.length-1];if(this.cursor+J.length<=this.maxCursor+1){let tt=Q.length-(this.maxCursor-this.cursor)-1;Q.set(J,tt)}else{if(Q){let J=Q.length-(this.maxCursor-this.cursor)-1;J<Q.length&&(this.chunks[this.chunks.length-1]=Q.subarray(0,J),this.maxCursor=this.cursor-1)}J.length<64&&J.length<this.chunkSize?(Q=alloc(this.chunkSize),this.chunks.push(Q),this.maxCursor+=Q.length,null===this._initReuseChunk&&(this._initReuseChunk=Q),Q.set(J,0)):(this.chunks.push(J),this.maxCursor+=J.length)}this.cursor+=J.length}toBytes(J=!1){let Q;if(1===this.chunks.length){let tt=this.chunks[0];J&&this.cursor>tt.length/2?(Q=this.cursor===tt.length?tt:tt.subarray(0,this.cursor),this._initReuseChunk=null,this.chunks=[]):Q=slice(tt,0,this.cursor)}else Q=concat$2(this.chunks,this.cursor);return J&&this.reset(),Q}}let decodeErrPrefix="CBOR decode error:",encodeErrPrefix="CBOR encode error:";function assertEnoughData(J,Q,tt){if(J.length-Q<tt)throw Error(`${decodeErrPrefix} not enough data for type`)}let uintBoundaries=[24,256,65536,4294967296,BigInt("18446744073709551616")];function readUint8(J,Q,tt){assertEnoughData(J,Q,1);let te=J[Q];if(!0===tt.strict&&te<uintBoundaries[0])throw Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);return te}function readUint16(J,Q,tt){assertEnoughData(J,Q,2);let te=J[Q]<<8|J[Q+1];if(!0===tt.strict&&te<uintBoundaries[1])throw Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);return te}function readUint32(J,Q,tt){assertEnoughData(J,Q,4);let te=16777216*J[Q]+(J[Q+1]<<16)+(J[Q+2]<<8)+J[Q+3];if(!0===tt.strict&&te<uintBoundaries[2])throw Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);return te}function readUint64(J,Q,tt){assertEnoughData(J,Q,8);let te=16777216*J[Q]+(J[Q+1]<<16)+(J[Q+2]<<8)+J[Q+3],tr=16777216*J[Q+4]+(J[Q+5]<<16)+(J[Q+6]<<8)+J[Q+7],tn=(BigInt(te)<<BigInt(32))+BigInt(tr);if(!0===tt.strict&&tn<uintBoundaries[3])throw Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);if(tn<=Number.MAX_SAFE_INTEGER)return Number(tn);if(!0===tt.allowBigInt)return tn;throw Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`)}function decodeUint8(J,Q,tt,te){return new Token(Type.uint,readUint8(J,Q+1,te),2)}function decodeUint16(J,Q,tt,te){return new Token(Type.uint,readUint16(J,Q+1,te),3)}function decodeUint32(J,Q,tt,te){return new Token(Type.uint,readUint32(J,Q+1,te),5)}function decodeUint64(J,Q,tt,te){return new Token(Type.uint,readUint64(J,Q+1,te),9)}function encodeUint(J,Q){return encodeUintValue(J,0,Q.value)}function encodeUintValue(J,Q,tt){if(tt<uintBoundaries[0]){let te=Number(tt);J.push([Q|te])}else if(tt<uintBoundaries[1]){let te=Number(tt);J.push([24|Q,te])}else if(tt<uintBoundaries[2]){let te=Number(tt);J.push([25|Q,te>>>8,255&te])}else if(tt<uintBoundaries[3]){let te=Number(tt);J.push([26|Q,te>>>24&255,te>>>16&255,te>>>8&255,255&te])}else{let te=BigInt(tt);if(!(te<uintBoundaries[4]))throw Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`);{let tt=[27|Q,0,0,0,0,0,0,0],tr=Number(te&BigInt(4294967295)),tn=Number(te>>BigInt(32)&BigInt(4294967295));tt[8]=255&tr,tr>>=8,tt[7]=255&tr,tr>>=8,tt[6]=255&tr,tr>>=8,tt[5]=255&tr,tt[4]=255&tn,tn>>=8,tt[3]=255&tn,tn>>=8,tt[2]=255&tn,tn>>=8,tt[1]=255&tn,J.push(tt)}}}function decodeNegint8(J,Q,tt,te){return new Token(Type.negint,-1-readUint8(J,Q+1,te),2)}function decodeNegint16(J,Q,tt,te){return new Token(Type.negint,-1-readUint16(J,Q+1,te),3)}function decodeNegint32(J,Q,tt,te){return new Token(Type.negint,-1-readUint32(J,Q+1,te),5)}encodeUint.encodedSize=function(J){return encodeUintValue.encodedSize(J.value)},encodeUintValue.encodedSize=function(J){return J<uintBoundaries[0]?1:J<uintBoundaries[1]?2:J<uintBoundaries[2]?3:J<uintBoundaries[3]?5:9},encodeUint.compareTokens=function(J,Q){return J.value<Q.value?-1:J.value>Q.value?1:0};let neg1b=BigInt(-1),pos1b=BigInt(1);function decodeNegint64(J,Q,tt,te){let tr=readUint64(J,Q+1,te);if("bigint"!=typeof tr){let J=-1-tr;if(J>=Number.MIN_SAFE_INTEGER)return new Token(Type.negint,J,9)}if(!0!==te.allowBigInt)throw Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);return new Token(Type.negint,neg1b-BigInt(tr),9)}function encodeNegint(J,Q){let tt=Q.value,te="bigint"==typeof tt?tt*neg1b-pos1b:-1*tt-1;encodeUintValue(J,Q.type.majorEncoded,te)}function toToken$3(J,Q,tt,te){assertEnoughData(J,Q,tt+te);let tr=slice(J,Q+tt,Q+tt+te);return new Token(Type.bytes,tr,tt+te)}function decodeBytesCompact(J,Q,tt,te){return toToken$3(J,Q,1,tt)}function decodeBytes8(J,Q,tt,te){return toToken$3(J,Q,2,readUint8(J,Q+1,te))}function decodeBytes16(J,Q,tt,te){return toToken$3(J,Q,3,readUint16(J,Q+1,te))}function decodeBytes32(J,Q,tt,te){return toToken$3(J,Q,5,readUint32(J,Q+1,te))}function decodeBytes64(J,Q,tt,te){let tr=readUint64(J,Q+1,te);if("bigint"==typeof tr)throw Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);return toToken$3(J,Q,9,tr)}function tokenBytes(J){return void 0===J.encodedBytes&&(J.encodedBytes=J.type===Type.string?fromString$2(J.value):J.value),J.encodedBytes}function encodeBytes(J,Q){let tt=tokenBytes(Q);encodeUintValue(J,Q.type.majorEncoded,tt.length),J.push(tt)}function compareBytes(J,Q){return J.length<Q.length?-1:J.length>Q.length?1:compare(J,Q)}function toToken$2(J,Q,tt,te,tr){let tn=tt+te;assertEnoughData(J,Q,tn);let ti=new Token(Type.string,toString(J,Q+tt,Q+tn),tn);return!0===tr.retainStringBytes&&(ti.byteValue=slice(J,Q+tt,Q+tn)),ti}function decodeStringCompact(J,Q,tt,te){return toToken$2(J,Q,1,tt,te)}function decodeString8(J,Q,tt,te){return toToken$2(J,Q,2,readUint8(J,Q+1,te),te)}function decodeString16(J,Q,tt,te){return toToken$2(J,Q,3,readUint16(J,Q+1,te),te)}function decodeString32(J,Q,tt,te){return toToken$2(J,Q,5,readUint32(J,Q+1,te),te)}function decodeString64(J,Q,tt,te){let tr=readUint64(J,Q+1,te);if("bigint"==typeof tr)throw Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`);return toToken$2(J,Q,9,tr,te)}encodeNegint.encodedSize=function(J){let Q=J.value,tt="bigint"==typeof Q?Q*neg1b-pos1b:-1*Q-1;return tt<uintBoundaries[0]?1:tt<uintBoundaries[1]?2:tt<uintBoundaries[2]?3:tt<uintBoundaries[3]?5:9},encodeNegint.compareTokens=function(J,Q){return J.value<Q.value?1:J.value>Q.value?-1:0},encodeBytes.encodedSize=function(J){let Q=tokenBytes(J);return encodeUintValue.encodedSize(Q.length)+Q.length},encodeBytes.compareTokens=function(J,Q){return compareBytes(tokenBytes(J),tokenBytes(Q))};let encodeString=encodeBytes;function toToken$1(J,Q,tt,te){return new Token(Type.array,te,tt)}function decodeArrayCompact(J,Q,tt,te){return toToken$1(J,Q,1,tt)}function decodeArray8(J,Q,tt,te){return toToken$1(J,Q,2,readUint8(J,Q+1,te))}function decodeArray16(J,Q,tt,te){return toToken$1(J,Q,3,readUint16(J,Q+1,te))}function decodeArray32(J,Q,tt,te){return toToken$1(J,Q,5,readUint32(J,Q+1,te))}function decodeArray64(J,Q,tt,te){let tr=readUint64(J,Q+1,te);if("bigint"==typeof tr)throw Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);return toToken$1(J,Q,9,tr)}function decodeArrayIndefinite(J,Q,tt,te){if(!1===te.allowIndefinite)throw Error(`${decodeErrPrefix} indefinite length items not allowed`);return toToken$1(J,Q,1,1/0)}function encodeArray(J,Q){encodeUintValue(J,Type.array.majorEncoded,Q.value)}function toToken(J,Q,tt,te){return new Token(Type.map,te,tt)}function decodeMapCompact(J,Q,tt,te){return toToken(J,Q,1,tt)}function decodeMap8(J,Q,tt,te){return toToken(J,Q,2,readUint8(J,Q+1,te))}function decodeMap16(J,Q,tt,te){return toToken(J,Q,3,readUint16(J,Q+1,te))}function decodeMap32(J,Q,tt,te){return toToken(J,Q,5,readUint32(J,Q+1,te))}function decodeMap64(J,Q,tt,te){let tr=readUint64(J,Q+1,te);if("bigint"==typeof tr)throw Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`);return toToken(J,Q,9,tr)}function decodeMapIndefinite(J,Q,tt,te){if(!1===te.allowIndefinite)throw Error(`${decodeErrPrefix} indefinite length items not allowed`);return toToken(J,Q,1,1/0)}function encodeMap(J,Q){encodeUintValue(J,Type.map.majorEncoded,Q.value)}function decodeTagCompact(J,Q,tt,te){return new Token(Type.tag,tt,1)}function decodeTag8(J,Q,tt,te){return new Token(Type.tag,readUint8(J,Q+1,te),2)}function decodeTag16(J,Q,tt,te){return new Token(Type.tag,readUint16(J,Q+1,te),3)}function decodeTag32(J,Q,tt,te){return new Token(Type.tag,readUint32(J,Q+1,te),5)}function decodeTag64(J,Q,tt,te){return new Token(Type.tag,readUint64(J,Q+1,te),9)}function encodeTag(J,Q){encodeUintValue(J,Type.tag.majorEncoded,Q.value)}encodeArray.compareTokens=encodeUint.compareTokens,encodeArray.encodedSize=function(J){return encodeUintValue.encodedSize(J.value)},encodeMap.compareTokens=encodeUint.compareTokens,encodeMap.encodedSize=function(J){return encodeUintValue.encodedSize(J.value)},encodeTag.compareTokens=encodeUint.compareTokens,encodeTag.encodedSize=function(J){return encodeUintValue.encodedSize(J.value)};let MINOR_FALSE=20,MINOR_TRUE=21,MINOR_NULL=22,MINOR_UNDEFINED=23;function decodeUndefined(J,Q,tt,te){if(!1===te.allowUndefined)throw Error(`${decodeErrPrefix} undefined values are not supported`);return!0===te.coerceUndefinedToNull?new Token(Type.null,null,1):new Token(Type.undefined,void 0,1)}function decodeBreak(J,Q,tt,te){if(!1===te.allowIndefinite)throw Error(`${decodeErrPrefix} indefinite length items not allowed`);return new Token(Type.break,void 0,1)}function createToken(J,Q,tt){if(tt){if(!1===tt.allowNaN&&Number.isNaN(J))throw Error(`${decodeErrPrefix} NaN values are not supported`);if(!1===tt.allowInfinity&&(J===1/0||J===-1/0))throw Error(`${decodeErrPrefix} Infinity values are not supported`)}return new Token(Type.float,J,Q)}function decodeFloat16(J,Q,tt,te){return createToken(readFloat16(J,Q+1),3,te)}function decodeFloat32(J,Q,tt,te){return createToken(readFloat32(J,Q+1),5,te)}function decodeFloat64(J,Q,tt,te){return createToken(readFloat64(J,Q+1),9,te)}function encodeFloat(J,Q,tt){let te=Q.value;if(!1===te)J.push([Type.float.majorEncoded|MINOR_FALSE]);else if(!0===te)J.push([Type.float.majorEncoded|MINOR_TRUE]);else if(null===te)J.push([Type.float.majorEncoded|MINOR_NULL]);else if(void 0===te)J.push([Type.float.majorEncoded|MINOR_UNDEFINED]);else{let Q,tr=!1;tt&&!0===tt.float64||(encodeFloat16(te),te===(Q=readFloat16(ui8a,1))||Number.isNaN(te)?(ui8a[0]=249,J.push(ui8a.slice(0,3)),tr=!0):(encodeFloat32(te),te===(Q=readFloat32(ui8a,1))&&(ui8a[0]=250,J.push(ui8a.slice(0,5)),tr=!0))),tr||(encodeFloat64(te),Q=readFloat64(ui8a,1),ui8a[0]=251,J.push(ui8a.slice(0,9)))}}encodeFloat.encodedSize=function(J,Q){let tt=J.value;if(!1===tt||!0===tt||null==tt)return 1;if(!Q||!0!==Q.float64){encodeFloat16(tt);let J=readFloat16(ui8a,1);if(tt===J||Number.isNaN(tt))return 3;if(encodeFloat32(tt),tt===(J=readFloat32(ui8a,1)))return 5}return 9};let buffer$1=new ArrayBuffer(9),dataView=new DataView(buffer$1,1),ui8a=new Uint8Array(buffer$1,0);function encodeFloat16(J){if(J===1/0)dataView.setUint16(0,31744,!1);else if(J===-1/0)dataView.setUint16(0,64512,!1);else if(Number.isNaN(J))dataView.setUint16(0,32256,!1);else{dataView.setFloat32(0,J);let Q=dataView.getUint32(0),tt=(2139095040&Q)>>23,te=8388607&Q;if(255===tt)dataView.setUint16(0,31744,!1);else if(0===tt)dataView.setUint16(0,(2147483648&J)>>16|te>>13,!1);else{let J=tt-127;J<-24?dataView.setUint16(0,0):J<-14?dataView.setUint16(0,(2147483648&Q)>>16|1<<24+J,!1):dataView.setUint16(0,(2147483648&Q)>>16|J+15<<10|te>>13,!1)}}}function readFloat16(J,Q){let tt;if(J.length-Q<2)throw Error(`${decodeErrPrefix} not enough data for float16`);let te=(J[Q]<<8)+J[Q+1];if(31744===te)return 1/0;if(64512===te)return-1/0;if(32256===te)return NaN;let tr=te>>10&31,tn=1023&te;return tt=0===tr?5960464477539063e-23*tn:31!==tr?(tn+1024)*2**(tr-25):0===tn?1/0:NaN,32768&te?-tt:tt}function encodeFloat32(J){dataView.setFloat32(0,J,!1)}function readFloat32(J,Q){if(J.length-Q<4)throw Error(`${decodeErrPrefix} not enough data for float32`);let tt=(J.byteOffset||0)+Q;return new DataView(J.buffer,tt,4).getFloat32(0,!1)}function encodeFloat64(J){dataView.setFloat64(0,J,!1)}function readFloat64(J,Q){if(J.length-Q<8)throw Error(`${decodeErrPrefix} not enough data for float64`);let tt=(J.byteOffset||0)+Q;return new DataView(J.buffer,tt,8).getFloat64(0,!1)}function invalidMinor(J,Q,tt){throw Error(`${decodeErrPrefix} encountered invalid minor (${tt}) for major ${J[Q]>>>5}`)}function errorer(J){return()=>{throw Error(`${decodeErrPrefix} ${J}`)}}encodeFloat.compareTokens=encodeUint.compareTokens;let jump=[];for(let e=0;e<=23;e++)jump[e]=invalidMinor;jump[24]=decodeUint8,jump[25]=decodeUint16,jump[26]=decodeUint32,jump[27]=decodeUint64,jump[28]=invalidMinor,jump[29]=invalidMinor,jump[30]=invalidMinor,jump[31]=invalidMinor;for(let e=32;e<=55;e++)jump[e]=invalidMinor;jump[56]=decodeNegint8,jump[57]=decodeNegint16,jump[58]=decodeNegint32,jump[59]=decodeNegint64,jump[60]=invalidMinor,jump[61]=invalidMinor,jump[62]=invalidMinor,jump[63]=invalidMinor;for(let e=64;e<=87;e++)jump[e]=decodeBytesCompact;jump[88]=decodeBytes8,jump[89]=decodeBytes16,jump[90]=decodeBytes32,jump[91]=decodeBytes64,jump[92]=invalidMinor,jump[93]=invalidMinor,jump[94]=invalidMinor,jump[95]=errorer("indefinite length bytes/strings are not supported");for(let e=96;e<=119;e++)jump[e]=decodeStringCompact;jump[120]=decodeString8,jump[121]=decodeString16,jump[122]=decodeString32,jump[123]=decodeString64,jump[124]=invalidMinor,jump[125]=invalidMinor,jump[126]=invalidMinor,jump[127]=errorer("indefinite length bytes/strings are not supported");for(let e=128;e<=151;e++)jump[e]=decodeArrayCompact;jump[152]=decodeArray8,jump[153]=decodeArray16,jump[154]=decodeArray32,jump[155]=decodeArray64,jump[156]=invalidMinor,jump[157]=invalidMinor,jump[158]=invalidMinor,jump[159]=decodeArrayIndefinite;for(let e=160;e<=183;e++)jump[e]=decodeMapCompact;jump[184]=decodeMap8,jump[185]=decodeMap16,jump[186]=decodeMap32,jump[187]=decodeMap64,jump[188]=invalidMinor,jump[189]=invalidMinor,jump[190]=invalidMinor,jump[191]=decodeMapIndefinite;for(let e=192;e<=215;e++)jump[e]=decodeTagCompact;jump[216]=decodeTag8,jump[217]=decodeTag16,jump[218]=decodeTag32,jump[219]=decodeTag64,jump[220]=invalidMinor,jump[221]=invalidMinor,jump[222]=invalidMinor,jump[223]=invalidMinor;for(let e=224;e<=243;e++)jump[e]=errorer("simple values are not supported");jump[244]=invalidMinor,jump[245]=invalidMinor,jump[246]=invalidMinor,jump[247]=decodeUndefined,jump[248]=errorer("simple values are not supported"),jump[249]=decodeFloat16,jump[250]=decodeFloat32,jump[251]=decodeFloat64,jump[252]=invalidMinor,jump[253]=invalidMinor,jump[254]=invalidMinor,jump[255]=decodeBreak;let quick=[];for(let e=0;e<24;e++)quick[e]=new Token(Type.uint,e,1);for(let e=-1;e>=-24;e--)quick[31-e]=new Token(Type.negint,e,1);function quickEncodeToken(J){switch(J.type){case Type.false:return fromArray([244]);case Type.true:return fromArray([245]);case Type.null:return fromArray([246]);case Type.bytes:return J.value.length?void 0:fromArray([64]);case Type.string:return""===J.value?fromArray([96]):void 0;case Type.array:return 0===J.value?fromArray([128]):void 0;case Type.map:return 0===J.value?fromArray([160]):void 0;case Type.uint:return J.value<24?fromArray([Number(J.value)]):void 0;case Type.negint:if(J.value>=-24)return fromArray([31-Number(J.value)])}}quick[64]=new Token(Type.bytes,new Uint8Array(0),1),quick[96]=new Token(Type.string,"",1),quick[128]=new Token(Type.array,0,1),quick[160]=new Token(Type.map,0,1),quick[244]=new Token(Type.false,!1,1),quick[245]=new Token(Type.true,!0,1),quick[246]=new Token(Type.null,null,1);let defaultEncodeOptions={float64:!1,mapSorter:mapSorter,quickEncodeToken:quickEncodeToken};function makeCborEncoders(){let J=[];return J[Type.uint.major]=encodeUint,J[Type.negint.major]=encodeNegint,J[Type.bytes.major]=encodeBytes,J[Type.string.major]=encodeString,J[Type.array.major]=encodeArray,J[Type.map.major]=encodeMap,J[Type.tag.major]=encodeTag,J[Type.float.major]=encodeFloat,J}let cborEncoders=makeCborEncoders(),buf=new Bl;class Ref{constructor(J,Q){this.obj=J,this.parent=Q}includes(J){let Q=this;do if(Q.obj===J)return!0;while(Q=Q.parent);return!1}static createCheck(J,Q){if(J&&J.includes(Q))throw Error(`${encodeErrPrefix} object contains circular references`);return new Ref(Q,J)}}let simpleTokens={null:new Token(Type.null,null),undefined:new Token(Type.undefined,void 0),true:new Token(Type.true,!0),false:new Token(Type.false,!1),emptyArray:new Token(Type.array,0),emptyMap:new Token(Type.map,0)},typeEncoders={number:(J,Q,tt,te)=>Number.isInteger(J)&&Number.isSafeInteger(J)?new Token(J>=0?Type.uint:Type.negint,J):new Token(Type.float,J),bigint:(J,Q,tt,te)=>J>=BigInt(0)?new Token(Type.uint,J):new Token(Type.negint,J),Uint8Array:(J,Q,tt,te)=>new Token(Type.bytes,J),string:(J,Q,tt,te)=>new Token(Type.string,J),boolean:(J,Q,tt,te)=>J?simpleTokens.true:simpleTokens.false,null:(J,Q,tt,te)=>simpleTokens.null,undefined:(J,Q,tt,te)=>simpleTokens.undefined,ArrayBuffer:(J,Q,tt,te)=>new Token(Type.bytes,new Uint8Array(J)),DataView:(J,Q,tt,te)=>new Token(Type.bytes,new Uint8Array(J.buffer,J.byteOffset,J.byteLength)),Array(J,Q,tt,te){if(!J.length)return!0===tt.addBreakTokens?[simpleTokens.emptyArray,new Token(Type.break)]:simpleTokens.emptyArray;te=Ref.createCheck(te,J);let tr=[],tn=0;for(let Q of J)tr[tn++]=objectToTokens(Q,tt,te);return tt.addBreakTokens?[new Token(Type.array,J.length),tr,new Token(Type.break)]:[new Token(Type.array,J.length),tr]},Object(J,Q,tt,te){let tr="Object"!==Q,tn=tr?J.keys():Object.keys(J),ti=tr?J.size:tn.length;if(!ti)return!0===tt.addBreakTokens?[simpleTokens.emptyMap,new Token(Type.break)]:simpleTokens.emptyMap;te=Ref.createCheck(te,J);let to=[],ts=0;for(let Q of tn)to[ts++]=[objectToTokens(Q,tt,te),objectToTokens(tr?J.get(Q):J[Q],tt,te)];return sortMapEntries(to,tt),tt.addBreakTokens?[new Token(Type.map,ti),to,new Token(Type.break)]:[new Token(Type.map,ti),to]}};for(let e of(typeEncoders.Map=typeEncoders.Object,typeEncoders.Buffer=typeEncoders.Uint8Array,"Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")))typeEncoders[`${e}Array`]=typeEncoders.DataView;function objectToTokens(J,Q={},tt){let te=is(J),tr=Q&&Q.typeEncoders&&Q.typeEncoders[te]||typeEncoders[te];if("function"==typeof tr){let tn=tr(J,te,Q,tt);if(null!=tn)return tn}let tn=typeEncoders[te];if(!tn)throw Error(`${encodeErrPrefix} unsupported type: ${te}`);return tn(J,te,Q,tt)}function sortMapEntries(J,Q){Q.mapSorter&&J.sort(Q.mapSorter)}function mapSorter(J,Q){let tt=Array.isArray(J[0])?J[0][0]:J[0],te=Array.isArray(Q[0])?Q[0][0]:Q[0];if(tt.type!==te.type)return tt.type.compare(te.type);let tr=tt.type.major,tn=cborEncoders[tr].compareTokens(tt,te);return 0===tn&&console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone"),tn}function tokensToEncoded(J,Q,tt,te){if(Array.isArray(Q))for(let tr of Q)tokensToEncoded(J,tr,tt,te);else tt[Q.type.major](J,Q,te)}function encodeCustom(J,Q,tt){let te=objectToTokens(J,tt);if(!Array.isArray(te)&&tt.quickEncodeToken){let J=tt.quickEncodeToken(te);if(J)return J;let tr=Q[te.type.major];if(tr.encodedSize){let J=tr.encodedSize(te,tt),Q=new Bl(J);if(tr(Q,te,tt),1!==Q.chunks.length)throw Error(`Unexpected error: pre-calculated length for ${te} was wrong`);return asU8A(Q.chunks[0])}}return buf.reset(),tokensToEncoded(buf,te,Q,tt),buf.toBytes(!0)}function encode$6(J,Q){return encodeCustom(J,cborEncoders,Q=Object.assign({},defaultEncodeOptions,Q))}let defaultDecodeOptions={strict:!1,allowIndefinite:!0,allowUndefined:!0,allowBigInt:!0};class Tokeniser{constructor(J,Q={}){this.pos=0,this.data=J,this.options=Q}done(){return this.pos>=this.data.length}next(){let J=this.data[this.pos],Q=quick[J];if(void 0===Q){let tt=jump[J];if(!tt)throw Error(`${decodeErrPrefix} no decoder for major type ${J>>>5} (byte 0x${J.toString(16).padStart(2,"0")})`);let te=31&J;Q=tt(this.data,this.pos,te,this.options)}return this.pos+=Q.encodedLength,Q}}let DONE=Symbol.for("DONE"),BREAK=Symbol.for("BREAK");function tokenToArray(J,Q,tt){let te=[];for(let tr=0;tr<J.value;tr++){let tn=tokensToObject(Q,tt);if(tn===BREAK){if(J.value===1/0)break;throw Error(`${decodeErrPrefix} got unexpected break to lengthed array`)}if(tn===DONE)throw Error(`${decodeErrPrefix} found array but not enough entries (got ${tr}, expected ${J.value})`);te[tr]=tn}return te}function tokenToMap(J,Q,tt){let te=!0===tt.useMaps,tr=te?void 0:{},tn=te?new Map:void 0;for(let ti=0;ti<J.value;ti++){let to=tokensToObject(Q,tt);if(to===BREAK){if(J.value===1/0)break;throw Error(`${decodeErrPrefix} got unexpected break to lengthed map`)}if(to===DONE)throw Error(`${decodeErrPrefix} found map but not enough entries (got ${ti} [no key], expected ${J.value})`);if(!0!==te&&"string"!=typeof to)throw Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof to})`);let ts=tokensToObject(Q,tt);if(ts===DONE)throw Error(`${decodeErrPrefix} found map but not enough entries (got ${ti} [no value], expected ${J.value})`);te?tn.set(to,ts):tr[to]=ts}return te?tn:tr}function tokensToObject(J,Q){if(J.done())return DONE;let tt=J.next();if(tt.type===Type.break)return BREAK;if(tt.type.terminal)return tt.value;if(tt.type===Type.array)return tokenToArray(tt,J,Q);if(tt.type===Type.map)return tokenToMap(tt,J,Q);if(tt.type===Type.tag){if(Q.tags&&"function"==typeof Q.tags[tt.value]){let te=tokensToObject(J,Q);return Q.tags[tt.value](te)}throw Error(`${decodeErrPrefix} tag not supported (${tt.value})`)}throw Error("unsupported")}function decode$6(J,Q){if(!(J instanceof Uint8Array))throw Error(`${decodeErrPrefix} data to decode must be a Uint8Array`);let tt=(Q=Object.assign({},defaultDecodeOptions,Q)).tokenizer||new Tokeniser(J,Q),te=tokensToObject(tt,Q);if(te===DONE)throw Error(`${decodeErrPrefix} did not find any content to decode`);if(te===BREAK)throw Error(`${decodeErrPrefix} got unexpected break`);if(!tt.done())throw Error(`${decodeErrPrefix} too many terminals, data makes no sense`);return te}let CID_CBOR_TAG$2=42;function cidEncoder$1(J){if(J.asCID!==J)return null;let Q=CID.asCID(J);if(!Q)return null;let tt=new Uint8Array(Q.bytes.byteLength+1);return tt.set(Q.bytes,1),[new Token(Type.tag,CID_CBOR_TAG$2),new Token(Type.bytes,tt)]}function undefinedEncoder$1(){throw Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded")}function numberEncoder$1(J){if(Number.isNaN(J))throw Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");if(J===1/0||J===-1/0)throw Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");return null}let encodeOptions$1={float64:!0,typeEncoders:{Object:cidEncoder$1,undefined:undefinedEncoder$1,number:numberEncoder$1}};function cidDecoder$2(J){if(0!==J[0])throw Error("Invalid CID for CBOR tag 42; expected leading 0x00");return CID.decode(J.subarray(1))}let decodeOptions$2={allowIndefinite:!1,coerceUndefinedToNull:!0,allowNaN:!1,allowInfinity:!1,allowBigInt:!0,strict:!0,useMaps:!1,tags:[]};decodeOptions$2.tags[CID_CBOR_TAG$2]=cidDecoder$2;let encode$5=J=>encode$6(J,encodeOptions$1),decode$5=J=>decode$6(J,decodeOptions$2),CIDV0_BYTES={SHA2_256:18,LENGTH:32,DAG_PB:112};async function readVarint(J){let Q=await J.upTo(8),tt=varint$1.decode(Q);return J.seek(varint$1.decode.bytes),tt}async function readHeader(J){let Q=await readVarint(J);if(0===Q)throw Error("Invalid CAR header (zero length)");let tt=await J.exactly(Q);J.seek(Q);let te=decode$5(tt);if(null==te||Array.isArray(te)||"object"!=typeof te)throw Error("Invalid CAR header format");if(1!==te.version){if("string"==typeof te.version)throw Error(`Invalid CAR version: "${te.version}"`);throw Error(`Invalid CAR version: ${te.version}`)}if(!Array.isArray(te.roots)||Object.keys(te).filter(J=>"roots"!==J&&"version"!==J).length)throw Error("Invalid CAR header format");return te}async function readMultihash(J){let Q=await J.upTo(8);varint$1.decode(Q);let tt=varint$1.decode.bytes,te=varint$1.decode(Q.subarray(varint$1.decode.bytes)),tr=tt+varint$1.decode.bytes+te,tn=await J.exactly(tr);return J.seek(tr),tn}async function readCid(J){let Q=await J.exactly(2);if(Q[0]===CIDV0_BYTES.SHA2_256&&Q[1]===CIDV0_BYTES.LENGTH){let Q=await J.exactly(34);J.seek(34);let tt=decode$8(Q);return CID.create(0,CIDV0_BYTES.DAG_PB,tt)}let tt=await readVarint(J);if(1!==tt)throw Error(`Unexpected CID version (${tt})`);let te=await readVarint(J),tr=await readMultihash(J),tn=decode$8(tr);return CID.create(tt,te,tn)}async function readBlockHead(J){let Q=J.pos,tt=await readVarint(J);if(0===tt)throw Error("Invalid CAR section (zero length)");return tt+=J.pos-Q,{cid:await readCid(J),length:tt,blockLength:tt-(J.pos-Q)}}async function readBlock(J){let{cid:Q,blockLength:tt}=await readBlockHead(J),te=await J.exactly(tt);return J.seek(tt),{bytes:te,cid:Q}}async function readBlockIndex(J){let Q=J.pos,{cid:tt,length:te,blockLength:tr}=await readBlockHead(J),tn={cid:tt,length:te,blockLength:tr,offset:Q,blockOffset:J.pos};return J.seek(tn.blockLength),tn}function createDecoder(J){let Q=readHeader(J);return{header:()=>Q,async *blocks(){for(await Q;(await J.upTo(8)).length>0;)yield await readBlock(J)},async *blocksIndex(){for(await Q;(await J.upTo(8)).length>0;)yield await readBlockIndex(J)}}}function bytesReader(J){let Q=0;return{upTo:async tt=>J.subarray(Q,Q+Math.min(tt,J.length-Q)),async exactly(tt){if(tt>J.length-Q)throw Error("Unexpected end of data");return J.subarray(Q,Q+tt)},seek(J){Q+=J},get pos(){return Q}}}function chunkReader(J){let Q=0,tt=0,te=0,tr=new Uint8Array(0),tn=async Q=>{tt=tr.length-te;let tn=[tr.subarray(te)];for(;tt<Q;){let Q=await J();if(null==Q)break;tt<0?Q.length>tt&&tn.push(Q.subarray(-tt)):tn.push(Q),tt+=Q.length}tr=new Uint8Array(tn.reduce((J,Q)=>J+Q.length,0));let ti=0;for(let J of tn)tr.set(J,ti),ti+=J.length;te=0};return{upTo:async J=>(tr.length-te<J&&await tn(J),tr.subarray(te,te+Math.min(tr.length-te,J))),async exactly(J){if(tr.length-te<J&&await tn(J),tr.length-te<J)throw Error("Unexpected end of data");return tr.subarray(te,te+J)},seek(J){Q+=J,te+=J},get pos(){return Q}}}function asyncIterableReader(J){let Q=J[Symbol.asyncIterator]();return chunkReader(async function(){let J=await Q.next();return J.done?null:J.value})}class CarReader{constructor(J,Q,tt){this._version=J,this._roots=Q,this._blocks=tt,this._keys=tt.map(J=>J.cid.toString())}get version(){return this._version}async getRoots(){return this._roots}async has(J){return this._keys.indexOf(J.toString())>-1}async get(J){let Q=this._keys.indexOf(J.toString());return Q>-1?this._blocks[Q]:void 0}async *blocks(){for(let J of this._blocks)yield J}async *cids(){for(let J of this._blocks)yield J.cid}static async fromBytes(J){if(!(J instanceof Uint8Array))throw TypeError("fromBytes() requires a Uint8Array");return decodeReaderComplete(bytesReader(J))}static async fromIterable(J){if(!J||"function"!=typeof J[Symbol.asyncIterator])throw TypeError("fromIterable() requires an async iterable");return decodeReaderComplete(asyncIterableReader(J))}}async function decodeReaderComplete(J){let Q=createDecoder(J),{version:tt,roots:te}=await Q.header(),tr=[];for await(let J of Q.blocks())tr.push(J);return new CarReader(tt,te,tr)}class CarIteratorBase{constructor(J,Q,tt){this._version=J,this._roots=Q,this._iterable=tt,this._decoded=!1}get version(){return this._version}async getRoots(){return this._roots}}class CarBlockIterator extends CarIteratorBase{[Symbol.asyncIterator](){if(this._decoded)throw Error("Cannot decode more than once");if(!this._iterable)throw Error("Block iterable not found");return this._decoded=!0,this._iterable[Symbol.asyncIterator]()}static async fromBytes(J){let{version:Q,roots:tt,iterator:te}=await fromBytes(J);return new CarBlockIterator(Q,tt,te)}static async fromIterable(J){let{version:Q,roots:tt,iterator:te}=await fromIterable(J);return new CarBlockIterator(Q,tt,te)}}async function fromBytes(J){if(!(J instanceof Uint8Array))throw TypeError("fromBytes() requires a Uint8Array");return decodeIterator(bytesReader(J))}async function fromIterable(J){if(!J||"function"!=typeof J[Symbol.asyncIterator])throw TypeError("fromIterable() requires an async iterable");return decodeIterator(asyncIterableReader(J))}async function decodeIterator(J){let Q=createDecoder(J),{version:tt,roots:te}=await Q.header();return{version:tt,roots:te,iterator:Q.blocks()}}function createHeader(J){let Q=encode$5({version:1,roots:J}),tt=varint$1.encode(Q.length),te=new Uint8Array(tt.length+Q.length);return te.set(tt,0),te.set(Q,tt.length),te}function createEncoder(J){return{async setRoots(Q){let tt=createHeader(Q);await J.write(tt)},async writeBlock(Q){let{cid:tt,bytes:te}=Q;await J.write(new Uint8Array(varint$1.encode(tt.bytes.length+te.length))),await J.write(tt.bytes),te.length&&await J.write(te)},close:async()=>J.end()}}function noop$1(){}function create$3(){let J=[],Q=null,tt=noop$1,te=!1,tr=null,tn=noop$1,ti=()=>(Q||(Q=new Promise(J=>{tt=()=>{Q=null,tt=noop$1,J()}})),Q),to={write(Q){J.push(Q);let tt=ti();return tn(),tt},async end(){te=!0;let J=ti();return tn(),J}},ts={async next(){let Q=J.shift();return Q?(0===J.length&&tt(),{done:!1,value:Q}):te?(tt(),{done:!0,value:void 0}):(tr||(tr=new Promise(J=>{tn=()=>(tr=null,tn=noop$1,J(ts.next()))})),tr)}};return{writer:to,iterator:ts}}class CarWriter{constructor(J,Q){this._encoder=Q,this._mutex=Q.setRoots(J),this._ended=!1}async put(J){if(!(J.bytes instanceof Uint8Array&&J.cid))throw TypeError("Can only write {cid, bytes} objects");if(this._ended)throw Error("Already closed");let Q=CID.asCID(J.cid);if(!Q)throw TypeError("Can only write {cid, bytes} objects");return this._mutex=this._mutex.then(()=>this._encoder.writeBlock({cid:Q,bytes:J.bytes})),this._mutex}async close(){if(this._ended)throw Error("Already closed");return await this._mutex,this._ended=!0,this._encoder.close()}static create(J){J=toRoots(J);let{encoder:Q,iterator:tt}=encodeWriter();return{writer:new CarWriter(J,Q),out:new CarWriterOut(tt)}}static createAppender(){let{encoder:J,iterator:Q}=encodeWriter();return J.setRoots=()=>Promise.resolve(),{writer:new CarWriter([],J),out:new CarWriterOut(Q)}}static async updateRootsInBytes(J,Q){let tt=bytesReader(J);await readHeader(tt);let te=createHeader(Q);if(tt.pos!==te.length)throw Error(`updateRoots() can only overwrite a header of the same length (old header is ${tt.pos} bytes, new header is ${te.length} bytes)`);return J.set(te,0),J}}class CarWriterOut{constructor(J){this._iterator=J}[Symbol.asyncIterator](){if(this._iterating)throw Error("Multiple iterator not supported");return this._iterating=!0,this._iterator}}function encodeWriter(){let J=create$3(),{writer:Q,iterator:tt}=J;return{encoder:createEncoder(Q),iterator:tt}}function toRoots(J){if(void 0===J)return[];if(!Array.isArray(J)){let Q=CID.asCID(J);if(!Q)throw TypeError("roots must be a single CID or an array of CIDs");return[Q]}let Q=[];for(let tt of J){let J=CID.asCID(tt);if(!J)throw TypeError("roots must be a single CID or an array of CIDs");Q.push(J)}return Q}async function*batch$1(J,Q=1){let tt=[];for await(let te of(Q<1&&(Q=1),J))for(tt.push(te);tt.length>=Q;)yield tt.slice(0,Q),tt=tt.slice(Q);for(;tt.length;)yield tt.slice(0,Q),tt=tt.slice(Q)}var itBatch=batch$1;let batch=itBatch;async function*parallelBatch(J,Q=1){for await(let tt of batch(J,Q)){let J=tt.map(J=>J().then(J=>({ok:!0,value:J}),J=>({ok:!1,err:J})));for(let Q=0;Q<J.length;Q++){let tt=await J[Q];if(!tt.ok)throw tt.err;yield tt.value}}}var itParallelBatch=parallelBatch,isPlainObj=J=>{if("[object Object]"!==Object.prototype.toString.call(J))return!1;let Q=Object.getPrototypeOf(J);return null===Q||Q===Object.prototype};let isOptionObject=isPlainObj,{hasOwnProperty:hasOwnProperty}=Object.prototype,{propertyIsEnumerable:propertyIsEnumerable}=Object,defineProperty=(J,Q,tt)=>Object.defineProperty(J,Q,{value:tt,writable:!0,enumerable:!0,configurable:!0}),globalThis$1=commonjsGlobal,defaultMergeOptions={concatArrays:!1,ignoreUndefined:!1},getEnumerableOwnPropertyKeys=J=>{let Q=[];for(let tt in J)hasOwnProperty.call(J,tt)&&Q.push(tt);if(Object.getOwnPropertySymbols){let tt=Object.getOwnPropertySymbols(J);for(let te of tt)propertyIsEnumerable.call(J,te)&&Q.push(te)}return Q};function clone(J){return Array.isArray(J)?cloneArray(J):isOptionObject(J)?cloneOptionObject(J):J}function cloneArray(J){let Q=J.slice(0,0);return getEnumerableOwnPropertyKeys(J).forEach(tt=>{defineProperty(Q,tt,clone(J[tt]))}),Q}function cloneOptionObject(J){let Q=null===Object.getPrototypeOf(J)?Object.create(null):{};return getEnumerableOwnPropertyKeys(J).forEach(tt=>{defineProperty(Q,tt,clone(J[tt]))}),Q}let mergeKeys=(J,Q,tt,te)=>(tt.forEach(tt=>{void 0===Q[tt]&&te.ignoreUndefined||(tt in J&&J[tt]!==Object.getPrototypeOf(J)?defineProperty(J,tt,merge(J[tt],Q[tt],te)):defineProperty(J,tt,clone(Q[tt])))}),J),concatArrays=(J,Q,tt)=>{let te=J.slice(0,0),tr=0;return[J,Q].forEach(Q=>{let tn=[];for(let tt=0;tt<Q.length;tt++)hasOwnProperty.call(Q,tt)&&(tn.push(String(tt)),defineProperty(te,tr++,Q===J?Q[tt]:clone(Q[tt])));te=mergeKeys(te,Q,getEnumerableOwnPropertyKeys(Q).filter(J=>!tn.includes(J)),tt)}),te};function merge(J,Q,tt){return tt.concatArrays&&Array.isArray(J)&&Array.isArray(Q)?concatArrays(J,Q,tt):isOptionObject(Q)&&isOptionObject(J)?mergeKeys(J,Q,getEnumerableOwnPropertyKeys(Q),tt):clone(Q)}var mergeOptions=function(...J){let Q=merge(clone(defaultMergeOptions),this!==globalThis$1&&this||{},defaultMergeOptions),tt={_:{}};for(let te of J)if(void 0!==te){if(!isOptionObject(te))throw TypeError("`"+te+"` is not an Option Object");tt=merge(tt,{_:te},Q)}return tt._};let from=({name:J,code:Q,encode:tt})=>new Hasher(J,Q,tt);class Hasher{constructor(J,Q,tt){this.name=J,this.code=Q,this.encode=tt}digest(J){if(J instanceof Uint8Array){let Q=this.encode(J);return Q instanceof Uint8Array?create$4(this.code,Q):Q.then(J=>create$4(this.code,J))}throw Error("Unknown type, must be binary type")}}let sha=J=>async Q=>new Uint8Array(await crypto.subtle.digest(J,Q)),sha256=from({name:"sha2-256",code:18,encode:sha("SHA-256")}),sha512=from({name:"sha2-512",code:19,encode:sha("SHA-512")});var module,exports,sha2=Object.freeze({__proto__:null,sha256:sha256,sha512:sha512}),murmurHash3js={exports:{}};module=murmurHash3js,exports=murmurHash3js.exports,function(J,Q){var tt={version:"3.0.0",x86:{},x64:{},inputValidation:!0};function te(J){if(!Array.isArray(J)&&!ArrayBuffer.isView(J))return!1;for(var Q=0;Q<J.length;Q++)if(!Number.isInteger(J[Q])||J[Q]<0||J[Q]>255)return!1;return!0}function tr(J,Q){return(65535&J)*Q+(((J>>>16)*Q&65535)<<16)}function tn(J,Q){return J<<Q|J>>>32-Q}function ti(J){return J=tr(J^=J>>>16,2246822507),J=tr(J^=J>>>13,3266489909),J^=J>>>16}function to(J,Q){J=[J[0]>>>16,65535&J[0],J[1]>>>16,65535&J[1]],Q=[Q[0]>>>16,65535&Q[0],Q[1]>>>16,65535&Q[1]];var tt=[0,0,0,0];return tt[3]+=J[3]+Q[3],tt[2]+=tt[3]>>>16,tt[3]&=65535,tt[2]+=J[2]+Q[2],tt[1]+=tt[2]>>>16,tt[2]&=65535,tt[1]+=J[1]+Q[1],tt[0]+=tt[1]>>>16,tt[1]&=65535,tt[0]+=J[0]+Q[0],tt[0]&=65535,[tt[0]<<16|tt[1],tt[2]<<16|tt[3]]}function ts(J,Q){J=[J[0]>>>16,65535&J[0],J[1]>>>16,65535&J[1]],Q=[Q[0]>>>16,65535&Q[0],Q[1]>>>16,65535&Q[1]];var tt=[0,0,0,0];return tt[3]+=J[3]*Q[3],tt[2]+=tt[3]>>>16,tt[3]&=65535,tt[2]+=J[2]*Q[3],tt[1]+=tt[2]>>>16,tt[2]&=65535,tt[2]+=J[3]*Q[2],tt[1]+=tt[2]>>>16,tt[2]&=65535,tt[1]+=J[1]*Q[3],tt[0]+=tt[1]>>>16,tt[1]&=65535,tt[1]+=J[2]*Q[2],tt[0]+=tt[1]>>>16,tt[1]&=65535,tt[1]+=J[3]*Q[1],tt[0]+=tt[1]>>>16,tt[1]&=65535,tt[0]+=J[0]*Q[3]+J[1]*Q[2]+J[2]*Q[1]+J[3]*Q[0],tt[0]&=65535,[tt[0]<<16|tt[1],tt[2]<<16|tt[3]]}function ta(J,Q){return 32==(Q%=64)?[J[1],J[0]]:Q<32?[J[0]<<Q|J[1]>>>32-Q,J[1]<<Q|J[0]>>>32-Q]:(Q-=32,[J[1]<<Q|J[0]>>>32-Q,J[0]<<Q|J[1]>>>32-Q])}function tl(J,Q){return 0==(Q%=64)?J:Q<32?[J[0]<<Q|J[1]>>>32-Q,J[1]<<Q]:[J[1]<<Q-32,0]}function tu(J,Q){return[J[0]^Q[0],J[1]^Q[1]]}function tf(J){return J=tu(J,[0,J[0]>>>1]),J=tu(J=ts(J,[4283543511,3981806797]),[0,J[0]>>>1]),J=tu(J=ts(J,[3301882366,444984403]),[0,J[0]>>>1])}tt.x86.hash32=function(J,to){if(tt.inputValidation&&!te(J))return Q;to=to||0;for(var ts=J.length%4,ta=J.length-ts,tl=to,tu=0,tf=3432918353,th=461845907,tc=0;tc<ta;tc+=4)tu=tr(tu=J[tc]|J[tc+1]<<8|J[tc+2]<<16|J[tc+3]<<24,tf),tu=tr(tu=tn(tu,15),th),tl=tr(tl=tn(tl^=tu,13),5)+3864292196;switch(tu=0,ts){case 3:tu^=J[tc+2]<<16;case 2:tu^=J[tc+1]<<8;case 1:tu=tr(tu^=J[tc],tf),tl^=tu=tr(tu=tn(tu,15),th)}return(tl=ti(tl^=J.length))>>>0},tt.x86.hash128=function(J,to){if(tt.inputValidation&&!te(J))return Q;to=to||0;for(var ts=J.length%16,ta=J.length-ts,tl=to,tu=to,tf=to,th=to,tc=0,td=0,tp=0,ty=0,tg=597399067,tb=2869860233,tm=951274213,tw=2716044179,t_=0;t_<ta;t_+=16)tc=J[t_]|J[t_+1]<<8|J[t_+2]<<16|J[t_+3]<<24,td=J[t_+4]|J[t_+5]<<8|J[t_+6]<<16|J[t_+7]<<24,tp=J[t_+8]|J[t_+9]<<8|J[t_+10]<<16|J[t_+11]<<24,ty=J[t_+12]|J[t_+13]<<8|J[t_+14]<<16|J[t_+15]<<24,tc=tn(tc=tr(tc,tg),15),tl=tn(tl^=tc=tr(tc,tb),19),tl=tr(tl+=tu,5)+1444728091,td=tn(td=tr(td,tb),16),tu=tn(tu^=td=tr(td,tm),17),tu=tr(tu+=tf,5)+197830471,tp=tn(tp=tr(tp,tm),17),tf=tn(tf^=tp=tr(tp,tw),15),tf=tr(tf+=th,5)+2530024501,ty=tn(ty=tr(ty,tw),18),th=tn(th^=ty=tr(ty,tg),13),th=tr(th+=tl,5)+850148119;switch(tc=0,td=0,tp=0,ty=0,ts){case 15:ty^=J[t_+14]<<16;case 14:ty^=J[t_+13]<<8;case 13:ty=tr(ty^=J[t_+12],tw),th^=ty=tr(ty=tn(ty,18),tg);case 12:tp^=J[t_+11]<<24;case 11:tp^=J[t_+10]<<16;case 10:tp^=J[t_+9]<<8;case 9:tp=tr(tp^=J[t_+8],tm),tf^=tp=tr(tp=tn(tp,17),tw);case 8:td^=J[t_+7]<<24;case 7:td^=J[t_+6]<<16;case 6:td^=J[t_+5]<<8;case 5:td=tr(td^=J[t_+4],tb),tu^=td=tr(td=tn(td,16),tm);case 4:tc^=J[t_+3]<<24;case 3:tc^=J[t_+2]<<16;case 2:tc^=J[t_+1]<<8;case 1:tc=tr(tc^=J[t_],tg),tl^=tc=tr(tc=tn(tc,15),tb)}return tl^=J.length,tl+=(tu^=J.length)+(tf^=J.length),tu+=tl+=th^=J.length,tf+=tl,th+=tl,tl=ti(tl)+(tu=ti(tu))+(tf=ti(tf)),tu+=tl+=th=ti(th),tf+=tl,th+=tl,("00000000"+(tl>>>0).toString(16)).slice(-8)+("00000000"+(tu>>>0).toString(16)).slice(-8)+("00000000"+(tf>>>0).toString(16)).slice(-8)+("00000000"+(th>>>0).toString(16)).slice(-8)},tt.x64.hash128=function(J,tr){if(tt.inputValidation&&!te(J))return Q;tr=tr||0;for(var tn=J.length%16,ti=J.length-tn,th=[0,tr],tc=[0,tr],td=[0,0],tp=[0,0],ty=[2277735313,289559509],tg=[1291169091,658871167],tb=0;tb<ti;tb+=16)td=[J[tb+4]|J[tb+5]<<8|J[tb+6]<<16|J[tb+7]<<24,J[tb]|J[tb+1]<<8|J[tb+2]<<16|J[tb+3]<<24],tp=[J[tb+12]|J[tb+13]<<8|J[tb+14]<<16|J[tb+15]<<24,J[tb+8]|J[tb+9]<<8|J[tb+10]<<16|J[tb+11]<<24],td=ta(td=ts(td,ty),31),th=to(th=ta(th=tu(th,td=ts(td,tg)),27),tc),th=to(ts(th,[0,5]),[0,1390208809]),tp=ta(tp=ts(tp,tg),33),tc=to(tc=ta(tc=tu(tc,tp=ts(tp,ty)),31),th),tc=to(ts(tc,[0,5]),[0,944331445]);switch(td=[0,0],tp=[0,0],tn){case 15:tp=tu(tp,tl([0,J[tb+14]],48));case 14:tp=tu(tp,tl([0,J[tb+13]],40));case 13:tp=tu(tp,tl([0,J[tb+12]],32));case 12:tp=tu(tp,tl([0,J[tb+11]],24));case 11:tp=tu(tp,tl([0,J[tb+10]],16));case 10:tp=tu(tp,tl([0,J[tb+9]],8));case 9:tp=ts(tp=tu(tp,[0,J[tb+8]]),tg),tc=tu(tc,tp=ts(tp=ta(tp,33),ty));case 8:td=tu(td,tl([0,J[tb+7]],56));case 7:td=tu(td,tl([0,J[tb+6]],48));case 6:td=tu(td,tl([0,J[tb+5]],40));case 5:td=tu(td,tl([0,J[tb+4]],32));case 4:td=tu(td,tl([0,J[tb+3]],24));case 3:td=tu(td,tl([0,J[tb+2]],16));case 2:td=tu(td,tl([0,J[tb+1]],8));case 1:td=ts(td=tu(td,[0,J[tb]]),ty),th=tu(th,td=ts(td=ta(td,31),tg))}return th=to(th=tu(th,[0,J.length]),tc=tu(tc,[0,J.length])),tc=to(tc,th),th=to(th=tf(th),tc=tf(tc)),tc=to(tc,th),("00000000"+(th[0]>>>0).toString(16)).slice(-8)+("00000000"+(th[1]>>>0).toString(16)).slice(-8)+("00000000"+(tc[0]>>>0).toString(16)).slice(-8)+("00000000"+(tc[1]>>>0).toString(16)).slice(-8)},module.exports&&(exports=module.exports=tt),exports.murmurHash3=tt}();var murmurhash3jsRevisited=murmurHash3js.exports;function fromNumberTo32BitBuf(J){let Q=[,,,,];for(let tt=0;tt<4;tt++)Q[tt]=255&J,J>>=8;return new Uint8Array(Q)}from({name:"murmur3-32",code:35,encode:J=>fromNumberTo32BitBuf(murmurhash3jsRevisited.x86.hash32(J))});let murmur3128=from({name:"murmur3-128",code:34,encode:J=>fromHex(murmurhash3jsRevisited.x64.hash128(J))});async function hamtHashFn(J){return(await murmur3128.encode(J)).slice(0,8).reverse()}let defaultOptions={chunker:"fixed",strategy:"balanced",rawLeaves:!1,onlyHash:!1,reduceSingleLeafToSelf:!0,hasher:sha256,leafType:"file",cidVersion:0,progress:()=>()=>{},shardSplitThreshold:1e3,fileImportConcurrency:50,blockWriteConcurrency:10,minChunkSize:262144,maxChunkSize:262144,avgChunkSize:262144,window:16,polynomial:0x3df305dfb2a804,maxChildrenPerNode:174,layerRepeat:4,wrapWithDirectory:!1,recursive:!1,hidden:!1,timeout:void 0,hamtHashFn:hamtHashFn,hamtHashCode:34,hamtBucketBits:8};var defaultOptions$1=(J={})=>mergeOptions.bind({ignoreUndefined:!0})(defaultOptions,J);function assign(J,Q){for(let tt in Q)Object.defineProperty(J,tt,{value:Q[tt],enumerable:!0,configurable:!0});return J}function createError(J,Q,tt){if(!J||"string"==typeof J)throw TypeError("Please pass an Error to err-code");tt||(tt={}),"object"==typeof Q&&(tt=Q,Q=""),Q&&(tt.code=Q);try{return assign(J,tt)}catch(te){tt.message=J.message,tt.stack=J.stack;let Q=function(){};return Q.prototype=Object.create(Object.getPrototypeOf(J)),assign(new Q,tt)}}var errCode=createError,indexMinimal={},minimal$1={},aspromise=asPromise;function asPromise(J,Q){for(var tt=Array(arguments.length-1),te=0,tr=2,tn=!0;tr<arguments.length;)tt[te++]=arguments[tr++];return new Promise(function(tr,ti){tt[te]=function(J){if(tn){if(tn=!1,J)ti(J);else{for(var Q=Array(arguments.length-1),tt=0;tt<Q.length;)Q[tt++]=arguments[tt];tr.apply(null,Q)}}};try{J.apply(Q||null,tt)}catch(J){tn&&(tn=!1,ti(J))}})}var base64$3={};!function(J){var Q=base64$3;Q.length=function(J){var Q=J.length;if(!Q)return 0;for(var tt=0;--Q%4>1&&"="===J.charAt(Q);)++tt;return Math.ceil(3*J.length)/4-tt};for(var tt=Array(64),te=Array(123),tr=0;tr<64;)te[tt[tr]=tr<26?tr+65:tr<52?tr+71:tr<62?tr-4:tr-59|43]=tr++;Q.encode=function(J,Q,te){for(var tr,tn=null,ti=[],to=0,ts=0;Q<te;){var ta=J[Q++];switch(ts){case 0:ti[to++]=tt[ta>>2],tr=(3&ta)<<4,ts=1;break;case 1:ti[to++]=tt[tr|ta>>4],tr=(15&ta)<<2,ts=2;break;case 2:ti[to++]=tt[tr|ta>>6],ti[to++]=tt[63&ta],ts=0}to>8191&&((tn||(tn=[])).push(String.fromCharCode.apply(String,ti)),to=0)}return ts&&(ti[to++]=tt[tr],ti[to++]=61,1===ts&&(ti[to++]=61)),tn?(to&&tn.push(String.fromCharCode.apply(String,ti.slice(0,to))),tn.join("")):String.fromCharCode.apply(String,ti.slice(0,to))};var tn="invalid encoding";Q.decode=function(J,Q,tt){for(var tr,ti=tt,to=0,ts=0;ts<J.length;){var ta=J.charCodeAt(ts++);if(61===ta&&to>1)break;if(void 0===(ta=te[ta]))throw Error(tn);switch(to){case 0:tr=ta,to=1;break;case 1:Q[tt++]=tr<<2|(48&ta)>>4,tr=ta,to=2;break;case 2:Q[tt++]=(15&tr)<<4|(60&ta)>>2,tr=ta,to=3;break;case 3:Q[tt++]=(3&tr)<<6|ta,to=0}}if(1===to)throw Error(tn);return tt-ti},Q.test=function(J){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(J)}}();var eventemitter=EventEmitter;function EventEmitter(){this._listeners={}}EventEmitter.prototype.on=function(J,Q,tt){return(this._listeners[J]||(this._listeners[J]=[])).push({fn:Q,ctx:tt||this}),this},EventEmitter.prototype.off=function(J,Q){if(void 0===J)this._listeners={};else if(void 0===Q)this._listeners[J]=[];else for(var tt=this._listeners[J],te=0;te<tt.length;)tt[te].fn===Q?tt.splice(te,1):++te;return this},EventEmitter.prototype.emit=function(J){var Q=this._listeners[J];if(Q){for(var tt=[],te=1;te<arguments.length;)tt.push(arguments[te++]);for(te=0;te<Q.length;)Q[te].fn.apply(Q[te++].ctx,tt)}return this};var float=factory(factory);function factory(J){return"undefined"!=typeof Float32Array?function(){var Q=new Float32Array([-0]),tt=new Uint8Array(Q.buffer),te=128===tt[3];function tr(J,te,tr){Q[0]=J,te[tr]=tt[0],te[tr+1]=tt[1],te[tr+2]=tt[2],te[tr+3]=tt[3]}function tn(J,te,tr){Q[0]=J,te[tr]=tt[3],te[tr+1]=tt[2],te[tr+2]=tt[1],te[tr+3]=tt[0]}function ti(J,te){return tt[0]=J[te],tt[1]=J[te+1],tt[2]=J[te+2],tt[3]=J[te+3],Q[0]}function to(J,te){return tt[3]=J[te],tt[2]=J[te+1],tt[1]=J[te+2],tt[0]=J[te+3],Q[0]}J.writeFloatLE=te?tr:tn,J.writeFloatBE=te?tn:tr,J.readFloatLE=te?ti:to,J.readFloatBE=te?to:ti}():function(){function Q(J,Q,tt,te){var tr=Q<0?1:0;if(tr&&(Q=-Q),0===Q)J(1/Q>0?0:2147483648,tt,te);else if(isNaN(Q))J(2143289344,tt,te);else if(Q>34028234663852886e22)J((tr<<31|2139095040)>>>0,tt,te);else if(Q<11754943508222875e-54)J((tr<<31|Math.round(Q/1401298464324817e-60))>>>0,tt,te);else{var tn=Math.floor(Math.log(Q)/Math.LN2);J((tr<<31|tn+127<<23|8388607&Math.round(Q*Math.pow(2,-tn)*8388608))>>>0,tt,te)}}function tt(J,Q,tt){var te=J(Q,tt),tr=2*(te>>31)+1,tn=te>>>23&255,ti=8388607&te;return 255===tn?ti?NaN:tr*(1/0):0===tn?1401298464324817e-60*tr*ti:tr*Math.pow(2,tn-150)*(ti+8388608)}J.writeFloatLE=Q.bind(null,writeUintLE),J.writeFloatBE=Q.bind(null,writeUintBE),J.readFloatLE=tt.bind(null,readUintLE),J.readFloatBE=tt.bind(null,readUintBE)}(),"undefined"!=typeof Float64Array?function(){var Q=new Float64Array([-0]),tt=new Uint8Array(Q.buffer),te=128===tt[7];function tr(J,te,tr){Q[0]=J,te[tr]=tt[0],te[tr+1]=tt[1],te[tr+2]=tt[2],te[tr+3]=tt[3],te[tr+4]=tt[4],te[tr+5]=tt[5],te[tr+6]=tt[6],te[tr+7]=tt[7]}function tn(J,te,tr){Q[0]=J,te[tr]=tt[7],te[tr+1]=tt[6],te[tr+2]=tt[5],te[tr+3]=tt[4],te[tr+4]=tt[3],te[tr+5]=tt[2],te[tr+6]=tt[1],te[tr+7]=tt[0]}function ti(J,te){return tt[0]=J[te],tt[1]=J[te+1],tt[2]=J[te+2],tt[3]=J[te+3],tt[4]=J[te+4],tt[5]=J[te+5],tt[6]=J[te+6],tt[7]=J[te+7],Q[0]}function to(J,te){return tt[7]=J[te],tt[6]=J[te+1],tt[5]=J[te+2],tt[4]=J[te+3],tt[3]=J[te+4],tt[2]=J[te+5],tt[1]=J[te+6],tt[0]=J[te+7],Q[0]}J.writeDoubleLE=te?tr:tn,J.writeDoubleBE=te?tn:tr,J.readDoubleLE=te?ti:to,J.readDoubleBE=te?to:ti}():function(){function Q(J,Q,tt,te,tr,tn){var ti,to=te<0?1:0;if(to&&(te=-te),0===te)J(0,tr,tn+Q),J(1/te>0?0:2147483648,tr,tn+tt);else if(isNaN(te))J(0,tr,tn+Q),J(2146959360,tr,tn+tt);else if(te>17976931348623157e292)J(0,tr,tn+Q),J((to<<31|2146435072)>>>0,tr,tn+tt);else if(te<22250738585072014e-324)J((ti=te/5e-324)>>>0,tr,tn+Q),J((to<<31|ti/4294967296)>>>0,tr,tn+tt);else{var ts=Math.floor(Math.log(te)/Math.LN2);1024===ts&&(ts=1023),J(4503599627370496*(ti=te*Math.pow(2,-ts))>>>0,tr,tn+Q),J((to<<31|ts+1023<<20|1048576*ti&1048575)>>>0,tr,tn+tt)}}function tt(J,Q,tt,te,tr){var tn=J(te,tr+Q),ti=J(te,tr+tt),to=2*(ti>>31)+1,ts=ti>>>20&2047,ta=4294967296*(1048575&ti)+tn;return 2047===ts?ta?NaN:to*(1/0):0===ts?5e-324*to*ta:to*Math.pow(2,ts-1075)*(ta+4503599627370496)}J.writeDoubleLE=Q.bind(null,writeUintLE,0,4),J.writeDoubleBE=Q.bind(null,writeUintBE,4,0),J.readDoubleLE=tt.bind(null,readUintLE,0,4),J.readDoubleBE=tt.bind(null,readUintBE,4,0)}(),J}function writeUintLE(J,Q,tt){Q[tt]=255&J,Q[tt+1]=J>>>8&255,Q[tt+2]=J>>>16&255,Q[tt+3]=J>>>24}function writeUintBE(J,Q,tt){Q[tt]=J>>>24,Q[tt+1]=J>>>16&255,Q[tt+2]=J>>>8&255,Q[tt+3]=255&J}function readUintLE(J,Q){return(J[Q]|J[Q+1]<<8|J[Q+2]<<16|J[Q+3]<<24)>>>0}function readUintBE(J,Q){return(J[Q]<<24|J[Q+1]<<16|J[Q+2]<<8|J[Q+3])>>>0}var inquire_1=inquire;function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(e){}return null}var utf8$2={};!function(J){var Q=utf8$2;Q.length=function(J){for(var Q=0,tt=0,te=0;te<J.length;++te)(tt=J.charCodeAt(te))<128?Q+=1:tt<2048?Q+=2:55296==(64512&tt)&&56320==(64512&J.charCodeAt(te+1))?(++te,Q+=4):Q+=3;return Q},Q.read=function(J,Q,tt){if(tt-Q<1)return"";for(var te,tr=null,tn=[],ti=0;Q<tt;)(te=J[Q++])<128?tn[ti++]=te:te>191&&te<224?tn[ti++]=(31&te)<<6|63&J[Q++]:te>239&&te<365?(te=((7&te)<<18|(63&J[Q++])<<12|(63&J[Q++])<<6|63&J[Q++])-65536,tn[ti++]=55296+(te>>10),tn[ti++]=56320+(1023&te)):tn[ti++]=(15&te)<<12|(63&J[Q++])<<6|63&J[Q++],ti>8191&&((tr||(tr=[])).push(String.fromCharCode.apply(String,tn)),ti=0);return tr?(ti&&tr.push(String.fromCharCode.apply(String,tn.slice(0,ti))),tr.join("")):String.fromCharCode.apply(String,tn.slice(0,ti))},Q.write=function(J,Q,tt){for(var te,tr,tn=tt,ti=0;ti<J.length;++ti)(te=J.charCodeAt(ti))<128?Q[tt++]=te:(te<2048?Q[tt++]=te>>6|192:(55296==(64512&te)&&56320==(64512&(tr=J.charCodeAt(ti+1)))?(te=65536+((1023&te)<<10)+(1023&tr),++ti,Q[tt++]=te>>18|240,Q[tt++]=te>>12&63|128):Q[tt++]=te>>12|224,Q[tt++]=te>>6&63|128),Q[tt++]=63&te|128);return tt-tn}}();var pool_1=pool;function pool(J,Q,tt){var te=tt||8192,tr=te>>>1,tn=null,ti=te;return function(tt){if(tt<1||tt>tr)return J(tt);ti+tt>te&&(tn=J(te),ti=0);var to=Q.call(tn,ti,ti+=tt);return 7&ti&&(ti=1+(7|ti)),to}}var longbits=LongBits$2,util$5=minimal$1;function LongBits$2(J,Q){this.lo=J>>>0,this.hi=Q>>>0}var zero=LongBits$2.zero=new LongBits$2(0,0);zero.toNumber=function(){return 0},zero.zzEncode=zero.zzDecode=function(){return this},zero.length=function(){return 1};var zeroHash=LongBits$2.zeroHash="\x00\x00\x00\x00\x00\x00\x00\x00";LongBits$2.fromNumber=function(J){if(0===J)return zero;var Q=J<0;Q&&(J=-J);var tt=J>>>0,te=(J-tt)/4294967296>>>0;return Q&&(te=~te>>>0,tt=~tt>>>0,++tt>4294967295&&(tt=0,++te>4294967295&&(te=0))),new LongBits$2(tt,te)},LongBits$2.from=function(J){if("number"==typeof J)return LongBits$2.fromNumber(J);if(util$5.isString(J)){if(!util$5.Long)return LongBits$2.fromNumber(parseInt(J,10));J=util$5.Long.fromString(J)}return J.low||J.high?new LongBits$2(J.low>>>0,J.high>>>0):zero},LongBits$2.prototype.toNumber=function(J){if(!J&&this.hi>>>31){var Q=1+~this.lo>>>0,tt=~this.hi>>>0;return Q||(tt=tt+1>>>0),-(Q+4294967296*tt)}return this.lo+4294967296*this.hi},LongBits$2.prototype.toLong=function(J){return util$5.Long?new util$5.Long(0|this.lo,0|this.hi,!!J):{low:0|this.lo,high:0|this.hi,unsigned:!!J}};var charCodeAt=String.prototype.charCodeAt;LongBits$2.fromHash=function(J){return J===zeroHash?zero:new LongBits$2((charCodeAt.call(J,0)|charCodeAt.call(J,1)<<8|charCodeAt.call(J,2)<<16|charCodeAt.call(J,3)<<24)>>>0,(charCodeAt.call(J,4)|charCodeAt.call(J,5)<<8|charCodeAt.call(J,6)<<16|charCodeAt.call(J,7)<<24)>>>0)},LongBits$2.prototype.toHash=function(){return String.fromCharCode(255&this.lo,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,255&this.hi,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},LongBits$2.prototype.zzEncode=function(){var J=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^J)>>>0,this.lo=(this.lo<<1^J)>>>0,this},LongBits$2.prototype.zzDecode=function(){var J=-(1&this.lo);return this.lo=((this.lo>>>1|this.hi<<31)^J)>>>0,this.hi=(this.hi>>>1^J)>>>0,this},LongBits$2.prototype.length=function(){var J=this.lo,Q=(this.lo>>>28|this.hi<<4)>>>0,tt=this.hi>>>24;return 0===tt?0===Q?J<16384?J<128?1:2:J<2097152?3:4:Q<16384?Q<128?5:6:Q<2097152?7:8:tt<128?9:10},function(J){var Q=minimal$1;function tt(J,Q,tt){for(var te=Object.keys(Q),tr=0;tr<te.length;++tr)void 0!==J[te[tr]]&&tt||(J[te[tr]]=Q[te[tr]]);return J}function te(J){function Q(J,te){if(!(this instanceof Q))return new Q(J,te);Object.defineProperty(this,"message",{get:function(){return J}}),Error.captureStackTrace?Error.captureStackTrace(this,Q):Object.defineProperty(this,"stack",{value:Error().stack||""}),te&&tt(this,te)}return(Q.prototype=Object.create(Error.prototype)).constructor=Q,Object.defineProperty(Q.prototype,"name",{get:function(){return J}}),Q.prototype.toString=function(){return this.name+": "+this.message},Q}Q.asPromise=aspromise,Q.base64=base64$3,Q.EventEmitter=eventemitter,Q.float=float,Q.inquire=inquire_1,Q.utf8=utf8$2,Q.pool=pool_1,Q.LongBits=longbits,Q.isNode=!!(void 0!==commonjsGlobal&&commonjsGlobal&&commonjsGlobal.process&&commonjsGlobal.process.versions&&commonjsGlobal.process.versions.node),Q.global=Q.isNode&&commonjsGlobal||"undefined"!=typeof window&&window||"undefined"!=typeof self&&self||commonjsGlobal,Q.emptyArray=Object.freeze?Object.freeze([]):[],Q.emptyObject=Object.freeze?Object.freeze({}):{},Q.isInteger=Number.isInteger||function(J){return"number"==typeof J&&isFinite(J)&&Math.floor(J)===J},Q.isString=function(J){return"string"==typeof J||J instanceof String},Q.isObject=function(J){return J&&"object"==typeof J},Q.isset=Q.isSet=function(J,Q){var tt=J[Q];return!(null==tt||!J.hasOwnProperty(Q))&&("object"!=typeof tt||(Array.isArray(tt)?tt.length:Object.keys(tt).length)>0)},Q.Buffer=function(){try{var J=Q.inquire("buffer").Buffer;return J.prototype.utf8Write?J:null}catch(J){return null}}(),Q._Buffer_from=null,Q._Buffer_allocUnsafe=null,Q.newBuffer=function(J){return"number"==typeof J?Q.Buffer?Q._Buffer_allocUnsafe(J):new Q.Array(J):Q.Buffer?Q._Buffer_from(J):"undefined"==typeof Uint8Array?J:new Uint8Array(J)},Q.Array="undefined"!=typeof Uint8Array?Uint8Array:Array,Q.Long=Q.global.dcodeIO&&Q.global.dcodeIO.Long||Q.global.Long||Q.inquire("long"),Q.key2Re=/^true|false|0|1$/,Q.key32Re=/^-?(?:0|[1-9][0-9]*)$/,Q.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,Q.longToHash=function(J){return J?Q.LongBits.from(J).toHash():Q.LongBits.zeroHash},Q.longFromHash=function(J,tt){var te=Q.LongBits.fromHash(J);return Q.Long?Q.Long.fromBits(te.lo,te.hi,tt):te.toNumber(!!tt)},Q.merge=tt,Q.lcFirst=function(J){return J.charAt(0).toLowerCase()+J.substring(1)},Q.newError=te,Q.ProtocolError=te("ProtocolError"),Q.oneOfGetter=function(J){for(var Q={},tt=0;tt<J.length;++tt)Q[J[tt]]=1;return function(){for(var J=Object.keys(this),tt=J.length-1;tt>-1;--tt)if(1===Q[J[tt]]&&void 0!==this[J[tt]]&&null!==this[J[tt]])return J[tt]}},Q.oneOfSetter=function(J){return function(Q){for(var tt=0;tt<J.length;++tt)J[tt]!==Q&&delete this[J[tt]]}},Q.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},Q._configure=function(){var J=Q.Buffer;J?(Q._Buffer_from=J.from!==Uint8Array.from&&J.from||function(Q,tt){return new J(Q,tt)},Q._Buffer_allocUnsafe=J.allocUnsafe||function(Q){return new J(Q)}):Q._Buffer_from=Q._Buffer_allocUnsafe=null}}();var BufferWriter$1,writer=Writer$1,util$4=minimal$1,LongBits$1=util$4.LongBits,base64$2=util$4.base64,utf8$1=util$4.utf8;function Op(J,Q,tt){this.fn=J,this.len=Q,this.next=void 0,this.val=tt}function noop(){}function State(J){this.head=J.head,this.tail=J.tail,this.len=J.len,this.next=J.states}function Writer$1(){this.len=0,this.head=new Op(noop,0,0),this.tail=this.head,this.states=null}var create$2=function(){return util$4.Buffer?function(){return(Writer$1.create=function(){return new BufferWriter$1})()}:function(){return new Writer$1}};function writeByte(J,Q,tt){Q[tt]=255&J}function writeVarint32(J,Q,tt){for(;J>127;)Q[tt++]=127&J|128,J>>>=7;Q[tt]=J}function VarintOp(J,Q){this.len=J,this.next=void 0,this.val=Q}function writeVarint64(J,Q,tt){for(;J.hi;)Q[tt++]=127&J.lo|128,J.lo=(J.lo>>>7|J.hi<<25)>>>0,J.hi>>>=7;for(;J.lo>127;)Q[tt++]=127&J.lo|128,J.lo=J.lo>>>7;Q[tt++]=J.lo}function writeFixed32(J,Q,tt){Q[tt]=255&J,Q[tt+1]=J>>>8&255,Q[tt+2]=J>>>16&255,Q[tt+3]=J>>>24}Writer$1.create=create$2(),Writer$1.alloc=function(J){return new util$4.Array(J)},util$4.Array!==Array&&(Writer$1.alloc=util$4.pool(Writer$1.alloc,util$4.Array.prototype.subarray)),Writer$1.prototype._push=function(J,Q,tt){return this.tail=this.tail.next=new Op(J,Q,tt),this.len+=Q,this},VarintOp.prototype=Object.create(Op.prototype),VarintOp.prototype.fn=writeVarint32,Writer$1.prototype.uint32=function(J){return this.len+=(this.tail=this.tail.next=new VarintOp((J>>>=0)<128?1:J<16384?2:J<2097152?3:J<268435456?4:5,J)).len,this},Writer$1.prototype.int32=function(J){return J<0?this._push(writeVarint64,10,LongBits$1.fromNumber(J)):this.uint32(J)},Writer$1.prototype.sint32=function(J){return this.uint32((J<<1^J>>31)>>>0)},Writer$1.prototype.uint64=function(J){var Q=LongBits$1.from(J);return this._push(writeVarint64,Q.length(),Q)},Writer$1.prototype.int64=Writer$1.prototype.uint64,Writer$1.prototype.sint64=function(J){var Q=LongBits$1.from(J).zzEncode();return this._push(writeVarint64,Q.length(),Q)},Writer$1.prototype.bool=function(J){return this._push(writeByte,1,J?1:0)},Writer$1.prototype.fixed32=function(J){return this._push(writeFixed32,4,J>>>0)},Writer$1.prototype.sfixed32=Writer$1.prototype.fixed32,Writer$1.prototype.fixed64=function(J){var Q=LongBits$1.from(J);return this._push(writeFixed32,4,Q.lo)._push(writeFixed32,4,Q.hi)},Writer$1.prototype.sfixed64=Writer$1.prototype.fixed64,Writer$1.prototype.float=function(J){return this._push(util$4.float.writeFloatLE,4,J)},Writer$1.prototype.double=function(J){return this._push(util$4.float.writeDoubleLE,8,J)};var writeBytes=util$4.Array.prototype.set?function(J,Q,tt){Q.set(J,tt)}:function(J,Q,tt){for(var te=0;te<J.length;++te)Q[tt+te]=J[te]};Writer$1.prototype.bytes=function(J){var Q=J.length>>>0;if(!Q)return this._push(writeByte,1,0);if(util$4.isString(J)){var tt=Writer$1.alloc(Q=base64$2.length(J));base64$2.decode(J,tt,0),J=tt}return this.uint32(Q)._push(writeBytes,Q,J)},Writer$1.prototype.string=function(J){var Q=utf8$1.length(J);return Q?this.uint32(Q)._push(utf8$1.write,Q,J):this._push(writeByte,1,0)},Writer$1.prototype.fork=function(){return this.states=new State(this),this.head=this.tail=new Op(noop,0,0),this.len=0,this},Writer$1.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new Op(noop,0,0),this.len=0),this},Writer$1.prototype.ldelim=function(){var J=this.head,Q=this.tail,tt=this.len;return this.reset().uint32(tt),tt&&(this.tail.next=J.next,this.tail=Q,this.len+=tt),this},Writer$1.prototype.finish=function(){for(var J=this.head.next,Q=this.constructor.alloc(this.len),tt=0;J;)J.fn(J.val,Q,tt),tt+=J.len,J=J.next;return Q},Writer$1._configure=function(J){BufferWriter$1=J,Writer$1.create=create$2(),BufferWriter$1._configure()};var writer_buffer=BufferWriter,Writer=writer;(BufferWriter.prototype=Object.create(Writer.prototype)).constructor=BufferWriter;var util$3=minimal$1;function BufferWriter(){Writer.call(this)}function writeStringBuffer(J,Q,tt){J.length<40?util$3.utf8.write(J,Q,tt):Q.utf8Write?Q.utf8Write(J,tt):Q.write(J,tt)}BufferWriter._configure=function(){BufferWriter.alloc=util$3._Buffer_allocUnsafe,BufferWriter.writeBytesBuffer=util$3.Buffer&&util$3.Buffer.prototype instanceof Uint8Array&&"set"===util$3.Buffer.prototype.set.name?function(J,Q,tt){Q.set(J,tt)}:function(J,Q,tt){if(J.copy)J.copy(Q,tt,0,J.length);else for(var te=0;te<J.length;)Q[tt++]=J[te++]}},BufferWriter.prototype.bytes=function(J){util$3.isString(J)&&(J=util$3._Buffer_from(J,"base64"));var Q=J.length>>>0;return this.uint32(Q),Q&&this._push(BufferWriter.writeBytesBuffer,Q,J),this},BufferWriter.prototype.string=function(J){var Q=util$3.Buffer.byteLength(J);return this.uint32(Q),Q&&this._push(writeStringBuffer,Q,J),this},BufferWriter._configure();var BufferReader$1,reader=Reader$1,util$2=minimal$1,LongBits=util$2.LongBits,utf8=util$2.utf8;function indexOutOfRange(J,Q){return RangeError("index out of range: "+J.pos+" + "+(Q||1)+" > "+J.len)}function Reader$1(J){this.buf=J,this.pos=0,this.len=J.length}var value,create_array="undefined"!=typeof Uint8Array?function(J){if(J instanceof Uint8Array||Array.isArray(J))return new Reader$1(J);throw Error("illegal buffer")}:function(J){if(Array.isArray(J))return new Reader$1(J);throw Error("illegal buffer")},create$1=function(){return util$2.Buffer?function(J){return(Reader$1.create=function(J){return util$2.Buffer.isBuffer(J)?new BufferReader$1(J):create_array(J)})(J)}:create_array};function readLongVarint(){var J=new LongBits(0,0),Q=0;if(!(this.len-this.pos>4)){for(;Q<3;++Q){if(this.pos>=this.len)throw indexOutOfRange(this);if(J.lo=(J.lo|(127&this.buf[this.pos])<<7*Q)>>>0,this.buf[this.pos++]<128)return J}return J.lo=(J.lo|(127&this.buf[this.pos++])<<7*Q)>>>0,J}for(;Q<4;++Q)if(J.lo=(J.lo|(127&this.buf[this.pos])<<7*Q)>>>0,this.buf[this.pos++]<128)return J;if(J.lo=(J.lo|(127&this.buf[this.pos])<<28)>>>0,J.hi=(J.hi|(127&this.buf[this.pos])>>4)>>>0,this.buf[this.pos++]<128)return J;if(Q=0,this.len-this.pos>4){for(;Q<5;++Q)if(J.hi=(J.hi|(127&this.buf[this.pos])<<7*Q+3)>>>0,this.buf[this.pos++]<128)return J}else for(;Q<5;++Q){if(this.pos>=this.len)throw indexOutOfRange(this);if(J.hi=(J.hi|(127&this.buf[this.pos])<<7*Q+3)>>>0,this.buf[this.pos++]<128)return J}throw Error("invalid varint encoding")}function readFixed32_end(J,Q){return(J[Q-4]|J[Q-3]<<8|J[Q-2]<<16|J[Q-1]<<24)>>>0}function readFixed64(){if(this.pos+8>this.len)throw indexOutOfRange(this,8);return new LongBits(readFixed32_end(this.buf,this.pos+=4),readFixed32_end(this.buf,this.pos+=4))}Reader$1.create=create$1(),Reader$1.prototype._slice=util$2.Array.prototype.subarray||util$2.Array.prototype.slice,Reader$1.prototype.uint32=(value=4294967295,function(){if(value=(127&this.buf[this.pos])>>>0,this.buf[this.pos++]<128||(value=(value|(127&this.buf[this.pos])<<7)>>>0,this.buf[this.pos++]<128)||(value=(value|(127&this.buf[this.pos])<<14)>>>0,this.buf[this.pos++]<128)||(value=(value|(127&this.buf[this.pos])<<21)>>>0,this.buf[this.pos++]<128)||(value=(value|(15&this.buf[this.pos])<<28)>>>0,this.buf[this.pos++]<128))return value;if((this.pos+=5)>this.len)throw this.pos=this.len,indexOutOfRange(this,10);return value}),Reader$1.prototype.int32=function(){return 0|this.uint32()},Reader$1.prototype.sint32=function(){var J=this.uint32();return J>>>1^-(1&J)|0},Reader$1.prototype.bool=function(){return 0!==this.uint32()},Reader$1.prototype.fixed32=function(){if(this.pos+4>this.len)throw indexOutOfRange(this,4);return readFixed32_end(this.buf,this.pos+=4)},Reader$1.prototype.sfixed32=function(){if(this.pos+4>this.len)throw indexOutOfRange(this,4);return 0|readFixed32_end(this.buf,this.pos+=4)},Reader$1.prototype.float=function(){if(this.pos+4>this.len)throw indexOutOfRange(this,4);var J=util$2.float.readFloatLE(this.buf,this.pos);return this.pos+=4,J},Reader$1.prototype.double=function(){if(this.pos+8>this.len)throw indexOutOfRange(this,4);var J=util$2.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,J},Reader$1.prototype.bytes=function(){var J=this.uint32(),Q=this.pos,tt=this.pos+J;if(tt>this.len)throw indexOutOfRange(this,J);return this.pos+=J,Array.isArray(this.buf)?this.buf.slice(Q,tt):Q===tt?new this.buf.constructor(0):this._slice.call(this.buf,Q,tt)},Reader$1.prototype.string=function(){var J=this.bytes();return utf8.read(J,0,J.length)},Reader$1.prototype.skip=function(J){if("number"==typeof J){if(this.pos+J>this.len)throw indexOutOfRange(this,J);this.pos+=J}else do if(this.pos>=this.len)throw indexOutOfRange(this);while(128&this.buf[this.pos++]);return this},Reader$1.prototype.skipType=function(J){switch(J){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;4!=(J=7&this.uint32());)this.skipType(J);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+J+" at offset "+this.pos)}return this},Reader$1._configure=function(J){BufferReader$1=J,Reader$1.create=create$1(),BufferReader$1._configure();var Q=util$2.Long?"toLong":"toNumber";util$2.merge(Reader$1.prototype,{int64:function(){return readLongVarint.call(this)[Q](!1)},uint64:function(){return readLongVarint.call(this)[Q](!0)},sint64:function(){return readLongVarint.call(this).zzDecode()[Q](!1)},fixed64:function(){return readFixed64.call(this)[Q](!0)},sfixed64:function(){return readFixed64.call(this)[Q](!1)}})};var reader_buffer=BufferReader,Reader=reader;(BufferReader.prototype=Object.create(Reader.prototype)).constructor=BufferReader;var util$1=minimal$1;function BufferReader(J){Reader.call(this,J)}BufferReader._configure=function(){util$1.Buffer&&(BufferReader.prototype._slice=util$1.Buffer.prototype.slice)},BufferReader.prototype.string=function(){var J=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+J,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+J,this.len))},BufferReader._configure();var rpc={},service=Service,util=minimal$1;function Service(J,Q,tt){if("function"!=typeof J)throw TypeError("rpcImpl must be a function");util.EventEmitter.call(this),this.rpcImpl=J,this.requestDelimited=!!Q,this.responseDelimited=!!tt}(Service.prototype=Object.create(util.EventEmitter.prototype)).constructor=Service,Service.prototype.rpcCall=function J(Q,tt,te,tr,tn){if(!tr)throw TypeError("request must be specified");var ti=this;if(!tn)return util.asPromise(J,ti,Q,tt,te,tr);if(ti.rpcImpl)try{return ti.rpcImpl(Q,tt[ti.requestDelimited?"encodeDelimited":"encode"](tr).finish(),function(J,tt){if(J)return ti.emit("error",J,Q),tn(J);if(null!==tt){if(!(tt instanceof te))try{tt=te[ti.responseDelimited?"decodeDelimited":"decode"](tt)}catch(J){return ti.emit("error",J,Q),tn(J)}return ti.emit("data",tt,Q),tn(null,tt)}ti.end(!0)})}catch(J){return ti.emit("error",J,Q),void setTimeout(function(){tn(J)},0)}else setTimeout(function(){tn(Error("already ended"))},0)},Service.prototype.end=function(J){return this.rpcImpl&&(J||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this},function(J){J.Service=service}(rpc);var roots={};!function(J){var Q=indexMinimal;function tt(){Q.util._configure(),Q.Writer._configure(Q.BufferWriter),Q.Reader._configure(Q.BufferReader)}Q.build="minimal",Q.Writer=writer,Q.BufferWriter=writer_buffer,Q.Reader=reader,Q.BufferReader=reader_buffer,Q.util=minimal$1,Q.rpc=rpc,Q.roots=roots,Q.configure=tt,tt()}();var minimal=indexMinimal;let $Reader=minimal.Reader,$Writer=minimal.Writer,$util=minimal.util,$root=minimal.roots["ipfs-unixfs"]||(minimal.roots["ipfs-unixfs"]={}),Data=$root.Data=(()=>{function J(J){if(this.blocksizes=[],J)for(var Q=Object.keys(J),tt=0;tt<Q.length;++tt)null!=J[Q[tt]]&&(this[Q[tt]]=J[Q[tt]])}return J.prototype.Type=0,J.prototype.Data=$util.newBuffer([]),J.prototype.filesize=$util.Long?$util.Long.fromBits(0,0,!0):0,J.prototype.blocksizes=$util.emptyArray,J.prototype.hashType=$util.Long?$util.Long.fromBits(0,0,!0):0,J.prototype.fanout=$util.Long?$util.Long.fromBits(0,0,!0):0,J.prototype.mode=0,J.prototype.mtime=null,J.encode=function(J,Q){if(Q||(Q=$Writer.create()),Q.uint32(8).int32(J.Type),null!=J.Data&&Object.hasOwnProperty.call(J,"Data")&&Q.uint32(18).bytes(J.Data),null!=J.filesize&&Object.hasOwnProperty.call(J,"filesize")&&Q.uint32(24).uint64(J.filesize),null!=J.blocksizes&&J.blocksizes.length)for(var tt=0;tt<J.blocksizes.length;++tt)Q.uint32(32).uint64(J.blocksizes[tt]);return null!=J.hashType&&Object.hasOwnProperty.call(J,"hashType")&&Q.uint32(40).uint64(J.hashType),null!=J.fanout&&Object.hasOwnProperty.call(J,"fanout")&&Q.uint32(48).uint64(J.fanout),null!=J.mode&&Object.hasOwnProperty.call(J,"mode")&&Q.uint32(56).uint32(J.mode),null!=J.mtime&&Object.hasOwnProperty.call(J,"mtime")&&$root.UnixTime.encode(J.mtime,Q.uint32(66).fork()).ldelim(),Q},J.decode=function(J,Q){J instanceof $Reader||(J=$Reader.create(J));for(var tt=void 0===Q?J.len:J.pos+Q,te=new $root.Data;J.pos<tt;){var tr=J.uint32();switch(tr>>>3){case 1:te.Type=J.int32();break;case 2:te.Data=J.bytes();break;case 3:te.filesize=J.uint64();break;case 4:if(te.blocksizes&&te.blocksizes.length||(te.blocksizes=[]),2==(7&tr))for(var tn=J.uint32()+J.pos;J.pos<tn;)te.blocksizes.push(J.uint64());else te.blocksizes.push(J.uint64());break;case 5:te.hashType=J.uint64();break;case 6:te.fanout=J.uint64();break;case 7:te.mode=J.uint32();break;case 8:te.mtime=$root.UnixTime.decode(J,J.uint32());break;default:J.skipType(7&tr)}}if(!te.hasOwnProperty("Type"))throw $util.ProtocolError("missing required 'Type'",{instance:te});return te},J.fromObject=function(J){if(J instanceof $root.Data)return J;var Q=new $root.Data;switch(J.Type){case"Raw":case 0:Q.Type=0;break;case"Directory":case 1:Q.Type=1;break;case"File":case 2:Q.Type=2;break;case"Metadata":case 3:Q.Type=3;break;case"Symlink":case 4:Q.Type=4;break;case"HAMTShard":case 5:Q.Type=5}if(null!=J.Data&&("string"==typeof J.Data?$util.base64.decode(J.Data,Q.Data=$util.newBuffer($util.base64.length(J.Data)),0):J.Data.length&&(Q.Data=J.Data)),null!=J.filesize&&($util.Long?(Q.filesize=$util.Long.fromValue(J.filesize)).unsigned=!0:"string"==typeof J.filesize?Q.filesize=parseInt(J.filesize,10):"number"==typeof J.filesize?Q.filesize=J.filesize:"object"==typeof J.filesize&&(Q.filesize=new $util.LongBits(J.filesize.low>>>0,J.filesize.high>>>0).toNumber(!0))),J.blocksizes){if(!Array.isArray(J.blocksizes))throw TypeError(".Data.blocksizes: array expected");Q.blocksizes=[];for(var tt=0;tt<J.blocksizes.length;++tt)$util.Long?(Q.blocksizes[tt]=$util.Long.fromValue(J.blocksizes[tt])).unsigned=!0:"string"==typeof J.blocksizes[tt]?Q.blocksizes[tt]=parseInt(J.blocksizes[tt],10):"number"==typeof J.blocksizes[tt]?Q.blocksizes[tt]=J.blocksizes[tt]:"object"==typeof J.blocksizes[tt]&&(Q.blocksizes[tt]=new $util.LongBits(J.blocksizes[tt].low>>>0,J.blocksizes[tt].high>>>0).toNumber(!0))}if(null!=J.hashType&&($util.Long?(Q.hashType=$util.Long.fromValue(J.hashType)).unsigned=!0:"string"==typeof J.hashType?Q.hashType=parseInt(J.hashType,10):"number"==typeof J.hashType?Q.hashType=J.hashType:"object"==typeof J.hashType&&(Q.hashType=new $util.LongBits(J.hashType.low>>>0,J.hashType.high>>>0).toNumber(!0))),null!=J.fanout&&($util.Long?(Q.fanout=$util.Long.fromValue(J.fanout)).unsigned=!0:"string"==typeof J.fanout?Q.fanout=parseInt(J.fanout,10):"number"==typeof J.fanout?Q.fanout=J.fanout:"object"==typeof J.fanout&&(Q.fanout=new $util.LongBits(J.fanout.low>>>0,J.fanout.high>>>0).toNumber(!0))),null!=J.mode&&(Q.mode=J.mode>>>0),null!=J.mtime){if("object"!=typeof J.mtime)throw TypeError(".Data.mtime: object expected");Q.mtime=$root.UnixTime.fromObject(J.mtime)}return Q},J.toObject=function(J,Q){Q||(Q={});var tt={};if((Q.arrays||Q.defaults)&&(tt.blocksizes=[]),Q.defaults){if(tt.Type=Q.enums===String?"Raw":0,Q.bytes===String?tt.Data="":(tt.Data=[],Q.bytes!==Array&&(tt.Data=$util.newBuffer(tt.Data))),$util.Long){var te=new $util.Long(0,0,!0);tt.filesize=Q.longs===String?te.toString():Q.longs===Number?te.toNumber():te}else tt.filesize=Q.longs===String?"0":0;$util.Long?(te=new $util.Long(0,0,!0),tt.hashType=Q.longs===String?te.toString():Q.longs===Number?te.toNumber():te):tt.hashType=Q.longs===String?"0":0,$util.Long?(te=new $util.Long(0,0,!0),tt.fanout=Q.longs===String?te.toString():Q.longs===Number?te.toNumber():te):tt.fanout=Q.longs===String?"0":0,tt.mode=0,tt.mtime=null}if(null!=J.Type&&J.hasOwnProperty("Type")&&(tt.Type=Q.enums===String?$root.Data.DataType[J.Type]:J.Type),null!=J.Data&&J.hasOwnProperty("Data")&&(tt.Data=Q.bytes===String?$util.base64.encode(J.Data,0,J.Data.length):Q.bytes===Array?Array.prototype.slice.call(J.Data):J.Data),null!=J.filesize&&J.hasOwnProperty("filesize")&&("number"==typeof J.filesize?tt.filesize=Q.longs===String?String(J.filesize):J.filesize:tt.filesize=Q.longs===String?$util.Long.prototype.toString.call(J.filesize):Q.longs===Number?new $util.LongBits(J.filesize.low>>>0,J.filesize.high>>>0).toNumber(!0):J.filesize),J.blocksizes&&J.blocksizes.length){tt.blocksizes=[];for(var tr=0;tr<J.blocksizes.length;++tr)"number"==typeof J.blocksizes[tr]?tt.blocksizes[tr]=Q.longs===String?String(J.blocksizes[tr]):J.blocksizes[tr]:tt.blocksizes[tr]=Q.longs===String?$util.Long.prototype.toString.call(J.blocksizes[tr]):Q.longs===Number?new $util.LongBits(J.blocksizes[tr].low>>>0,J.blocksizes[tr].high>>>0).toNumber(!0):J.blocksizes[tr]}return null!=J.hashType&&J.hasOwnProperty("hashType")&&("number"==typeof J.hashType?tt.hashType=Q.longs===String?String(J.hashType):J.hashType:tt.hashType=Q.longs===String?$util.Long.prototype.toString.call(J.hashType):Q.longs===Number?new $util.LongBits(J.hashType.low>>>0,J.hashType.high>>>0).toNumber(!0):J.hashType),null!=J.fanout&&J.hasOwnProperty("fanout")&&("number"==typeof J.fanout?tt.fanout=Q.longs===String?String(J.fanout):J.fanout:tt.fanout=Q.longs===String?$util.Long.prototype.toString.call(J.fanout):Q.longs===Number?new $util.LongBits(J.fanout.low>>>0,J.fanout.high>>>0).toNumber(!0):J.fanout),null!=J.mode&&J.hasOwnProperty("mode")&&(tt.mode=J.mode),null!=J.mtime&&J.hasOwnProperty("mtime")&&(tt.mtime=$root.UnixTime.toObject(J.mtime,Q)),tt},J.prototype.toJSON=function(){return this.constructor.toObject(this,minimal.util.toJSONOptions)},J.DataType=function(){let J={},Q=Object.create(J);return Q[J[0]="Raw"]=0,Q[J[1]="Directory"]=1,Q[J[2]="File"]=2,Q[J[3]="Metadata"]=3,Q[J[4]="Symlink"]=4,Q[J[5]="HAMTShard"]=5,Q}(),J})();$root.UnixTime=(()=>{function J(J){if(J)for(var Q=Object.keys(J),tt=0;tt<Q.length;++tt)null!=J[Q[tt]]&&(this[Q[tt]]=J[Q[tt]])}return J.prototype.Seconds=$util.Long?$util.Long.fromBits(0,0,!1):0,J.prototype.FractionalNanoseconds=0,J.encode=function(J,Q){return Q||(Q=$Writer.create()),Q.uint32(8).int64(J.Seconds),null!=J.FractionalNanoseconds&&Object.hasOwnProperty.call(J,"FractionalNanoseconds")&&Q.uint32(21).fixed32(J.FractionalNanoseconds),Q},J.decode=function(J,Q){J instanceof $Reader||(J=$Reader.create(J));for(var tt=void 0===Q?J.len:J.pos+Q,te=new $root.UnixTime;J.pos<tt;){var tr=J.uint32();switch(tr>>>3){case 1:te.Seconds=J.int64();break;case 2:te.FractionalNanoseconds=J.fixed32();break;default:J.skipType(7&tr)}}if(!te.hasOwnProperty("Seconds"))throw $util.ProtocolError("missing required 'Seconds'",{instance:te});return te},J.fromObject=function(J){if(J instanceof $root.UnixTime)return J;var Q=new $root.UnixTime;return null!=J.Seconds&&($util.Long?(Q.Seconds=$util.Long.fromValue(J.Seconds)).unsigned=!1:"string"==typeof J.Seconds?Q.Seconds=parseInt(J.Seconds,10):"number"==typeof J.Seconds?Q.Seconds=J.Seconds:"object"==typeof J.Seconds&&(Q.Seconds=new $util.LongBits(J.Seconds.low>>>0,J.Seconds.high>>>0).toNumber())),null!=J.FractionalNanoseconds&&(Q.FractionalNanoseconds=J.FractionalNanoseconds>>>0),Q},J.toObject=function(J,Q){Q||(Q={});var tt={};if(Q.defaults){if($util.Long){var te=new $util.Long(0,0,!1);tt.Seconds=Q.longs===String?te.toString():Q.longs===Number?te.toNumber():te}else tt.Seconds=Q.longs===String?"0":0;tt.FractionalNanoseconds=0}return null!=J.Seconds&&J.hasOwnProperty("Seconds")&&("number"==typeof J.Seconds?tt.Seconds=Q.longs===String?String(J.Seconds):J.Seconds:tt.Seconds=Q.longs===String?$util.Long.prototype.toString.call(J.Seconds):Q.longs===Number?new $util.LongBits(J.Seconds.low>>>0,J.Seconds.high>>>0).toNumber():J.Seconds),null!=J.FractionalNanoseconds&&J.hasOwnProperty("FractionalNanoseconds")&&(tt.FractionalNanoseconds=J.FractionalNanoseconds),tt},J.prototype.toJSON=function(){return this.constructor.toObject(this,minimal.util.toJSONOptions)},J})(),$root.Metadata=(()=>{function J(J){if(J)for(var Q=Object.keys(J),tt=0;tt<Q.length;++tt)null!=J[Q[tt]]&&(this[Q[tt]]=J[Q[tt]])}return J.prototype.MimeType="",J.encode=function(J,Q){return Q||(Q=$Writer.create()),null!=J.MimeType&&Object.hasOwnProperty.call(J,"MimeType")&&Q.uint32(10).string(J.MimeType),Q},J.decode=function(J,Q){J instanceof $Reader||(J=$Reader.create(J));for(var tt=void 0===Q?J.len:J.pos+Q,te=new $root.Metadata;J.pos<tt;){var tr=J.uint32();tr>>>3==1?te.MimeType=J.string():J.skipType(7&tr)}return te},J.fromObject=function(J){if(J instanceof $root.Metadata)return J;var Q=new $root.Metadata;return null!=J.MimeType&&(Q.MimeType=String(J.MimeType)),Q},J.toObject=function(J,Q){Q||(Q={});var tt={};return Q.defaults&&(tt.MimeType=""),null!=J.MimeType&&J.hasOwnProperty("MimeType")&&(tt.MimeType=J.MimeType),tt},J.prototype.toJSON=function(){return this.constructor.toObject(this,minimal.util.toJSONOptions)},J})();let PBData=Data,types=["raw","directory","file","metadata","symlink","hamt-sharded-directory"],dirTypes=["directory","hamt-sharded-directory"],DEFAULT_FILE_MODE=parseInt("0644",8),DEFAULT_DIRECTORY_MODE=parseInt("0755",8);function parseMode(J){if(null!=J)return"number"==typeof J?4095&J:"0"===(J=J.toString()).substring(0,1)?4095&parseInt(J,8):4095&parseInt(J,10)}function parseMtime(J){let Q;if(null!=J){if(null!=J.secs&&(Q={secs:J.secs,nsecs:J.nsecs}),null!=J.Seconds&&(Q={secs:J.Seconds,nsecs:J.FractionalNanoseconds}),Array.isArray(J)&&(Q={secs:J[0],nsecs:J[1]}),J instanceof Date){let tt=J.getTime(),te=Math.floor(tt/1e3);Q={secs:te,nsecs:1e3*(tt-1e3*te)}}if(Object.prototype.hasOwnProperty.call(Q,"secs")){if(null!=Q&&null!=Q.nsecs&&(Q.nsecs<0||Q.nsecs>999999999))throw errCode(Error("mtime-nsecs must be within the range [0,999999999]"),"ERR_INVALID_MTIME_NSECS");return Q}}}class UnixFS{static unmarshal(J){let Q=PBData.decode(J),tt=PBData.toObject(Q,{defaults:!1,arrays:!0,longs:Number,objects:!1}),te=new UnixFS({type:types[tt.Type],data:tt.Data,blockSizes:tt.blocksizes,mode:tt.mode,mtime:tt.mtime?{secs:tt.mtime.Seconds,nsecs:tt.mtime.FractionalNanoseconds}:void 0});return te._originalMode=tt.mode||0,te}constructor(J={type:"file"}){let{type:Q,data:tt,blockSizes:te,hashType:tr,fanout:tn,mtime:ti,mode:to}=J;if(Q&&!types.includes(Q))throw errCode(Error("Type: "+Q+" is not valid"),"ERR_INVALID_TYPE");this.type=Q||"file",this.data=tt,this.hashType=tr,this.fanout=tn,this.blockSizes=te||[],this._originalMode=0,this.mode=parseMode(to),ti&&(this.mtime=parseMtime(ti),this.mtime&&!this.mtime.nsecs&&(this.mtime.nsecs=0))}set mode(J){this._mode=this.isDirectory()?DEFAULT_DIRECTORY_MODE:DEFAULT_FILE_MODE;let Q=parseMode(J);void 0!==Q&&(this._mode=Q)}get mode(){return this._mode}isDirectory(){return!!(this.type&&dirTypes.includes(this.type))}addBlockSize(J){this.blockSizes.push(J)}removeBlockSize(J){this.blockSizes.splice(J,1)}fileSize(){if(this.isDirectory())return 0;let J=0;return this.blockSizes.forEach(Q=>{J+=Q}),this.data&&(J+=this.data.length),J}marshal(){let J;switch(this.type){case"raw":J=PBData.DataType.Raw;break;case"directory":J=PBData.DataType.Directory;break;case"file":J=PBData.DataType.File;break;case"metadata":J=PBData.DataType.Metadata;break;case"symlink":J=PBData.DataType.Symlink;break;case"hamt-sharded-directory":J=PBData.DataType.HAMTShard;break;default:throw errCode(Error("Type: "+J+" is not valid"),"ERR_INVALID_TYPE")}let Q,tt,te=this.data;if(this.data&&this.data.length||(te=void 0),null!=this.mode&&((Q=4294963200&this._originalMode|(parseMode(this.mode)||0))!==DEFAULT_FILE_MODE||this.isDirectory()||(Q=void 0),Q===DEFAULT_DIRECTORY_MODE&&this.isDirectory()&&(Q=void 0)),null!=this.mtime){let J=parseMtime(this.mtime);J&&0===(tt={Seconds:J.secs,FractionalNanoseconds:J.nsecs}).FractionalNanoseconds&&delete tt.FractionalNanoseconds}let tr={Type:J,Data:te,filesize:this.isDirectory()?void 0:this.fileSize(),blocksizes:this.blockSizes,hashType:this.hashType,fanout:this.fanout,mode:Q,mtime:tt};return PBData.encode(tr).finish()}}let textDecoder=new TextDecoder;function decodeVarint(J,Q){let tt=0;for(let te=0;;te+=7){if(te>=64)throw Error("protobuf: varint overflow");if(Q>=J.length)throw Error("protobuf: unexpected end of data");let tr=J[Q++];if(tt+=te<28?(127&tr)<<te:(127&tr)*2**te,tr<128)break}return[tt,Q]}function decodeBytes(J,Q){let tt;[tt,Q]=decodeVarint(J,Q);let te=Q+tt;if(tt<0||te<0)throw Error("protobuf: invalid length");if(te>J.length)throw Error("protobuf: unexpected end of data");return[J.subarray(Q,te),te]}function decodeKey(J,Q){let tt;return[tt,Q]=decodeVarint(J,Q),[7&tt,tt>>3,Q]}function decodeLink(J){let Q={},tt=J.length,te=0;for(;te<tt;){let tt,tr;if([tt,tr,te]=decodeKey(J,te),1===tr){if(Q.Hash)throw Error("protobuf: (PBLink) duplicate Hash section");if(2!==tt)throw Error(`protobuf: (PBLink) wrong wireType (${tt}) for Hash`);if(void 0!==Q.Name)throw Error("protobuf: (PBLink) invalid order, found Name before Hash");if(void 0!==Q.Tsize)throw Error("protobuf: (PBLink) invalid order, found Tsize before Hash");[Q.Hash,te]=decodeBytes(J,te)}else if(2===tr){let tr;if(void 0!==Q.Name)throw Error("protobuf: (PBLink) duplicate Name section");if(2!==tt)throw Error(`protobuf: (PBLink) wrong wireType (${tt}) for Name`);if(void 0!==Q.Tsize)throw Error("protobuf: (PBLink) invalid order, found Tsize before Name");[tr,te]=decodeBytes(J,te),Q.Name=textDecoder.decode(tr)}else{if(3!==tr)throw Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${tr}`);if(void 0!==Q.Tsize)throw Error("protobuf: (PBLink) duplicate Tsize section");if(0!==tt)throw Error(`protobuf: (PBLink) wrong wireType (${tt}) for Tsize`);[Q.Tsize,te]=decodeVarint(J,te)}}if(te>tt)throw Error("protobuf: (PBLink) unexpected end of data");return Q}function decodeNode(J){let Q=J.length,tt,te,tr=0,tn=!1;for(;tr<Q;){let Q,ti;if([Q,ti,tr]=decodeKey(J,tr),2!==Q)throw Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${Q}`);if(1===ti){if(te)throw Error("protobuf: (PBNode) duplicate Data section");[te,tr]=decodeBytes(J,tr),tt&&(tn=!0)}else{if(2!==ti)throw Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${ti}`);{let Q;if(tn)throw Error("protobuf: (PBNode) duplicate Links section");tt||(tt=[]),[Q,tr]=decodeBytes(J,tr),tt.push(decodeLink(Q))}}}if(tr>Q)throw Error("protobuf: (PBNode) unexpected end of data");let ti={};return te&&(ti.Data=te),ti.Links=tt||[],ti}let textEncoder$1=new TextEncoder,maxInt32=4294967296,maxUInt32=2147483648;function encodeLink(J,Q){let tt=Q.length;if("number"==typeof J.Tsize){if(J.Tsize<0)throw Error("Tsize cannot be negative");if(!Number.isSafeInteger(J.Tsize))throw Error("Tsize too large for encoding");tt=encodeVarint(Q,tt,J.Tsize)-1,Q[tt]=24}if("string"==typeof J.Name){let te=textEncoder$1.encode(J.Name);tt-=te.length,Q.set(te,tt),tt=encodeVarint(Q,tt,te.length)-1,Q[tt]=18}return J.Hash&&(tt-=J.Hash.length,Q.set(J.Hash,tt),tt=encodeVarint(Q,tt,J.Hash.length)-1,Q[tt]=10),Q.length-tt}function encodeNode(J){let Q=sizeNode(J),tt=new Uint8Array(Q),te=Q;if(J.Data&&(te-=J.Data.length,tt.set(J.Data,te),te=encodeVarint(tt,te,J.Data.length)-1,tt[te]=10),J.Links)for(let Q=J.Links.length-1;Q>=0;Q--){let tr=encodeLink(J.Links[Q],tt.subarray(0,te));te-=tr,te=encodeVarint(tt,te,tr)-1,tt[te]=18}return tt}function sizeLink(J){let Q=0;if(J.Hash){let tt=J.Hash.length;Q+=1+tt+sov(tt)}if("string"==typeof J.Name){let tt=textEncoder$1.encode(J.Name).length;Q+=1+tt+sov(tt)}return"number"==typeof J.Tsize&&(Q+=1+sov(J.Tsize)),Q}function sizeNode(J){let Q=0;if(J.Data){let tt=J.Data.length;Q+=1+tt+sov(tt)}if(J.Links)for(let tt of J.Links){let J=sizeLink(tt);Q+=1+J+sov(J)}return Q}function encodeVarint(J,Q,tt){let te=Q-=sov(tt);for(;tt>=maxUInt32;)J[Q++]=127&tt|128,tt/=128;for(;tt>=128;)J[Q++]=127&tt|128,tt>>>=7;return J[Q]=tt,te}function sov(J){return J%2==0&&J++,Math.floor((len64(J)+6)/7)}function len64(J){let Q=0;return J>=maxInt32&&(J=Math.floor(J/maxInt32),Q=32),J>=65536&&(J>>>=16,Q+=16),J>=256&&(J>>>=8,Q+=8),Q+len8tab[J]}let len8tab=[0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8],pbNodeProperties=["Data","Links"],pbLinkProperties=["Hash","Name","Tsize"],textEncoder=new TextEncoder;function linkComparator(J,Q){if(J===Q)return 0;let tt=J.Name?textEncoder.encode(J.Name):[],te=Q.Name?textEncoder.encode(Q.Name):[],tr=tt.length,tn=te.length;for(let J=0,Q=Math.min(tr,tn);J<Q;++J)if(tt[J]!==te[J]){tr=tt[J],tn=te[J];break}return tr<tn?-1:tn<tr?1:0}function hasOnlyProperties(J,Q){return!Object.keys(J).some(J=>!Q.includes(J))}function asLink(J){if("object"==typeof J.asCID){let Q=CID.asCID(J);if(!Q)throw TypeError("Invalid DAG-PB form");return{Hash:Q}}if("object"!=typeof J||Array.isArray(J))throw TypeError("Invalid DAG-PB form");let Q={};if(J.Hash){let tt=CID.asCID(J.Hash);try{tt||("string"==typeof J.Hash?tt=CID.parse(J.Hash):J.Hash instanceof Uint8Array&&(tt=CID.decode(J.Hash)))}catch(J){throw TypeError(`Invalid DAG-PB form: ${J.message}`)}tt&&(Q.Hash=tt)}if(!Q.Hash)throw TypeError("Invalid DAG-PB form");return"string"==typeof J.Name&&(Q.Name=J.Name),"number"==typeof J.Tsize&&(Q.Tsize=J.Tsize),Q}function prepare(J){if((J instanceof Uint8Array||"string"==typeof J)&&(J={Data:J}),"object"!=typeof J||Array.isArray(J))throw TypeError("Invalid DAG-PB form");let Q={};if(void 0!==J.Data){if("string"==typeof J.Data)Q.Data=textEncoder.encode(J.Data);else{if(!(J.Data instanceof Uint8Array))throw TypeError("Invalid DAG-PB form");Q.Data=J.Data}}if(void 0!==J.Links){if(!Array.isArray(J.Links))throw TypeError("Invalid DAG-PB form");Q.Links=J.Links.map(asLink),Q.Links.sort(linkComparator)}else Q.Links=[];return Q}function validate(J){if(!J||"object"!=typeof J||Array.isArray(J))throw TypeError("Invalid DAG-PB form");if(!hasOnlyProperties(J,pbNodeProperties))throw TypeError("Invalid DAG-PB form (extraneous properties)");if(void 0!==J.Data&&!(J.Data instanceof Uint8Array))throw TypeError("Invalid DAG-PB form (Data must be a Uint8Array)");if(!Array.isArray(J.Links))throw TypeError("Invalid DAG-PB form (Links must be an array)");for(let Q=0;Q<J.Links.length;Q++){let tt=J.Links[Q];if(!tt||"object"!=typeof tt||Array.isArray(tt))throw TypeError("Invalid DAG-PB form (bad link object)");if(!hasOnlyProperties(tt,pbLinkProperties))throw TypeError("Invalid DAG-PB form (extraneous properties on link object)");if(!tt.Hash)throw TypeError("Invalid DAG-PB form (link must have a Hash)");if(tt.Hash.asCID!==tt.Hash)throw TypeError("Invalid DAG-PB form (link Hash must be a CID)");if(void 0!==tt.Name&&"string"!=typeof tt.Name)throw TypeError("Invalid DAG-PB form (link Name must be a string)");if(void 0!==tt.Tsize&&("number"!=typeof tt.Tsize||tt.Tsize%1!=0))throw TypeError("Invalid DAG-PB form (link Tsize must be an integer)");if(Q>0&&-1===linkComparator(tt,J.Links[Q-1]))throw TypeError("Invalid DAG-PB form (links must be sorted by Name bytes)")}}function createNode(J,Q=[]){return prepare({Data:J,Links:Q})}function createLink(J,Q,tt){return asLink({Hash:tt,Name:J,Tsize:Q})}let name$3="dag-pb",code$5=112;function encode$4(J){validate(J);let Q={};return J.Links&&(Q.Links=J.Links.map(J=>{let Q={};return J.Hash&&(Q.Hash=J.Hash.bytes),void 0!==J.Name&&(Q.Name=J.Name),void 0!==J.Tsize&&(Q.Tsize=J.Tsize),Q})),J.Data&&(Q.Data=J.Data),encodeNode(Q)}function decode$4(J){let Q=decodeNode(J),tt={};return Q.Data&&(tt.Data=Q.Data),Q.Links&&(tt.Links=Q.Links.map(J=>{let Q={};try{Q.Hash=CID.decode(J.Hash)}catch(J){}if(!Q.Hash)throw Error("Invalid Hash field found in link, expected CID");return void 0!==J.Name&&(Q.Name=J.Name),void 0!==J.Tsize&&(Q.Tsize=J.Tsize),Q})),tt}var pb=Object.freeze({__proto__:null,name:name$3,code:code$5,encode:encode$4,decode:decode$4,prepare:prepare,validate:validate,createNode:createNode,createLink:createLink});let persist=async(J,Q,tt)=>{tt.codec||(tt.codec=pb),tt.hasher||(tt.hasher=sha256),void 0===tt.cidVersion&&(tt.cidVersion=1),tt.codec===pb&&tt.hasher!==sha256&&(tt.cidVersion=1);let te=await tt.hasher.digest(J),tr=CID.create(tt.cidVersion,tt.codec.code,te);return tt.onlyHash||await Q.put(tr,J,{signal:tt.signal}),tr},dirBuilder=async(J,Q,tt)=>{let te=new UnixFS({type:"directory",mtime:J.mtime,mode:J.mode}),tr=encode$4(prepare({Data:te.marshal()}));return{cid:await persist(tr,Q,tt),path:J.path,unixfs:te,size:tr.length}},name$2="raw",code$4=85,encode$3=J=>coerce(J),decode$3=J=>coerce(J);var raw=Object.freeze({__proto__:null,name:name$2,code:code$4,encode:encode$3,decode:decode$3});let all=async J=>{let Q=[];for await(let tt of J)Q.push(tt);return Q};var itAll=all;async function flat(J,Q){return Q(await itAll(J))}function balanced(J,Q,tt){return reduceToParents(J,Q,tt)}async function reduceToParents(J,Q,tt){let te=[];for await(let tr of itBatch(J,tt.maxChildrenPerNode))te.push(await Q(tr));return te.length>1?reduceToParents(te,Q,tt):te[0]}async function trickleStream(J,Q,tt){let te=new Root(tt.layerRepeat),tr=0,tn=1,ti=te;for await(let to of itBatch(J,tt.maxChildrenPerNode))ti.isFull()&&(ti!==te&&te.addChild(await ti.reduce(Q)),tr&&tr%tt.layerRepeat==0&&tn++,ti=new SubTree(tn,tt.layerRepeat,tr),tr++),ti.append(to);return ti&&ti!==te&&te.addChild(await ti.reduce(Q)),te.reduce(Q)}class SubTree{constructor(J,Q,tt=0){this.maxDepth=J,this.layerRepeat=Q,this.currentDepth=1,this.iteration=tt,this.root=this.node=this.parent={children:[],depth:this.currentDepth,maxDepth:J,maxChildren:(this.maxDepth-this.currentDepth)*this.layerRepeat}}isFull(){if(!this.root.data)return!1;if(this.currentDepth<this.maxDepth&&this.node.maxChildren)return this._addNextNodeToParent(this.node),!1;let J=this._findParent(this.node,this.currentDepth);return!J||(this._addNextNodeToParent(J),!1)}_addNextNodeToParent(J){this.parent=J;let Q={children:[],depth:J.depth+1,parent:J,maxDepth:this.maxDepth,maxChildren:Math.floor(J.children.length/this.layerRepeat)*this.layerRepeat};J.children.push(Q),this.currentDepth=Q.depth,this.node=Q}append(J){this.node.data=J}reduce(J){return this._reduce(this.root,J)}async _reduce(J,Q){let tt=[];return J.children.length&&(tt=await Promise.all(J.children.filter(J=>J.data).map(J=>this._reduce(J,Q)))),Q((J.data||[]).concat(tt))}_findParent(J,Q){let tt=J.parent;if(tt&&0!==tt.depth)return tt.children.length!==tt.maxChildren&&tt.maxChildren?tt:this._findParent(tt,Q)}}class Root extends SubTree{constructor(J){super(0,J),this.root.depth=0,this.currentDepth=1}addChild(J){this.root.children.push(J)}reduce(J){return J((this.root.data||[]).concat(this.root.children))}}async function*bufferImporter(J,Q,tt){for await(let te of J.content)yield async()=>{let tr;tt.progress(te.length,J.path);let tn={codec:pb,cidVersion:tt.cidVersion,hasher:tt.hasher,onlyHash:tt.onlyHash};return tt.rawLeaves?(tn.codec=raw,tn.cidVersion=1):te=encode$4({Data:(tr=new UnixFS({type:tt.leafType,data:te,mtime:J.mtime,mode:J.mode})).marshal(),Links:[]}),{cid:await persist(te,Q,tn),unixfs:tr,size:te.length}}}let dagBuilders={flat:flat,balanced:balanced,trickle:trickleStream};async function*buildFileBatch(J,Q,tt){let te,tr=-1;for await(let tn of itParallelBatch(("function"==typeof tt.bufferImporter?tt.bufferImporter:bufferImporter)(J,Q,tt),tt.blockWriteConcurrency))0!=++tr?(1===tr&&te&&(yield te,te=null),yield tn):te=tn;te&&(te.single=!0,yield te)}let reduce=(J,Q,tt)=>async function(te){if(1===te.length&&te[0].single&&tt.reduceSingleLeafToSelf){let tr=te[0];if(tr.cid.code===code$4&&(void 0!==J.mtime||void 0!==J.mode)){let te=await Q.get(tr.cid);tr.unixfs=new UnixFS({type:"file",mtime:J.mtime,mode:J.mode,data:te}),te=encode$4(prepare({Data:tr.unixfs.marshal()})),tr.cid=await persist(te,Q,{...tt,codec:pb,hasher:tt.hasher,cidVersion:tt.cidVersion}),tr.size=te.length}return{cid:tr.cid,path:J.path,unixfs:tr.unixfs,size:tr.size}}let tr=new UnixFS({type:"file",mtime:J.mtime,mode:J.mode}),tn=te.filter(J=>!(J.cid.code!==code$4||!J.size)||!(!J.unixfs||J.unixfs.data||!J.unixfs.fileSize())||!!(J.unixfs&&J.unixfs.data&&J.unixfs.data.length)).map(J=>(J.cid.code===code$4?tr.addBlockSize(J.size):J.unixfs&&J.unixfs.data?tr.addBlockSize(J.unixfs.data.length):tr.addBlockSize(J.unixfs&&J.unixfs.fileSize()||0),{Name:"",Tsize:J.size,Hash:J.cid})),ti={Data:tr.marshal(),Links:tn},to=encode$4(prepare(ti));return{cid:await persist(to,Q,tt),path:J.path,unixfs:tr,size:to.length+ti.Links.reduce((J,Q)=>J+Q.Tsize,0)}};function fileBuilder(J,Q,tt){let te=dagBuilders[tt.strategy];if(!te)throw errCode(Error(`Unknown importer build strategy name: ${tt.strategy}`),"ERR_BAD_STRATEGY");return te(buildFileBatch(J,Q,tt),reduce(J,Q,tt),tt)}var buffer={},base64Js={};base64Js.byteLength=byteLength,base64Js.toByteArray=toByteArray,base64Js.fromByteArray=fromByteArray;for(var lookup=[],revLookup=[],Arr="undefined"!=typeof Uint8Array?Uint8Array:Array,code$3="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",i=0,len=code$3.length;i<len;++i)lookup[i]=code$3[i],revLookup[code$3.charCodeAt(i)]=i;function getLens(J){var Q=J.length;if(Q%4>0)throw Error("Invalid string. Length must be a multiple of 4");var tt=J.indexOf("=");return -1===tt&&(tt=Q),[tt,tt===Q?0:4-tt%4]}function byteLength(J){var Q=getLens(J),tt=Q[0],te=Q[1];return 3*(tt+te)/4-te}function _byteLength(J,Q,tt){return 3*(Q+tt)/4-tt}function toByteArray(J){var Q,tt,te=getLens(J),tr=te[0],tn=te[1],ti=new Arr(_byteLength(J,tr,tn)),to=0,ts=tn>0?tr-4:tr;for(tt=0;tt<ts;tt+=4)Q=revLookup[J.charCodeAt(tt)]<<18|revLookup[J.charCodeAt(tt+1)]<<12|revLookup[J.charCodeAt(tt+2)]<<6|revLookup[J.charCodeAt(tt+3)],ti[to++]=Q>>16&255,ti[to++]=Q>>8&255,ti[to++]=255&Q;return 2===tn&&(Q=revLookup[J.charCodeAt(tt)]<<2|revLookup[J.charCodeAt(tt+1)]>>4,ti[to++]=255&Q),1===tn&&(Q=revLookup[J.charCodeAt(tt)]<<10|revLookup[J.charCodeAt(tt+1)]<<4|revLookup[J.charCodeAt(tt+2)]>>2,ti[to++]=Q>>8&255,ti[to++]=255&Q),ti}function tripletToBase64(J){return lookup[J>>18&63]+lookup[J>>12&63]+lookup[J>>6&63]+lookup[63&J]}function encodeChunk(J,Q,tt){for(var te=[],tr=Q;tr<tt;tr+=3)te.push(tripletToBase64((J[tr]<<16&16711680)+(J[tr+1]<<8&65280)+(255&J[tr+2])));return te.join("")}function fromByteArray(J){for(var Q,tt=J.length,te=tt%3,tr=[],tn=16383,ti=0,to=tt-te;ti<to;ti+=tn)tr.push(encodeChunk(J,ti,ti+tn>to?to:ti+tn));return 1===te?tr.push(lookup[(Q=J[tt-1])>>2]+lookup[Q<<4&63]+"=="):2===te&&tr.push(lookup[(Q=(J[tt-2]<<8)+J[tt-1])>>10]+lookup[Q>>4&63]+lookup[Q<<2&63]+"="),tr.join("")}revLookup["-".charCodeAt(0)]=62,revLookup["_".charCodeAt(0)]=63;var ieee754={/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */read:function(J,Q,tt,te,tr){var tn,ti,to=8*tr-te-1,ts=(1<<to)-1,ta=ts>>1,tl=-7,tu=tt?tr-1:0,tf=tt?-1:1,th=J[Q+tu];for(tu+=tf,tn=th&(1<<-tl)-1,th>>=-tl,tl+=to;tl>0;tn=256*tn+J[Q+tu],tu+=tf,tl-=8);for(ti=tn&(1<<-tl)-1,tn>>=-tl,tl+=te;tl>0;ti=256*ti+J[Q+tu],tu+=tf,tl-=8);if(0===tn)tn=1-ta;else{if(tn===ts)return ti?NaN:1/0*(th?-1:1);ti+=Math.pow(2,te),tn-=ta}return(th?-1:1)*ti*Math.pow(2,tn-te)},write:function(J,Q,tt,te,tr,tn){var ti,to,ts,ta=8*tn-tr-1,tl=(1<<ta)-1,tu=tl>>1,tf=23===tr?5960464477539062e-23:0,th=te?0:tn-1,tc=te?1:-1,td=Q<0||0===Q&&1/Q<0?1:0;for(isNaN(Q=Math.abs(Q))||Q===1/0?(to=isNaN(Q)?1:0,ti=tl):(ti=Math.floor(Math.log(Q)/Math.LN2),Q*(ts=Math.pow(2,-ti))<1&&(ti--,ts*=2),(Q+=ti+tu>=1?tf/ts:tf*Math.pow(2,1-tu))*ts>=2&&(ti++,ts/=2),ti+tu>=tl?(to=0,ti=tl):ti+tu>=1?(to=(Q*ts-1)*Math.pow(2,tr),ti+=tu):(to=Q*Math.pow(2,tu-1)*Math.pow(2,tr),ti=0));tr>=8;J[tt+th]=255&to,th+=tc,to/=256,tr-=8);for(ti=ti<<tr|to,ta+=tr;ta>0;J[tt+th]=255&ti,th+=tc,ti/=256,ta-=8);J[tt+th-tc]|=128*td}};/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */!function(J){let Q=base64Js,tt=ieee754,te="function"==typeof Symbol&&"function"==typeof Symbol.for?Symbol.for("nodejs.util.inspect.custom"):null;J.Buffer=ti,J.SlowBuffer=function(J){return+J!=J&&(J=0),ti.alloc(+J)},J.INSPECT_MAX_BYTES=50;let tr=2147483647;function tn(J){if(J>tr)throw RangeError('The value "'+J+'" is invalid for option "size"');let Q=new Uint8Array(J);return Object.setPrototypeOf(Q,ti.prototype),Q}function ti(J,Q,tt){if("number"==typeof J){if("string"==typeof Q)throw TypeError('The "string" argument must be of type string. Received type number');return ta(J)}return to(J,Q,tt)}function to(J,Q,tt){if("string"==typeof J)return function(J,Q){if("string"==typeof Q&&""!==Q||(Q="utf8"),!ti.isEncoding(Q))throw TypeError("Unknown encoding: "+Q);let tt=0|th(J,Q),te=tn(tt),tr=te.write(J,Q);return tr!==tt&&(te=te.slice(0,tr)),te}(J,Q);if(ArrayBuffer.isView(J))return function(J){if(tG(J,Uint8Array)){let Q=new Uint8Array(J);return tu(Q.buffer,Q.byteOffset,Q.byteLength)}return tl(J)}(J);if(null==J)throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof J);if(tG(J,ArrayBuffer)||J&&tG(J.buffer,ArrayBuffer)||"undefined"!=typeof SharedArrayBuffer&&(tG(J,SharedArrayBuffer)||J&&tG(J.buffer,SharedArrayBuffer)))return tu(J,Q,tt);if("number"==typeof J)throw TypeError('The "value" argument must not be of type number. Received type number');let te=J.valueOf&&J.valueOf();if(null!=te&&te!==J)return ti.from(te,Q,tt);let tr=function(J){if(ti.isBuffer(J)){let Q=0|tf(J.length),tt=tn(Q);return 0===tt.length||J.copy(tt,0,0,Q),tt}return void 0!==J.length?"number"!=typeof J.length||tW(J.length)?tn(0):tl(J):"Buffer"===J.type&&Array.isArray(J.data)?tl(J.data):void 0}(J);if(tr)return tr;if("undefined"!=typeof Symbol&&null!=Symbol.toPrimitive&&"function"==typeof J[Symbol.toPrimitive])return ti.from(J[Symbol.toPrimitive]("string"),Q,tt);throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof J)}function ts(J){if("number"!=typeof J)throw TypeError('"size" argument must be of type number');if(J<0)throw RangeError('The value "'+J+'" is invalid for option "size"')}function ta(J){return ts(J),tn(J<0?0:0|tf(J))}function tl(J){let Q=J.length<0?0:0|tf(J.length),tt=tn(Q);for(let te=0;te<Q;te+=1)tt[te]=255&J[te];return tt}function tu(J,Q,tt){let te;if(Q<0||J.byteLength<Q)throw RangeError('"offset" is outside of buffer bounds');if(J.byteLength<Q+(tt||0))throw RangeError('"length" is outside of buffer bounds');return Object.setPrototypeOf(te=void 0===Q&&void 0===tt?new Uint8Array(J):void 0===tt?new Uint8Array(J,Q):new Uint8Array(J,Q,tt),ti.prototype),te}function tf(J){if(J>=tr)throw RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+tr.toString(16)+" bytes");return 0|J}function th(J,Q){if(ti.isBuffer(J))return J.length;if(ArrayBuffer.isView(J)||tG(J,ArrayBuffer))return J.byteLength;if("string"!=typeof J)throw TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof J);let tt=J.length,te=arguments.length>2&&!0===arguments[2];if(!te&&0===tt)return 0;let tr=!1;for(;;)switch(Q){case"ascii":case"latin1":case"binary":return tt;case"utf8":case"utf-8":return tF(J).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*tt;case"hex":return tt>>>1;case"base64":return tH(J).length;default:if(tr)return te?-1:tF(J).length;Q=(""+Q).toLowerCase(),tr=!0}}function tc(J,Q,tt){let te=!1;if((void 0===Q||Q<0)&&(Q=0),Q>this.length||((void 0===tt||tt>this.length)&&(tt=this.length),tt<=0)||(tt>>>=0)<=(Q>>>=0))return"";for(J||(J="utf8");;)switch(J){case"hex":return tS(this,Q,tt);case"utf8":case"utf-8":return tE(this,Q,tt);case"ascii":return tk(this,Q,tt);case"latin1":case"binary":return tB(this,Q,tt);case"base64":return tv(this,Q,tt);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return tT(this,Q,tt);default:if(te)throw TypeError("Unknown encoding: "+J);J=(J+"").toLowerCase(),te=!0}}function td(J,Q,tt){let te=J[Q];J[Q]=J[tt],J[tt]=te}function tp(J,Q,tt,te,tr){if(0===J.length)return -1;if("string"==typeof tt?(te=tt,tt=0):tt>2147483647?tt=2147483647:tt<-2147483648&&(tt=-2147483648),tW(tt=+tt)&&(tt=tr?0:J.length-1),tt<0&&(tt=J.length+tt),tt>=J.length){if(tr)return -1;tt=J.length-1}else if(tt<0){if(!tr)return -1;tt=0}if("string"==typeof Q&&(Q=ti.from(Q,te)),ti.isBuffer(Q))return 0===Q.length?-1:ty(J,Q,tt,te,tr);if("number"==typeof Q)return Q&=255,"function"==typeof Uint8Array.prototype.indexOf?tr?Uint8Array.prototype.indexOf.call(J,Q,tt):Uint8Array.prototype.lastIndexOf.call(J,Q,tt):ty(J,[Q],tt,te,tr);throw TypeError("val must be string, number or Buffer")}function ty(J,Q,tt,te,tr){let tn,ti=1,to=J.length,ts=Q.length;if(void 0!==te&&("ucs2"===(te=String(te).toLowerCase())||"ucs-2"===te||"utf16le"===te||"utf-16le"===te)){if(J.length<2||Q.length<2)return -1;ti=2,to/=2,ts/=2,tt/=2}function ta(J,Q){return 1===ti?J[Q]:J.readUInt16BE(Q*ti)}if(tr){let te=-1;for(tn=tt;tn<to;tn++)if(ta(J,tn)===ta(Q,-1===te?0:tn-te)){if(-1===te&&(te=tn),tn-te+1===ts)return te*ti}else -1!==te&&(tn-=tn-te),te=-1}else for(tt+ts>to&&(tt=to-ts),tn=tt;tn>=0;tn--){let tt=!0;for(let te=0;te<ts;te++)if(ta(J,tn+te)!==ta(Q,te)){tt=!1;break}if(tt)return tn}return -1}function tg(J,Q,tt,te){let tr;tt=Number(tt)||0;let tn=J.length-tt;te?(te=Number(te))>tn&&(te=tn):te=tn;let ti=Q.length;for(te>ti/2&&(te=ti/2),tr=0;tr<te;++tr){let te=parseInt(Q.substr(2*tr,2),16);if(tW(te))break;J[tt+tr]=te}return tr}function tb(J,Q,tt,te){return tV(tF(Q,J.length-tt),J,tt,te)}function tm(J,Q,tt,te){return tV(function(J){let Q=[];for(let tt=0;tt<J.length;++tt)Q.push(255&J.charCodeAt(tt));return Q}(Q),J,tt,te)}function tw(J,Q,tt,te){return tV(tH(Q),J,tt,te)}function t_(J,Q,tt,te){return tV(function(J,Q){let tt,te;let tr=[];for(let tn=0;tn<J.length&&!((Q-=2)<0);++tn)te=(tt=J.charCodeAt(tn))>>8,tr.push(tt%256),tr.push(te);return tr}(Q,J.length-tt),J,tt,te)}function tv(J,tt,te){return 0===tt&&te===J.length?Q.fromByteArray(J):Q.fromByteArray(J.slice(tt,te))}function tE(J,Q,tt){tt=Math.min(J.length,tt);let te=[],tr=Q;for(;tr<tt;){let Q=J[tr],tn=null,ti=Q>239?4:Q>223?3:Q>191?2:1;if(tr+ti<=tt){let tt,te,to,ts;switch(ti){case 1:Q<128&&(tn=Q);break;case 2:128==(192&(tt=J[tr+1]))&&(ts=(31&Q)<<6|63&tt)>127&&(tn=ts);break;case 3:tt=J[tr+1],te=J[tr+2],128==(192&tt)&&128==(192&te)&&(ts=(15&Q)<<12|(63&tt)<<6|63&te)>2047&&(ts<55296||ts>57343)&&(tn=ts);break;case 4:tt=J[tr+1],te=J[tr+2],to=J[tr+3],128==(192&tt)&&128==(192&te)&&128==(192&to)&&(ts=(15&Q)<<18|(63&tt)<<12|(63&te)<<6|63&to)>65535&&ts<1114112&&(tn=ts)}}null===tn?(tn=65533,ti=1):tn>65535&&(tn-=65536,te.push(tn>>>10&1023|55296),tn=56320|1023&tn),te.push(tn),tr+=ti}return function(J){let Q=J.length;if(Q<=tA)return String.fromCharCode.apply(String,J);let tt="",te=0;for(;te<Q;)tt+=String.fromCharCode.apply(String,J.slice(te,te+=tA));return tt}(te)}J.kMaxLength=tr,ti.TYPED_ARRAY_SUPPORT=function(){try{let J=new Uint8Array(1),Q={foo:function(){return 42}};return Object.setPrototypeOf(Q,Uint8Array.prototype),Object.setPrototypeOf(J,Q),42===J.foo()}catch(J){return!1}}(),ti.TYPED_ARRAY_SUPPORT||"undefined"==typeof console||"function"!=typeof console.error||console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."),Object.defineProperty(ti.prototype,"parent",{enumerable:!0,get:function(){if(ti.isBuffer(this))return this.buffer}}),Object.defineProperty(ti.prototype,"offset",{enumerable:!0,get:function(){if(ti.isBuffer(this))return this.byteOffset}}),ti.poolSize=8192,ti.from=function(J,Q,tt){return to(J,Q,tt)},Object.setPrototypeOf(ti.prototype,Uint8Array.prototype),Object.setPrototypeOf(ti,Uint8Array),ti.alloc=function(J,Q,tt){return function(J,Q,tt){return ts(J),J<=0?tn(J):void 0!==Q?"string"==typeof tt?tn(J).fill(Q,tt):tn(J).fill(Q):tn(J)}(J,Q,tt)},ti.allocUnsafe=function(J){return ta(J)},ti.allocUnsafeSlow=function(J){return ta(J)},ti.isBuffer=function(J){return null!=J&&!0===J._isBuffer&&J!==ti.prototype},ti.compare=function(J,Q){if(tG(J,Uint8Array)&&(J=ti.from(J,J.offset,J.byteLength)),tG(Q,Uint8Array)&&(Q=ti.from(Q,Q.offset,Q.byteLength)),!ti.isBuffer(J)||!ti.isBuffer(Q))throw TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(J===Q)return 0;let tt=J.length,te=Q.length;for(let tr=0,tn=Math.min(tt,te);tr<tn;++tr)if(J[tr]!==Q[tr]){tt=J[tr],te=Q[tr];break}return tt<te?-1:te<tt?1:0},ti.isEncoding=function(J){switch(String(J).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},ti.concat=function(J,Q){let tt;if(!Array.isArray(J))throw TypeError('"list" argument must be an Array of Buffers');if(0===J.length)return ti.alloc(0);if(void 0===Q)for(Q=0,tt=0;tt<J.length;++tt)Q+=J[tt].length;let te=ti.allocUnsafe(Q),tr=0;for(tt=0;tt<J.length;++tt){let Q=J[tt];if(tG(Q,Uint8Array))tr+Q.length>te.length?(ti.isBuffer(Q)||(Q=ti.from(Q)),Q.copy(te,tr)):Uint8Array.prototype.set.call(te,Q,tr);else{if(!ti.isBuffer(Q))throw TypeError('"list" argument must be an Array of Buffers');Q.copy(te,tr)}tr+=Q.length}return te},ti.byteLength=th,ti.prototype._isBuffer=!0,ti.prototype.swap16=function(){let J=this.length;if(J%2!=0)throw RangeError("Buffer size must be a multiple of 16-bits");for(let Q=0;Q<J;Q+=2)td(this,Q,Q+1);return this},ti.prototype.swap32=function(){let J=this.length;if(J%4!=0)throw RangeError("Buffer size must be a multiple of 32-bits");for(let Q=0;Q<J;Q+=4)td(this,Q,Q+3),td(this,Q+1,Q+2);return this},ti.prototype.swap64=function(){let J=this.length;if(J%8!=0)throw RangeError("Buffer size must be a multiple of 64-bits");for(let Q=0;Q<J;Q+=8)td(this,Q,Q+7),td(this,Q+1,Q+6),td(this,Q+2,Q+5),td(this,Q+3,Q+4);return this},ti.prototype.toString=function(){let J=this.length;return 0===J?"":0==arguments.length?tE(this,0,J):tc.apply(this,arguments)},ti.prototype.toLocaleString=ti.prototype.toString,ti.prototype.equals=function(J){if(!ti.isBuffer(J))throw TypeError("Argument must be a Buffer");return this===J||0===ti.compare(this,J)},ti.prototype.inspect=function(){let Q="",tt=J.INSPECT_MAX_BYTES;return Q=this.toString("hex",0,tt).replace(/(.{2})/g,"$1 ").trim(),this.length>tt&&(Q+=" ... "),"<Buffer "+Q+">"},te&&(ti.prototype[te]=ti.prototype.inspect),ti.prototype.compare=function(J,Q,tt,te,tr){if(tG(J,Uint8Array)&&(J=ti.from(J,J.offset,J.byteLength)),!ti.isBuffer(J))throw TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof J);if(void 0===Q&&(Q=0),void 0===tt&&(tt=J?J.length:0),void 0===te&&(te=0),void 0===tr&&(tr=this.length),Q<0||tt>J.length||te<0||tr>this.length)throw RangeError("out of range index");if(te>=tr&&Q>=tt)return 0;if(te>=tr)return -1;if(Q>=tt)return 1;if(this===J)return 0;let tn=(tr>>>=0)-(te>>>=0),to=(tt>>>=0)-(Q>>>=0),ts=Math.min(tn,to),ta=this.slice(te,tr),tl=J.slice(Q,tt);for(let J=0;J<ts;++J)if(ta[J]!==tl[J]){tn=ta[J],to=tl[J];break}return tn<to?-1:to<tn?1:0},ti.prototype.includes=function(J,Q,tt){return -1!==this.indexOf(J,Q,tt)},ti.prototype.indexOf=function(J,Q,tt){return tp(this,J,Q,tt,!0)},ti.prototype.lastIndexOf=function(J,Q,tt){return tp(this,J,Q,tt,!1)},ti.prototype.write=function(J,Q,tt,te){if(void 0===Q)te="utf8",tt=this.length,Q=0;else if(void 0===tt&&"string"==typeof Q)te=Q,tt=this.length,Q=0;else{if(!isFinite(Q))throw Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");Q>>>=0,isFinite(tt)?(tt>>>=0,void 0===te&&(te="utf8")):(te=tt,tt=void 0)}let tr=this.length-Q;if((void 0===tt||tt>tr)&&(tt=tr),J.length>0&&(tt<0||Q<0)||Q>this.length)throw RangeError("Attempt to write outside buffer bounds");te||(te="utf8");let tn=!1;for(;;)switch(te){case"hex":return tg(this,J,Q,tt);case"utf8":case"utf-8":return tb(this,J,Q,tt);case"ascii":case"latin1":case"binary":return tm(this,J,Q,tt);case"base64":return tw(this,J,Q,tt);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return t_(this,J,Q,tt);default:if(tn)throw TypeError("Unknown encoding: "+te);te=(""+te).toLowerCase(),tn=!0}},ti.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};let tA=4096;function tk(J,Q,tt){let te="";tt=Math.min(J.length,tt);for(let tr=Q;tr<tt;++tr)te+=String.fromCharCode(127&J[tr]);return te}function tB(J,Q,tt){let te="";tt=Math.min(J.length,tt);for(let tr=Q;tr<tt;++tr)te+=String.fromCharCode(J[tr]);return te}function tS(J,Q,tt){let te=J.length;(!Q||Q<0)&&(Q=0),(!tt||tt<0||tt>te)&&(tt=te);let tr="";for(let te=Q;te<tt;++te)tr+=tq[J[te]];return tr}function tT(J,Q,tt){let te=J.slice(Q,tt),tr="";for(let J=0;J<te.length-1;J+=2)tr+=String.fromCharCode(te[J]+256*te[J+1]);return tr}function tx(J,Q,tt){if(J%1!=0||J<0)throw RangeError("offset is not uint");if(J+Q>tt)throw RangeError("Trying to access beyond buffer length")}function tI(J,Q,tt,te,tr,tn){if(!ti.isBuffer(J))throw TypeError('"buffer" argument must be a Buffer instance');if(Q>tr||Q<tn)throw RangeError('"value" argument is out of bounds');if(tt+te>J.length)throw RangeError("Index out of range")}function tN(J,Q,tt,te,tr){tR(Q,te,tr,J,tt,7);let tn=Number(Q&BigInt(4294967295));J[tt++]=tn,tn>>=8,J[tt++]=tn,tn>>=8,J[tt++]=tn,tn>>=8,J[tt++]=tn;let ti=Number(Q>>BigInt(32)&BigInt(4294967295));return J[tt++]=ti,ti>>=8,J[tt++]=ti,ti>>=8,J[tt++]=ti,ti>>=8,J[tt++]=ti,tt}function tC(J,Q,tt,te,tr){tR(Q,te,tr,J,tt,7);let tn=Number(Q&BigInt(4294967295));J[tt+7]=tn,tn>>=8,J[tt+6]=tn,tn>>=8,J[tt+5]=tn,tn>>=8,J[tt+4]=tn;let ti=Number(Q>>BigInt(32)&BigInt(4294967295));return J[tt+3]=ti,ti>>=8,J[tt+2]=ti,ti>>=8,J[tt+1]=ti,ti>>=8,J[tt]=ti,tt+8}function tU(J,Q,tt,te,tr,tn){if(tt+te>J.length||tt<0)throw RangeError("Index out of range")}function tD(J,Q,te,tr,tn){return Q=+Q,te>>>=0,tn||tU(J,0,te,4),tt.write(J,Q,te,tr,23,4),te+4}function tO(J,Q,te,tr,tn){return Q=+Q,te>>>=0,tn||tU(J,0,te,8),tt.write(J,Q,te,tr,52,8),te+8}ti.prototype.slice=function(J,Q){let tt=this.length;(J=~~J)<0?(J+=tt)<0&&(J=0):J>tt&&(J=tt),(Q=void 0===Q?tt:~~Q)<0?(Q+=tt)<0&&(Q=0):Q>tt&&(Q=tt),Q<J&&(Q=J);let te=this.subarray(J,Q);return Object.setPrototypeOf(te,ti.prototype),te},ti.prototype.readUintLE=ti.prototype.readUIntLE=function(J,Q,tt){J>>>=0,Q>>>=0,tt||tx(J,Q,this.length);let te=this[J],tr=1,tn=0;for(;++tn<Q&&(tr*=256);)te+=this[J+tn]*tr;return te},ti.prototype.readUintBE=ti.prototype.readUIntBE=function(J,Q,tt){J>>>=0,Q>>>=0,tt||tx(J,Q,this.length);let te=this[J+--Q],tr=1;for(;Q>0&&(tr*=256);)te+=this[J+--Q]*tr;return te},ti.prototype.readUint8=ti.prototype.readUInt8=function(J,Q){return J>>>=0,Q||tx(J,1,this.length),this[J]},ti.prototype.readUint16LE=ti.prototype.readUInt16LE=function(J,Q){return J>>>=0,Q||tx(J,2,this.length),this[J]|this[J+1]<<8},ti.prototype.readUint16BE=ti.prototype.readUInt16BE=function(J,Q){return J>>>=0,Q||tx(J,2,this.length),this[J]<<8|this[J+1]},ti.prototype.readUint32LE=ti.prototype.readUInt32LE=function(J,Q){return J>>>=0,Q||tx(J,4,this.length),(this[J]|this[J+1]<<8|this[J+2]<<16)+16777216*this[J+3]},ti.prototype.readUint32BE=ti.prototype.readUInt32BE=function(J,Q){return J>>>=0,Q||tx(J,4,this.length),16777216*this[J]+(this[J+1]<<16|this[J+2]<<8|this[J+3])},ti.prototype.readBigUInt64LE=tJ(function(J){tj(J>>>=0,"offset");let Q=this[J],tt=this[J+7];void 0!==Q&&void 0!==tt||tM(J,this.length-8);let te=Q+256*this[++J]+65536*this[++J]+16777216*this[++J],tr=this[++J]+256*this[++J]+65536*this[++J]+16777216*tt;return BigInt(te)+(BigInt(tr)<<BigInt(32))}),ti.prototype.readBigUInt64BE=tJ(function(J){tj(J>>>=0,"offset");let Q=this[J],tt=this[J+7];void 0!==Q&&void 0!==tt||tM(J,this.length-8);let te=16777216*Q+65536*this[++J]+256*this[++J]+this[++J],tr=16777216*this[++J]+65536*this[++J]+256*this[++J]+tt;return(BigInt(te)<<BigInt(32))+BigInt(tr)}),ti.prototype.readIntLE=function(J,Q,tt){J>>>=0,Q>>>=0,tt||tx(J,Q,this.length);let te=this[J],tr=1,tn=0;for(;++tn<Q&&(tr*=256);)te+=this[J+tn]*tr;return te>=(tr*=128)&&(te-=Math.pow(2,8*Q)),te},ti.prototype.readIntBE=function(J,Q,tt){J>>>=0,Q>>>=0,tt||tx(J,Q,this.length);let te=Q,tr=1,tn=this[J+--te];for(;te>0&&(tr*=256);)tn+=this[J+--te]*tr;return tn>=(tr*=128)&&(tn-=Math.pow(2,8*Q)),tn},ti.prototype.readInt8=function(J,Q){return J>>>=0,Q||tx(J,1,this.length),128&this[J]?-1*(255-this[J]+1):this[J]},ti.prototype.readInt16LE=function(J,Q){J>>>=0,Q||tx(J,2,this.length);let tt=this[J]|this[J+1]<<8;return 32768&tt?4294901760|tt:tt},ti.prototype.readInt16BE=function(J,Q){J>>>=0,Q||tx(J,2,this.length);let tt=this[J+1]|this[J]<<8;return 32768&tt?4294901760|tt:tt},ti.prototype.readInt32LE=function(J,Q){return J>>>=0,Q||tx(J,4,this.length),this[J]|this[J+1]<<8|this[J+2]<<16|this[J+3]<<24},ti.prototype.readInt32BE=function(J,Q){return J>>>=0,Q||tx(J,4,this.length),this[J]<<24|this[J+1]<<16|this[J+2]<<8|this[J+3]},ti.prototype.readBigInt64LE=tJ(function(J){tj(J>>>=0,"offset");let Q=this[J],tt=this[J+7];void 0!==Q&&void 0!==tt||tM(J,this.length-8);let te=this[J+4]+256*this[J+5]+65536*this[J+6]+(tt<<24);return(BigInt(te)<<BigInt(32))+BigInt(Q+256*this[++J]+65536*this[++J]+16777216*this[++J])}),ti.prototype.readBigInt64BE=tJ(function(J){tj(J>>>=0,"offset");let Q=this[J],tt=this[J+7];void 0!==Q&&void 0!==tt||tM(J,this.length-8);let te=(Q<<24)+65536*this[++J]+256*this[++J]+this[++J];return(BigInt(te)<<BigInt(32))+BigInt(16777216*this[++J]+65536*this[++J]+256*this[++J]+tt)}),ti.prototype.readFloatLE=function(J,Q){return J>>>=0,Q||tx(J,4,this.length),tt.read(this,J,!0,23,4)},ti.prototype.readFloatBE=function(J,Q){return J>>>=0,Q||tx(J,4,this.length),tt.read(this,J,!1,23,4)},ti.prototype.readDoubleLE=function(J,Q){return J>>>=0,Q||tx(J,8,this.length),tt.read(this,J,!0,52,8)},ti.prototype.readDoubleBE=function(J,Q){return J>>>=0,Q||tx(J,8,this.length),tt.read(this,J,!1,52,8)},ti.prototype.writeUintLE=ti.prototype.writeUIntLE=function(J,Q,tt,te){J=+J,Q>>>=0,tt>>>=0,te||tI(this,J,Q,tt,Math.pow(2,8*tt)-1,0);let tr=1,tn=0;for(this[Q]=255&J;++tn<tt&&(tr*=256);)this[Q+tn]=J/tr&255;return Q+tt},ti.prototype.writeUintBE=ti.prototype.writeUIntBE=function(J,Q,tt,te){J=+J,Q>>>=0,tt>>>=0,te||tI(this,J,Q,tt,Math.pow(2,8*tt)-1,0);let tr=tt-1,tn=1;for(this[Q+tr]=255&J;--tr>=0&&(tn*=256);)this[Q+tr]=J/tn&255;return Q+tt},ti.prototype.writeUint8=ti.prototype.writeUInt8=function(J,Q,tt){return J=+J,Q>>>=0,tt||tI(this,J,Q,1,255,0),this[Q]=255&J,Q+1},ti.prototype.writeUint16LE=ti.prototype.writeUInt16LE=function(J,Q,tt){return J=+J,Q>>>=0,tt||tI(this,J,Q,2,65535,0),this[Q]=255&J,this[Q+1]=J>>>8,Q+2},ti.prototype.writeUint16BE=ti.prototype.writeUInt16BE=function(J,Q,tt){return J=+J,Q>>>=0,tt||tI(this,J,Q,2,65535,0),this[Q]=J>>>8,this[Q+1]=255&J,Q+2},ti.prototype.writeUint32LE=ti.prototype.writeUInt32LE=function(J,Q,tt){return J=+J,Q>>>=0,tt||tI(this,J,Q,4,4294967295,0),this[Q+3]=J>>>24,this[Q+2]=J>>>16,this[Q+1]=J>>>8,this[Q]=255&J,Q+4},ti.prototype.writeUint32BE=ti.prototype.writeUInt32BE=function(J,Q,tt){return J=+J,Q>>>=0,tt||tI(this,J,Q,4,4294967295,0),this[Q]=J>>>24,this[Q+1]=J>>>16,this[Q+2]=J>>>8,this[Q+3]=255&J,Q+4},ti.prototype.writeBigUInt64LE=tJ(function(J,Q=0){return tN(this,J,Q,BigInt(0),BigInt("0xffffffffffffffff"))}),ti.prototype.writeBigUInt64BE=tJ(function(J,Q=0){return tC(this,J,Q,BigInt(0),BigInt("0xffffffffffffffff"))}),ti.prototype.writeIntLE=function(J,Q,tt,te){if(J=+J,Q>>>=0,!te){let te=Math.pow(2,8*tt-1);tI(this,J,Q,tt,te-1,-te)}let tr=0,tn=1,ti=0;for(this[Q]=255&J;++tr<tt&&(tn*=256);)J<0&&0===ti&&0!==this[Q+tr-1]&&(ti=1),this[Q+tr]=(J/tn>>0)-ti&255;return Q+tt},ti.prototype.writeIntBE=function(J,Q,tt,te){if(J=+J,Q>>>=0,!te){let te=Math.pow(2,8*tt-1);tI(this,J,Q,tt,te-1,-te)}let tr=tt-1,tn=1,ti=0;for(this[Q+tr]=255&J;--tr>=0&&(tn*=256);)J<0&&0===ti&&0!==this[Q+tr+1]&&(ti=1),this[Q+tr]=(J/tn>>0)-ti&255;return Q+tt},ti.prototype.writeInt8=function(J,Q,tt){return J=+J,Q>>>=0,tt||tI(this,J,Q,1,127,-128),J<0&&(J=255+J+1),this[Q]=255&J,Q+1},ti.prototype.writeInt16LE=function(J,Q,tt){return J=+J,Q>>>=0,tt||tI(this,J,Q,2,32767,-32768),this[Q]=255&J,this[Q+1]=J>>>8,Q+2},ti.prototype.writeInt16BE=function(J,Q,tt){return J=+J,Q>>>=0,tt||tI(this,J,Q,2,32767,-32768),this[Q]=J>>>8,this[Q+1]=255&J,Q+2},ti.prototype.writeInt32LE=function(J,Q,tt){return J=+J,Q>>>=0,tt||tI(this,J,Q,4,2147483647,-2147483648),this[Q]=255&J,this[Q+1]=J>>>8,this[Q+2]=J>>>16,this[Q+3]=J>>>24,Q+4},ti.prototype.writeInt32BE=function(J,Q,tt){return J=+J,Q>>>=0,tt||tI(this,J,Q,4,2147483647,-2147483648),J<0&&(J=4294967295+J+1),this[Q]=J>>>24,this[Q+1]=J>>>16,this[Q+2]=J>>>8,this[Q+3]=255&J,Q+4},ti.prototype.writeBigInt64LE=tJ(function(J,Q=0){return tN(this,J,Q,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),ti.prototype.writeBigInt64BE=tJ(function(J,Q=0){return tC(this,J,Q,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),ti.prototype.writeFloatLE=function(J,Q,tt){return tD(this,J,Q,!0,tt)},ti.prototype.writeFloatBE=function(J,Q,tt){return tD(this,J,Q,!1,tt)},ti.prototype.writeDoubleLE=function(J,Q,tt){return tO(this,J,Q,!0,tt)},ti.prototype.writeDoubleBE=function(J,Q,tt){return tO(this,J,Q,!1,tt)},ti.prototype.copy=function(J,Q,tt,te){if(!ti.isBuffer(J))throw TypeError("argument should be a Buffer");if(tt||(tt=0),te||0===te||(te=this.length),Q>=J.length&&(Q=J.length),Q||(Q=0),te>0&&te<tt&&(te=tt),te===tt||0===J.length||0===this.length)return 0;if(Q<0)throw RangeError("targetStart out of bounds");if(tt<0||tt>=this.length)throw RangeError("Index out of range");if(te<0)throw RangeError("sourceEnd out of bounds");te>this.length&&(te=this.length),J.length-Q<te-tt&&(te=J.length-Q+tt);let tr=te-tt;return this===J&&"function"==typeof Uint8Array.prototype.copyWithin?this.copyWithin(Q,tt,te):Uint8Array.prototype.set.call(J,this.subarray(tt,te),Q),tr},ti.prototype.fill=function(J,Q,tt,te){let tr;if("string"==typeof J){if("string"==typeof Q?(te=Q,Q=0,tt=this.length):"string"==typeof tt&&(te=tt,tt=this.length),void 0!==te&&"string"!=typeof te)throw TypeError("encoding must be a string");if("string"==typeof te&&!ti.isEncoding(te))throw TypeError("Unknown encoding: "+te);if(1===J.length){let Q=J.charCodeAt(0);("utf8"===te&&Q<128||"latin1"===te)&&(J=Q)}}else"number"==typeof J?J&=255:"boolean"==typeof J&&(J=Number(J));if(Q<0||this.length<Q||this.length<tt)throw RangeError("Out of range index");if(tt<=Q)return this;if(Q>>>=0,tt=void 0===tt?this.length:tt>>>0,J||(J=0),"number"==typeof J)for(tr=Q;tr<tt;++tr)this[tr]=J;else{let tn=ti.isBuffer(J)?J:ti.from(J,te),to=tn.length;if(0===to)throw TypeError('The value "'+J+'" is invalid for argument "value"');for(tr=0;tr<tt-Q;++tr)this[tr+Q]=tn[tr%to]}return this};let tz={};function tL(J,Q,tt){tz[J]=class extends tt{constructor(){super(),Object.defineProperty(this,"message",{value:Q.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${J}]`,this.stack,delete this.name}get code(){return J}set code(J){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:J,writable:!0})}toString(){return`${this.name} [${J}]: ${this.message}`}}}function tP(J){let Q="",tt=J.length,te="-"===J[0]?1:0;for(;tt>=te+4;tt-=3)Q=`_${J.slice(tt-3,tt)}${Q}`;return`${J.slice(0,tt)}${Q}`}function tR(J,Q,tt,te,tr,tn){if(J>tt||J<Q){let te;let tr="bigint"==typeof Q?"n":"";throw te=tn>3?0===Q||Q===BigInt(0)?`>= 0${tr} and < 2${tr} ** ${8*(tn+1)}${tr}`:`>= -(2${tr} ** ${8*(tn+1)-1}${tr}) and < 2 ** ${8*(tn+1)-1}${tr}`:`>= ${Q}${tr} and <= ${tt}${tr}`,new tz.ERR_OUT_OF_RANGE("value",te,J)}!function(J,Q,tt){tj(Q,"offset"),void 0!==J[Q]&&void 0!==J[Q+tt]||tM(Q,J.length-(tt+1))}(te,tr,tn)}function tj(J,Q){if("number"!=typeof J)throw new tz.ERR_INVALID_ARG_TYPE(Q,"number",J)}function tM(J,Q,tt){if(Math.floor(J)!==J)throw tj(J,tt),new tz.ERR_OUT_OF_RANGE(tt||"offset","an integer",J);if(Q<0)throw new tz.ERR_BUFFER_OUT_OF_BOUNDS;throw new tz.ERR_OUT_OF_RANGE(tt||"offset",`>= ${tt?1:0} and <= ${Q}`,J)}tL("ERR_BUFFER_OUT_OF_BOUNDS",function(J){return J?`${J} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"},RangeError),tL("ERR_INVALID_ARG_TYPE",function(J,Q){return`The "${J}" argument must be of type number. Received type ${typeof Q}`},TypeError),tL("ERR_OUT_OF_RANGE",function(J,Q,tt){let te=`The value of "${J}" is out of range.`,tr=tt;return Number.isInteger(tt)&&Math.abs(tt)>4294967296?tr=tP(String(tt)):"bigint"==typeof tt&&(tr=String(tt),(tt>BigInt(2)**BigInt(32)||tt<-(BigInt(2)**BigInt(32)))&&(tr=tP(tr)),tr+="n"),te+=` It must be ${Q}. Received ${tr}`},RangeError);let t$=/[^+/0-9A-Za-z-_]/g;function tF(J,Q){let tt;Q=Q||1/0;let te=J.length,tr=null,tn=[];for(let ti=0;ti<te;++ti){if((tt=J.charCodeAt(ti))>55295&&tt<57344){if(!tr){if(tt>56319||ti+1===te){(Q-=3)>-1&&tn.push(239,191,189);continue}tr=tt;continue}if(tt<56320){(Q-=3)>-1&&tn.push(239,191,189),tr=tt;continue}tt=65536+(tr-55296<<10|tt-56320)}else tr&&(Q-=3)>-1&&tn.push(239,191,189);if(tr=null,tt<128){if((Q-=1)<0)break;tn.push(tt)}else if(tt<2048){if((Q-=2)<0)break;tn.push(tt>>6|192,63&tt|128)}else if(tt<65536){if((Q-=3)<0)break;tn.push(tt>>12|224,tt>>6&63|128,63&tt|128)}else{if(!(tt<1114112))throw Error("Invalid code point");if((Q-=4)<0)break;tn.push(tt>>18|240,tt>>12&63|128,tt>>6&63|128,63&tt|128)}}return tn}function tH(J){return Q.toByteArray(function(J){if((J=(J=J.split("=")[0]).trim().replace(t$,"")).length<2)return"";for(;J.length%4!=0;)J+="=";return J}(J))}function tV(J,Q,tt,te){let tr;for(tr=0;tr<te&&!(tr+tt>=Q.length||tr>=J.length);++tr)Q[tr+tt]=J[tr];return tr}function tG(J,Q){return J instanceof Q||null!=J&&null!=J.constructor&&null!=J.constructor.name&&J.constructor.name===Q.name}function tW(J){return J!=J}let tq=function(){let J="0123456789abcdef",Q=Array(256);for(let tt=0;tt<16;++tt){let te=16*tt;for(let tr=0;tr<16;++tr)Q[te+tr]=J[tt]+J[tr]}return Q}();function tJ(J){return"undefined"==typeof BigInt?tX:J}function tX(){throw Error("BigInt not supported")}}(buffer);let{Buffer:Buffer}=buffer,symbol=Symbol.for("BufferList");function BufferList(J){if(!(this instanceof BufferList))return new BufferList(J);BufferList._init.call(this,J)}BufferList._init=function(J){Object.defineProperty(this,symbol,{value:!0}),this._bufs=[],this.length=0,J&&this.append(J)},BufferList.prototype._new=function(J){return new BufferList(J)},BufferList.prototype._offset=function(J){if(0===J)return[0,0];let Q=0;for(let tt=0;tt<this._bufs.length;tt++){let te=Q+this._bufs[tt].length;if(J<te||tt===this._bufs.length-1)return[tt,J-Q];Q=te}},BufferList.prototype._reverseOffset=function(J){let Q=J[0],tt=J[1];for(let J=0;J<Q;J++)tt+=this._bufs[J].length;return tt},BufferList.prototype.get=function(J){if(J>this.length||J<0)return;let Q=this._offset(J);return this._bufs[Q[0]][Q[1]]},BufferList.prototype.slice=function(J,Q){return"number"==typeof J&&J<0&&(J+=this.length),"number"==typeof Q&&Q<0&&(Q+=this.length),this.copy(null,0,J,Q)},BufferList.prototype.copy=function(J,Q,tt,te){if(("number"!=typeof tt||tt<0)&&(tt=0),("number"!=typeof te||te>this.length)&&(te=this.length),tt>=this.length||te<=0)return J||Buffer.alloc(0);let tr=!!J,tn=this._offset(tt),ti=te-tt,to=ti,ts=tr&&Q||0,ta=tn[1];if(0===tt&&te===this.length){if(!tr)return 1===this._bufs.length?this._bufs[0]:Buffer.concat(this._bufs,this.length);for(let Q=0;Q<this._bufs.length;Q++)this._bufs[Q].copy(J,ts),ts+=this._bufs[Q].length;return J}if(to<=this._bufs[tn[0]].length-ta)return tr?this._bufs[tn[0]].copy(J,Q,ta,ta+to):this._bufs[tn[0]].slice(ta,ta+to);tr||(J=Buffer.allocUnsafe(ti));for(let Q=tn[0];Q<this._bufs.length;Q++){let tt=this._bufs[Q].length-ta;if(!(to>tt)){this._bufs[Q].copy(J,ts,ta,ta+to),ts+=tt;break}this._bufs[Q].copy(J,ts,ta),ts+=tt,to-=tt,ta&&(ta=0)}return J.length>ts?J.slice(0,ts):J},BufferList.prototype.shallowSlice=function(J,Q){if(J=J||0,Q="number"!=typeof Q?this.length:Q,J<0&&(J+=this.length),Q<0&&(Q+=this.length),J===Q)return this._new();let tt=this._offset(J),te=this._offset(Q),tr=this._bufs.slice(tt[0],te[0]+1);return 0===te[1]?tr.pop():tr[tr.length-1]=tr[tr.length-1].slice(0,te[1]),0!==tt[1]&&(tr[0]=tr[0].slice(tt[1])),this._new(tr)},BufferList.prototype.toString=function(J,Q,tt){return this.slice(Q,tt).toString(J)},BufferList.prototype.consume=function(J){if(Number.isNaN(J=Math.trunc(J))||J<=0)return this;for(;this._bufs.length;){if(!(J>=this._bufs[0].length)){this._bufs[0]=this._bufs[0].slice(J),this.length-=J;break}J-=this._bufs[0].length,this.length-=this._bufs[0].length,this._bufs.shift()}return this},BufferList.prototype.duplicate=function(){let J=this._new();for(let Q=0;Q<this._bufs.length;Q++)J.append(this._bufs[Q]);return J},BufferList.prototype.append=function(J){if(null==J)return this;if(J.buffer)this._appendBuffer(Buffer.from(J.buffer,J.byteOffset,J.byteLength));else if(Array.isArray(J))for(let Q=0;Q<J.length;Q++)this.append(J[Q]);else if(this._isBufferList(J))for(let Q=0;Q<J._bufs.length;Q++)this.append(J._bufs[Q]);else"number"==typeof J&&(J=J.toString()),this._appendBuffer(Buffer.from(J));return this},BufferList.prototype._appendBuffer=function(J){this._bufs.push(J),this.length+=J.length},BufferList.prototype.indexOf=function(J,Q,tt){if(void 0===tt&&"string"==typeof Q&&(tt=Q,Q=void 0),"function"==typeof J||Array.isArray(J))throw TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');if("number"==typeof J?J=Buffer.from([J]):"string"==typeof J?J=Buffer.from(J,tt):this._isBufferList(J)?J=J.slice():Array.isArray(J.buffer)?J=Buffer.from(J.buffer,J.byteOffset,J.byteLength):Buffer.isBuffer(J)||(J=Buffer.from(J)),isNaN(Q=Number(Q||0))&&(Q=0),Q<0&&(Q=this.length+Q),Q<0&&(Q=0),0===J.length)return Q>this.length?this.length:Q;let te=this._offset(Q),tr=te[0],tn=te[1];for(;tr<this._bufs.length;tr++){let Q=this._bufs[tr];for(;tn<Q.length;)if(Q.length-tn>=J.length){let tt=Q.indexOf(J,tn);if(-1!==tt)return this._reverseOffset([tr,tt]);tn=Q.length-J.length+1}else{let Q=this._reverseOffset([tr,tn]);if(this._match(Q,J))return Q;tn++}tn=0}return -1},BufferList.prototype._match=function(J,Q){if(this.length-J<Q.length)return!1;for(let tt=0;tt<Q.length;tt++)if(this.get(J+tt)!==Q[tt])return!1;return!0},function(){let J={readDoubleBE:8,readDoubleLE:8,readFloatBE:4,readFloatLE:4,readInt32BE:4,readInt32LE:4,readUInt32BE:4,readUInt32LE:4,readInt16BE:2,readInt16LE:2,readUInt16BE:2,readUInt16LE:2,readInt8:1,readUInt8:1,readIntBE:null,readIntLE:null,readUIntBE:null,readUIntLE:null};for(let Q in J)!function(Q){BufferList.prototype[Q]=null===J[Q]?function(J,tt){return this.slice(J,J+tt)[Q](0,tt)}:function(tt=0){return this.slice(tt,tt+J[Q])[Q](0)}}(Q)}(),BufferList.prototype._isBufferList=function(J){return J instanceof BufferList||BufferList.isBufferList(J)},BufferList.isBufferList=function(J){return null!=J&&J[symbol]};var BufferList_1=BufferList;class Rabin$1{constructor(J,Q=12,tt=8192,te=32768,tr=64,tn){this.bits=Q,this.min=tt,this.max=te,this.asModule=J,this.rabin=new J.Rabin(Q,tt,te,tr,tn),this.polynomial=tn}fingerprint(J){let{__retain:Q,__release:tt,__allocArray:te,__getInt32Array:tr,Int32Array_ID:tn,Uint8Array_ID:ti}=this.asModule,to=Q(te(tn,new Int32Array(Math.ceil(J.length/this.min)))),ts=Q(te(ti,J)),ta=tr(this.rabin.fingerprint(ts,to));tt(ts),tt(to);let tl=ta.indexOf(0);return tl>=0?ta.subarray(0,tl):ta}}var rabin$1=Rabin$1,loader={};let ID_OFFSET=-8,SIZE_OFFSET=-4,ARRAYBUFFER_ID=0,STRING_ID=1,ARRAYBUFFERVIEW=1,ARRAY=2,VAL_ALIGN_OFFSET=5,VAL_SIGNED=1024,VAL_FLOAT=2048,VAL_MANAGED=8192,ARRAYBUFFERVIEW_BUFFER_OFFSET=0,ARRAYBUFFERVIEW_DATASTART_OFFSET=4,ARRAYBUFFERVIEW_DATALENGTH_OFFSET=8,ARRAYBUFFERVIEW_SIZE=12,ARRAY_LENGTH_OFFSET=12,ARRAY_SIZE=16,BIGINT="undefined"!=typeof BigUint64Array,THIS=Symbol(),CHUNKSIZE=1024;function getStringImpl(J,Q){let tt=new Uint32Array(J),te=new Uint16Array(J);var tr=tt[Q+SIZE_OFFSET>>>2]>>>1,tn=Q>>>1;if(tr<=CHUNKSIZE)return String.fromCharCode.apply(String,te.subarray(tn,tn+tr));let ti=[];do{let J=te[tn+CHUNKSIZE-1],Q=J>=55296&&J<56320?CHUNKSIZE-1:CHUNKSIZE;ti.push(String.fromCharCode.apply(String,te.subarray(tn,tn+=Q))),tr-=Q}while(tr>CHUNKSIZE);return ti.join("")+String.fromCharCode.apply(String,te.subarray(tn,tn+tr))}function preInstantiate(J){let Q={};function tt(J,Q){return J?getStringImpl(J.buffer,Q):"<yet unknown>"}let te=J.env=J.env||{};return te.abort=te.abort||function(J,tr,tn,ti){let to=Q.memory||te.memory;throw Error("abort: "+tt(to,J)+" at "+tt(to,tr)+":"+tn+":"+ti)},te.trace=te.trace||function(J,tr){let tn=Q.memory||te.memory;console.log("trace: "+tt(tn,J)+(tr?" ":"")+Array.prototype.slice.call(arguments,2,2+tr).join(", "))},J.Math=J.Math||Math,J.Date=J.Date||Date,Q}function postInstantiate(J,Q){let tt=Q.exports,te=tt.memory,tr=tt.table,tn=tt.__alloc,ti=tt.__retain,to=tt.__rtti_base||-1;function ts(J){let Q=new Uint32Array(te.buffer);if((J>>>=0)>=Q[to>>>2])throw Error("invalid id: "+J);return Q[(to+4>>>2)+2*J]}function ta(J){let Q=new Uint32Array(te.buffer);if((J>>>=0)>=Q[to>>>2])throw Error("invalid id: "+J);return Q[(to+4>>>2)+2*J+1]}function tl(J){return 31-Math.clz32(J>>>VAL_ALIGN_OFFSET&31)}function tu(J,Q,tt){let tr=te.buffer;if(tt)switch(J){case 2:return new Float32Array(tr);case 3:return new Float64Array(tr)}else switch(J){case 0:return new(Q?Int8Array:Uint8Array)(tr);case 1:return new(Q?Int16Array:Uint16Array)(tr);case 2:return new(Q?Int32Array:Uint32Array)(tr);case 3:return new(Q?BigInt64Array:BigUint64Array)(tr)}throw Error("unsupported align: "+J)}function tf(J){let Q=new Uint32Array(te.buffer),tt=Q[J+ID_OFFSET>>>2],tr=ts(tt);if(!(tr&ARRAYBUFFERVIEW))throw Error("not an array: "+tt);let tn=tl(tr);var ti=Q[J+ARRAYBUFFERVIEW_DATASTART_OFFSET>>>2];let to=tr&ARRAY?Q[J+ARRAY_LENGTH_OFFSET>>>2]:Q[ti+SIZE_OFFSET>>>2]>>>tn;return tu(tn,tr&VAL_SIGNED,tr&VAL_FLOAT).subarray(ti>>>=tn,ti+to)}function th(J,Q,tt){return new J(tc(J,Q,tt))}function tc(J,Q,tt){let tr=te.buffer,tn=new Uint32Array(tr),ti=tn[tt+ARRAYBUFFERVIEW_DATASTART_OFFSET>>>2];return new J(tr,ti,tn[ti+SIZE_OFFSET>>>2]>>>Q)}return J.__allocString=function(J){let Q=J.length,tt=tn(Q<<1,STRING_ID),tr=new Uint16Array(te.buffer);for(var ti=0,to=tt>>>1;ti<Q;++ti)tr[to+ti]=J.charCodeAt(ti);return tt},J.__getString=function(J){let Q=te.buffer;if(new Uint32Array(Q)[J+ID_OFFSET>>>2]!==STRING_ID)throw Error("not a string: "+J);return getStringImpl(Q,J)},J.__allocArray=function(J,Q){let tt=ts(J);if(!(tt&(ARRAYBUFFERVIEW|ARRAY)))throw Error("not an array: "+J+" @ "+tt);let tr=tl(tt),to=Q.length,ta=tn(to<<tr,ARRAYBUFFER_ID),tf=tn(tt&ARRAY?ARRAY_SIZE:ARRAYBUFFERVIEW_SIZE,J),th=new Uint32Array(te.buffer);th[tf+ARRAYBUFFERVIEW_BUFFER_OFFSET>>>2]=ti(ta),th[tf+ARRAYBUFFERVIEW_DATASTART_OFFSET>>>2]=ta,th[tf+ARRAYBUFFERVIEW_DATALENGTH_OFFSET>>>2]=to<<tr,tt&ARRAY&&(th[tf+ARRAY_LENGTH_OFFSET>>>2]=to);let tc=tu(tr,tt&VAL_SIGNED,tt&VAL_FLOAT);if(tt&VAL_MANAGED)for(let J=0;J<to;++J)tc[(ta>>>tr)+J]=ti(Q[J]);else tc.set(Q,ta>>>tr);return tf},J.__getArrayView=tf,J.__getArray=function(J){let Q=tf(J),tt=Q.length,te=Array(tt);for(let J=0;J<tt;J++)te[J]=Q[J];return te},J.__getArrayBuffer=function(J){let Q=te.buffer,tt=new Uint32Array(Q)[J+SIZE_OFFSET>>>2];return Q.slice(J,J+tt)},J.__getInt8Array=th.bind(null,Int8Array,0),J.__getInt8ArrayView=tc.bind(null,Int8Array,0),J.__getUint8Array=th.bind(null,Uint8Array,0),J.__getUint8ArrayView=tc.bind(null,Uint8Array,0),J.__getUint8ClampedArray=th.bind(null,Uint8ClampedArray,0),J.__getUint8ClampedArrayView=tc.bind(null,Uint8ClampedArray,0),J.__getInt16Array=th.bind(null,Int16Array,1),J.__getInt16ArrayView=tc.bind(null,Int16Array,1),J.__getUint16Array=th.bind(null,Uint16Array,1),J.__getUint16ArrayView=tc.bind(null,Uint16Array,1),J.__getInt32Array=th.bind(null,Int32Array,2),J.__getInt32ArrayView=tc.bind(null,Int32Array,2),J.__getUint32Array=th.bind(null,Uint32Array,2),J.__getUint32ArrayView=tc.bind(null,Uint32Array,2),BIGINT&&(J.__getInt64Array=th.bind(null,BigInt64Array,3),J.__getInt64ArrayView=tc.bind(null,BigInt64Array,3),J.__getUint64Array=th.bind(null,BigUint64Array,3),J.__getUint64ArrayView=tc.bind(null,BigUint64Array,3)),J.__getFloat32Array=th.bind(null,Float32Array,2),J.__getFloat32ArrayView=tc.bind(null,Float32Array,2),J.__getFloat64Array=th.bind(null,Float64Array,3),J.__getFloat64ArrayView=tc.bind(null,Float64Array,3),J.__instanceof=function(J,Q){let tt=new Uint32Array(te.buffer);var tr=tt[J+ID_OFFSET>>>2];if(tr<=tt[to>>>2])do if(tr==Q)return!0;while(tr=ta(tr));return!1},J.memory=J.memory||te,J.table=J.table||tr,demangle(tt,J)}function isResponse(J){return"undefined"!=typeof Response&&J instanceof Response}async function instantiate$1(J,Q){return isResponse(J=await J)?instantiateStreaming(J,Q):postInstantiate(preInstantiate(Q||(Q={})),await WebAssembly.instantiate(J instanceof WebAssembly.Module?J:await WebAssembly.compile(J),Q))}function instantiateSync(J,Q){return postInstantiate(preInstantiate(Q||(Q={})),new WebAssembly.Instance(J instanceof WebAssembly.Module?J:new WebAssembly.Module(J),Q))}async function instantiateStreaming(J,Q){return WebAssembly.instantiateStreaming?postInstantiate(preInstantiate(Q||(Q={})),(await WebAssembly.instantiateStreaming(J,Q)).instance):instantiate$1(isResponse(J=await J)?J.arrayBuffer():J,Q)}function demangle(J,Q){var tt=Q?Object.create(Q):{},te=J.__argumentsLength?function(Q){J.__argumentsLength.value=Q}:J.__setArgumentsLength||J.__setargc||function(){};for(let Q in J){if(!Object.prototype.hasOwnProperty.call(J,Q))continue;let tr=J[Q],tn=Q.split("."),ti=tt;for(;tn.length>1;){let J=tn.shift();Object.prototype.hasOwnProperty.call(ti,J)||(ti[J]={}),ti=ti[J]}let to=tn[0],ts=to.indexOf("#");if(ts>=0){let tt=to.substring(0,ts),tn=ti[tt];if(void 0===tn||!tn.prototype){let J=function(...Q){return J.wrap(J.prototype.constructor(0,...Q))};J.prototype={valueOf:function(){return this[THIS]}},J.wrap=function(Q){return Object.create(J.prototype,{[THIS]:{value:Q,writable:!1}})},tn&&Object.getOwnPropertyNames(tn).forEach(Q=>Object.defineProperty(J,Q,Object.getOwnPropertyDescriptor(tn,Q))),ti[tt]=J}if(to=to.substring(ts+1),ti=ti[tt].prototype,/^(get|set):/.test(to)){if(!Object.prototype.hasOwnProperty.call(ti,to=to.substring(4))){let tt=J[Q.replace("set:","get:")],te=J[Q.replace("get:","set:")];Object.defineProperty(ti,to,{get:function(){return tt(this[THIS])},set:function(J){te(this[THIS],J)},enumerable:!0})}}else"constructor"===to?(ti[to]=(...J)=>(te(J.length),tr(...J))).original=tr:(ti[to]=function(...J){return te(J.length),tr(this[THIS],...J)}).original=tr}else/^(get|set):/.test(to)?Object.prototype.hasOwnProperty.call(ti,to=to.substring(4))||Object.defineProperty(ti,to,{get:J[Q.replace("set:","get:")],set:J[Q.replace("get:","set:")],enumerable:!0}):"function"==typeof tr&&tr!==te?(ti[to]=(...J)=>(te(J.length),tr(...J))).original=tr:ti[to]=tr}return tt}loader.instantiate=instantiate$1,loader.instantiateSync=instantiateSync,loader.instantiateStreaming=instantiateStreaming,loader.demangle=demangle;let{instantiate:instantiate}=loader;function loadWebAssembly(J={}){if(!loadWebAssembly.supported)return null;var Q=new Uint8Array([0,97,115,109,1,0,0,0,1,78,14,96,2,127,126,0,96,1,127,1,126,96,2,127,127,0,96,1,127,1,127,96,1,127,0,96,2,127,127,1,127,96,3,127,127,127,1,127,96,0,0,96,3,127,127,127,0,96,0,1,127,96,4,127,127,127,127,0,96,5,127,127,127,127,127,1,127,96,1,126,1,127,96,2,126,126,1,126,2,13,1,3,101,110,118,5,97,98,111,114,116,0,10,3,54,53,2,2,8,9,3,5,2,8,6,5,3,4,2,6,9,12,13,2,5,11,3,2,3,2,3,2,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,6,7,7,4,4,5,3,1,0,1,6,47,9,127,1,65,0,11,127,1,65,0,11,127,0,65,3,11,127,0,65,4,11,127,1,65,0,11,127,1,65,0,11,127,1,65,0,11,127,0,65,240,2,11,127,0,65,6,11,7,240,5,41,6,109,101,109,111,114,121,2,0,7,95,95,97,108,108,111,99,0,10,8,95,95,114,101,116,97,105,110,0,11,9,95,95,114,101,108,101,97,115,101,0,12,9,95,95,99,111,108,108,101,99,116,0,51,11,95,95,114,116,116,105,95,98,97,115,101,3,7,13,73,110,116,51,50,65,114,114,97,121,95,73,68,3,2,13,85,105,110,116,56,65,114,114,97,121,95,73,68,3,3,6,100,101,103,114,101,101,0,16,3,109,111,100,0,17,5,82,97,98,105,110,3,8,16,82,97,98,105,110,35,103,101,116,58,119,105,110,100,111,119,0,21,16,82,97,98,105,110,35,115,101,116,58,119,105,110,100,111,119,0,22,21,82,97,98,105,110,35,103,101,116,58,119,105,110,100,111,119,95,115,105,122,101,0,23,21,82,97,98,105,110,35,115,101,116,58,119,105,110,100,111,119,95,115,105,122,101,0,24,14,82,97,98,105,110,35,103,101,116,58,119,112,111,115,0,25,14,82,97,98,105,110,35,115,101,116,58,119,112,111,115,0,26,15,82,97,98,105,110,35,103,101,116,58,99,111,117,110,116,0,27,15,82,97,98,105,110,35,115,101,116,58,99,111,117,110,116,0,28,13,82,97,98,105,110,35,103,101,116,58,112,111,115,0,29,13,82,97,98,105,110,35,115,101,116,58,112,111,115,0,30,15,82,97,98,105,110,35,103,101,116,58,115,116,97,114,116,0,31,15,82,97,98,105,110,35,115,101,116,58,115,116,97,114,116,0,32,16,82,97,98,105,110,35,103,101,116,58,100,105,103,101,115,116,0,33,16,82,97,98,105,110,35,115,101,116,58,100,105,103,101,115,116,0,34,21,82,97,98,105,110,35,103,101,116,58,99,104,117,110,107,95,115,116,97,114,116,0,35,21,82,97,98,105,110,35,115,101,116,58,99,104,117,110,107,95,115,116,97,114,116,0,36,22,82,97,98,105,110,35,103,101,116,58,99,104,117,110,107,95,108,101,110,103,116,104,0,37,22,82,97,98,105,110,35,115,101,116,58,99,104,117,110,107,95,108,101,110,103,116,104,0,38,31,82,97,98,105,110,35,103,101,116,58,99,104,117,110,107,95,99,117,116,95,102,105,110,103,101,114,112,114,105,110,116,0,39,31,82,97,98,105,110,35,115,101,116,58,99,104,117,110,107,95,99,117,116,95,102,105,110,103,101,114,112,114,105,110,116,0,40,20,82,97,98,105,110,35,103,101,116,58,112,111,108,121,110,111,109,105,97,108,0,41,20,82,97,98,105,110,35,115,101,116,58,112,111,108,121,110,111,109,105,97,108,0,42,17,82,97,98,105,110,35,103,101,116,58,109,105,110,115,105,122,101,0,43,17,82,97,98,105,110,35,115,101,116,58,109,105,110,115,105,122,101,0,44,17,82,97,98,105,110,35,103,101,116,58,109,97,120,115,105,122,101,0,45,17,82,97,98,105,110,35,115,101,116,58,109,97,120,115,105,122,101,0,46,14,82,97,98,105,110,35,103,101,116,58,109,97,115,107,0,47,14,82,97,98,105,110,35,115,101,116,58,109,97,115,107,0,48,17,82,97,98,105,110,35,99,111,110,115,116,114,117,99,116,111,114,0,20,17,82,97,98,105,110,35,102,105,110,103,101,114,112,114,105,110,116,0,49,8,1,50,10,165,31,53,199,1,1,4,127,32,1,40,2,0,65,124,113,34,2,65,128,2,73,4,127,32,2,65,4,118,33,4,65,0,5,32,2,65,31,32,2,103,107,34,3,65,4,107,118,65,16,115,33,4,32,3,65,7,107,11,33,3,32,1,40,2,20,33,2,32,1,40,2,16,34,5,4,64,32,5,32,2,54,2,20,11,32,2,4,64,32,2,32,5,54,2,16,11,32,1,32,0,32,4,32,3,65,4,116,106,65,2,116,106,40,2,96,70,4,64,32,0,32,4,32,3,65,4,116,106,65,2,116,106,32,2,54,2,96,32,2,69,4,64,32,0,32,3,65,2,116,106,32,0,32,3,65,2,116,106,40,2,4,65,1,32,4,116,65,127,115,113,34,1,54,2,4,32,1,69,4,64,32,0,32,0,40,2,0,65,1,32,3,116,65,127,115,113,54,2,0,11,11,11,11,226,2,1,6,127,32,1,40,2,0,33,3,32,1,65,16,106,32,1,40,2,0,65,124,113,106,34,4,40,2,0,34,5,65,1,113,4,64,32,3,65,124,113,65,16,106,32,5,65,124,113,106,34,2,65,240,255,255,255,3,73,4,64,32,0,32,4,16,1,32,1,32,2,32,3,65,3,113,114,34,3,54,2,0,32,1,65,16,106,32,1,40,2,0,65,124,113,106,34,4,40,2,0,33,5,11,11,32,3,65,2,113,4,64,32,1,65,4,107,40,2,0,34,2,40,2,0,34,6,65,124,113,65,16,106,32,3,65,124,113,106,34,7,65,240,255,255,255,3,73,4,64,32,0,32,2,16,1,32,2,32,7,32,6,65,3,113,114,34,3,54,2,0,32,2,33,1,11,11,32,4,32,5,65,2,114,54,2,0,32,4,65,4,107,32,1,54,2,0,32,0,32,3,65,124,113,34,2,65,128,2,73,4,127,32,2,65,4,118,33,4,65,0,5,32,2,65,31,32,2,103,107,34,2,65,4,107,118,65,16,115,33,4,32,2,65,7,107,11,34,3,65,4,116,32,4,106,65,2,116,106,40,2,96,33,2,32,1,65,0,54,2,16,32,1,32,2,54,2,20,32,2,4,64,32,2,32,1,54,2,16,11,32,0,32,4,32,3,65,4,116,106,65,2,116,106,32,1,54,2,96,32,0,32,0,40,2,0,65,1,32,3,116,114,54,2,0,32,0,32,3,65,2,116,106,32,0,32,3,65,2,116,106,40,2,4,65,1,32,4,116,114,54,2,4,11,119,1,1,127,32,2,2,127,32,0,40,2,160,12,34,2,4,64,32,2,32,1,65,16,107,70,4,64,32,2,40,2,0,33,3,32,1,65,16,107,33,1,11,11,32,1,11,107,34,2,65,48,73,4,64,15,11,32,1,32,3,65,2,113,32,2,65,32,107,65,1,114,114,54,2,0,32,1,65,0,54,2,16,32,1,65,0,54,2,20,32,1,32,2,106,65,16,107,34,2,65,2,54,2,0,32,0,32,2,54,2,160,12,32,0,32,1,16,2,11,155,1,1,3,127,35,0,34,0,69,4,64,65,1,63,0,34,0,74,4,127,65,1,32,0,107,64,0,65,0,72,5,65,0,11,4,64,0,11,65,176,3,34,0,65,0,54,2,0,65,208,15,65,0,54,2,0,3,64,32,1,65,23,73,4,64,32,1,65,2,116,65,176,3,106,65,0,54,2,4,65,0,33,2,3,64,32,2,65,16,73,4,64,32,1,65,4,116,32,2,106,65,2,116,65,176,3,106,65,0,54,2,96,32,2,65,1,106,33,2,12,1,11,11,32,1,65,1,106,33,1,12,1,11,11,65,176,3,65,224,15,63,0,65,16,116,16,3,65,176,3,36,0,11,32,0,11,45,0,32,0,65,240,255,255,255,3,79,4,64,65,32,65,224,0,65,201,3,65,29,16,0,0,11,32,0,65,15,106,65,112,113,34,0,65,16,32,0,65,16,75,27,11,169,1,1,1,127,32,0,32,1,65,128,2,73,4,127,32,1,65,4,118,33,1,65,0,5,32,1,65,248,255,255,255,1,73,4,64,32,1,65,1,65,27,32,1,103,107,116,106,65,1,107,33,1,11,32,1,65,31,32,1,103,107,34,2,65,4,107,118,65,16,115,33,1,32,2,65,7,107,11,34,2,65,2,116,106,40,2,4,65,127,32,1,116,113,34,1,4,127,32,0,32,1,104,32,2,65,4,116,106,65,2,116,106,40,2,96,5,32,0,40,2,0,65,127,32,2,65,1,106,116,113,34,1,4,127,32,0,32,0,32,1,104,34,0,65,2,116,106,40,2,4,104,32,0,65,4,116,106,65,2,116,106,40,2,96,5,65,0,11,11,11,111,1,1,127,63,0,34,2,32,1,65,248,255,255,255,1,73,4,127,32,1,65,1,65,27,32,1,103,107,116,65,1,107,106,5,32,1,11,65,16,32,0,40,2,160,12,32,2,65,16,116,65,16,107,71,116,106,65,255,255,3,106,65,128,128,124,113,65,16,118,34,1,32,2,32,1,74,27,64,0,65,0,72,4,64,32,1,64,0,65,0,72,4,64,0,11,11,32,0,32,2,65,16,116,63,0,65,16,116,16,3,11,113,1,2,127,32,1,40,2,0,34,3,65,124,113,32,2,107,34,4,65,32,79,4,64,32,1,32,2,32,3,65,2,113,114,54,2,0,32,2,32,1,65,16,106,106,34,1,32,4,65,16,107,65,1,114,54,2,0,32,0,32,1,16,2,5,32,1,32,3,65,126,113,54,2,0,32,1,65,16,106,32,1,40,2,0,65,124,113,106,32,1,65,16,106,32,1,40,2,0,65,124,113,106,40,2,0,65,125,113,54,2,0,11,11,91,1,2,127,32,0,32,1,16,5,34,4,16,6,34,3,69,4,64,65,1,36,1,65,0,36,1,32,0,32,4,16,6,34,3,69,4,64,32,0,32,4,16,7,32,0,32,4,16,6,33,3,11,11,32,3,65,0,54,2,4,32,3,32,2,54,2,8,32,3,32,1,54,2,12,32,0,32,3,16,1,32,0,32,3,32,4,16,8,32,3,11,13,0,16,4,32,0,32,1,16,9,65,16,106,11,33,1,1,127,32,0,65,172,3,75,4,64,32,0,65,16,107,34,1,32,1,40,2,4,65,1,106,54,2,4,11,32,0,11,18,0,32,0,65,172,3,75,4,64,32,0,65,16,107,16,52,11,11,140,3,1,1,127,2,64,32,1,69,13,0,32,0,65,0,58,0,0,32,0,32,1,106,65,1,107,65,0,58,0,0,32,1,65,2,77,13,0,32,0,65,1,106,65,0,58,0,0,32,0,65,2,106,65,0,58,0,0,32,0,32,1,106,34,2,65,2,107,65,0,58,0,0,32,2,65,3,107,65,0,58,0,0,32,1,65,6,77,13,0,32,0,65,3,106,65,0,58,0,0,32,0,32,1,106,65,4,107,65,0,58,0,0,32,1,65,8,77,13,0,32,1,65,0,32,0,107,65,3,113,34,1,107,33,2,32,0,32,1,106,34,0,65,0,54,2,0,32,0,32,2,65,124,113,34,1,106,65,4,107,65,0,54,2,0,32,1,65,8,77,13,0,32,0,65,4,106,65,0,54,2,0,32,0,65,8,106,65,0,54,2,0,32,0,32,1,106,34,2,65,12,107,65,0,54,2,0,32,2,65,8,107,65,0,54,2,0,32,1,65,24,77,13,0,32,0,65,12,106,65,0,54,2,0,32,0,65,16,106,65,0,54,2,0,32,0,65,20,106,65,0,54,2,0,32,0,65,24,106,65,0,54,2,0,32,0,32,1,106,34,2,65,28,107,65,0,54,2,0,32,2,65,24,107,65,0,54,2,0,32,2,65,20,107,65,0,54,2,0,32,2,65,16,107,65,0,54,2,0,32,0,32,0,65,4,113,65,24,106,34,2,106,33,0,32,1,32,2,107,33,1,3,64,32,1,65,32,79,4,64,32,0,66,0,55,3,0,32,0,65,8,106,66,0,55,3,0,32,0,65,16,106,66,0,55,3,0,32,0,65,24,106,66,0,55,3,0,32,1,65,32,107,33,1,32,0,65,32,106,33,0,12,1,11,11,11,11,178,1,1,3,127,32,1,65,240,255,255,255,3,32,2,118,75,4,64,65,144,1,65,192,1,65,23,65,56,16,0,0,11,32,1,32,2,116,34,3,65,0,16,10,34,2,32,3,16,13,32,0,69,4,64,65,12,65,2,16,10,34,0,65,172,3,75,4,64,32,0,65,16,107,34,1,32,1,40,2,4,65,1,106,54,2,4,11,11,32,0,65,0,54,2,0,32,0,65,0,54,2,4,32,0,65,0,54,2,8,32,2,34,1,32,0,40,2,0,34,4,71,4,64,32,1,65,172,3,75,4,64,32,1,65,16,107,34,5,32,5,40,2,4,65,1,106,54,2,4,11,32,4,16,12,11,32,0,32,1,54,2,0,32,0,32,2,54,2,4,32,0,32,3,54,2,8,32,0,11,46,1,2,127,65,12,65,5,16,10,34,0,65,172,3,75,4,64,32,0,65,16,107,34,1,32,1,40,2,4,65,1,106,54,2,4,11,32,0,65,128,2,65,3,16,14,11,9,0,65,63,32,0,121,167,107,11,49,1,2,127,65,63,32,1,121,167,107,33,2,3,64,65,63,32,0,121,167,107,32,2,107,34,3,65,0,78,4,64,32,0,32,1,32,3,172,134,133,33,0,12,1,11,11,32,0,11,40,0,32,1,32,0,40,2,8,79,4,64,65,128,2,65,192,2,65,163,1,65,44,16,0,0,11,32,1,32,0,40,2,4,106,65,0,58,0,0,11,38,0,32,1,32,0,40,2,8,79,4,64,65,128,2,65,192,2,65,152,1,65,44,16,0,0,11,32,1,32,0,40,2,4,106,45,0,0,11,254,5,2,1,127,4,126,32,0,69,4,64,65,232,0,65,6,16,10,34,0,65,172,3,75,4,64,32,0,65,16,107,34,5,32,5,40,2,4,65,1,106,54,2,4,11,11,32,0,65,0,54,2,0,32,0,65,0,54,2,4,32,0,65,0,54,2,8,32,0,66,0,55,3,16,32,0,66,0,55,3,24,32,0,66,0,55,3,32,32,0,66,0,55,3,40,32,0,66,0,55,3,48,32,0,66,0,55,3,56,32,0,66,0,55,3,64,32,0,66,0,55,3,72,32,0,66,0,55,3,80,32,0,66,0,55,3,88,32,0,66,0,55,3,96,32,0,32,2,173,55,3,80,32,0,32,3,173,55,3,88,65,12,65,4,16,10,34,2,65,172,3,75,4,64,32,2,65,16,107,34,3,32,3,40,2,4,65,1,106,54,2,4,11,32,2,32,4,65,0,16,14,33,2,32,0,40,2,0,16,12,32,0,32,2,54,2,0,32,0,32,4,54,2,4,32,0,66,1,32,1,173,134,66,1,125,55,3,96,32,0,66,243,130,183,218,216,230,232,30,55,3,72,35,4,69,4,64,65,0,33,2,3,64,32,2,65,128,2,72,4,64,32,2,65,255,1,113,173,33,6,32,0,41,3,72,34,7,33,8,65,63,32,7,121,167,107,33,1,3,64,65,63,32,6,121,167,107,32,1,107,34,3,65,0,78,4,64,32,6,32,8,32,3,172,134,133,33,6,12,1,11,11,65,0,33,4,3,64,32,4,32,0,40,2,4,65,1,107,72,4,64,32,6,66,8,134,33,6,32,0,41,3,72,34,7,33,8,65,63,32,7,121,167,107,33,1,3,64,65,63,32,6,121,167,107,32,1,107,34,3,65,0,78,4,64,32,6,32,8,32,3,172,134,133,33,6,12,1,11,11,32,4,65,1,106,33,4,12,1,11,11,35,6,40,2,4,32,2,65,3,116,106,32,6,55,3,0,32,2,65,1,106,33,2,12,1,11,11,65,63,32,0,41,3,72,121,167,107,172,33,7,65,0,33,2,3,64,32,2,65,128,2,72,4,64,35,5,33,1,32,2,172,32,7,134,34,8,33,6,65,63,32,0,41,3,72,34,9,121,167,107,33,3,3,64,65,63,32,6,121,167,107,32,3,107,34,4,65,0,78,4,64,32,6,32,9,32,4,172,134,133,33,6,12,1,11,11,32,1,40,2,4,32,2,65,3,116,106,32,6,32,8,132,55,3,0,32,2,65,1,106,33,2,12,1,11,11,65,1,36,4,11,32,0,66,0,55,3,24,32,0,66,0,55,3,32,65,0,33,2,3,64,32,2,32,0,40,2,4,72,4,64,32,0,40,2,0,32,2,16,18,32,2,65,1,106,33,2,12,1,11,11,32,0,66,0,55,3,40,32,0,65,0,54,2,8,32,0,66,0,55,3,16,32,0,66,0,55,3,40,32,0,40,2,0,32,0,40,2,8,16,19,33,1,32,0,40,2,8,32,0,40,2,0,40,2,4,106,65,1,58,0,0,32,0,32,0,41,3,40,35,6,40,2,4,32,1,65,3,116,106,41,3,0,133,55,3,40,32,0,32,0,40,2,8,65,1,106,32,0,40,2,4,111,54,2,8,32,0,35,5,40,2,4,32,0,41,3,40,34,6,66,45,136,167,65,3,116,106,41,3,0,32,6,66,8,134,66,1,132,133,55,3,40,32,0,11,38,1,1,127,32,0,40,2,0,34,0,65,172,3,75,4,64,32,0,65,16,107,34,1,32,1,40,2,4,65,1,106,54,2,4,11,32,0,11,55,1,2,127,32,1,32,0,40,2,0,34,2,71,4,64,32,1,65,172,3,75,4,64,32,1,65,16,107,34,3,32,3,40,2,4,65,1,106,54,2,4,11,32,2,16,12,11,32,0,32,1,54,2,0,11,7,0,32,0,40,2,4,11,9,0,32,0,32,1,54,2,4,11,7,0,32,0,40,2,8,11,9,0,32,0,32,1,54,2,8,11,7,0,32,0,41,3,16,11,9,0,32,0,32,1,55,3,16,11,7,0,32,0,41,3,24,11,9,0,32,0,32,1,55,3,24,11,7,0,32,0,41,3,32,11,9,0,32,0,32,1,55,3,32,11,7,0,32,0,41,3,40,11,9,0,32,0,32,1,55,3,40,11,7,0,32,0,41,3,48,11,9,0,32,0,32,1,55,3,48,11,7,0,32,0,41,3,56,11,9,0,32,0,32,1,55,3,56,11,7,0,32,0,41,3,64,11,9,0,32,0,32,1,55,3,64,11,7,0,32,0,41,3,72,11,9,0,32,0,32,1,55,3,72,11,7,0,32,0,41,3,80,11,9,0,32,0,32,1,55,3,80,11,7,0,32,0,41,3,88,11,9,0,32,0,32,1,55,3,88,11,7,0,32,0,41,3,96,11,9,0,32,0,32,1,55,3,96,11,172,4,2,5,127,1,126,32,2,65,172,3,75,4,64,32,2,65,16,107,34,4,32,4,40,2,4,65,1,106,54,2,4,11,32,2,33,4,65,0,33,2,32,1,40,2,8,33,5,32,1,40,2,4,33,6,3,64,2,127,65,0,33,3,3,64,32,3,32,5,72,4,64,32,3,32,6,106,45,0,0,33,1,32,0,40,2,0,32,0,40,2,8,16,19,33,7,32,0,40,2,8,32,0,40,2,0,40,2,4,106,32,1,58,0,0,32,0,32,0,41,3,40,35,6,40,2,4,32,7,65,3,116,106,41,3,0,133,55,3,40,32,0,32,0,40,2,8,65,1,106,32,0,40,2,4,111,54,2,8,32,0,35,5,40,2,4,32,0,41,3,40,34,8,66,45,136,167,65,3,116,106,41,3,0,32,1,173,32,8,66,8,134,132,133,55,3,40,32,0,32,0,41,3,16,66,1,124,55,3,16,32,0,32,0,41,3,24,66,1,124,55,3,24,32,0,41,3,16,32,0,41,3,80,90,4,127,32,0,41,3,40,32,0,41,3,96,131,80,5,65,0,11,4,127,65,1,5,32,0,41,3,16,32,0,41,3,88,90,11,4,64,32,0,32,0,41,3,32,55,3,48,32,0,32,0,41,3,16,55,3,56,32,0,32,0,41,3,40,55,3,64,65,0,33,1,3,64,32,1,32,0,40,2,4,72,4,64,32,0,40,2,0,32,1,16,18,32,1,65,1,106,33,1,12,1,11,11,32,0,66,0,55,3,40,32,0,65,0,54,2,8,32,0,66,0,55,3,16,32,0,66,0,55,3,40,32,0,40,2,0,32,0,40,2,8,16,19,33,1,32,0,40,2,8,32,0,40,2,0,40,2,4,106,65,1,58,0,0,32,0,32,0,41,3,40,35,6,40,2,4,32,1,65,3,116,106,41,3,0,133,55,3,40,32,0,32,0,40,2,8,65,1,106,32,0,40,2,4,111,54,2,8,32,0,35,5,40,2,4,32,0,41,3,40,34,8,66,45,136,167,65,3,116,106,41,3,0,32,8,66,8,134,66,1,132,133,55,3,40,32,3,65,1,106,12,3,11,32,3,65,1,106,33,3,12,1,11,11,65,127,11,34,1,65,0,78,4,64,32,5,32,1,107,33,5,32,1,32,6,106,33,6,32,2,34,1,65,1,106,33,2,32,4,40,2,4,32,1,65,2,116,106,32,0,41,3,56,62,2,0,12,1,11,11,32,4,11,10,0,16,15,36,5,16,15,36,6,11,3,0,1,11,73,1,2,127,32,0,40,2,4,34,1,65,255,255,255,255,0,113,34,2,65,1,70,4,64,32,0,65,16,106,16,53,32,0,32,0,40,2,0,65,1,114,54,2,0,35,0,32,0,16,2,5,32,0,32,2,65,1,107,32,1,65,128,128,128,128,127,113,114,54,2,4,11,11,58,0,2,64,2,64,2,64,32,0,65,8,107,40,2,0,14,7,0,0,1,1,1,1,1,2,11,15,11,32,0,40,2,0,34,0,4,64,32,0,65,172,3,79,4,64,32,0,65,16,107,16,52,11,11,15,11,0,11,11,137,3,7,0,65,16,11,55,40,0,0,0,1,0,0,0,1,0,0,0,40,0,0,0,97,0,108,0,108,0,111,0,99,0,97,0,116,0,105,0,111,0,110,0,32,0,116,0,111,0,111,0,32,0,108,0,97,0,114,0,103,0,101,0,65,208,0,11,45,30,0,0,0,1,0,0,0,1,0,0,0,30,0,0,0,126,0,108,0,105,0,98,0,47,0,114,0,116,0,47,0,116,0,108,0,115,0,102,0,46,0,116,0,115,0,65,128,1,11,43,28,0,0,0,1,0,0,0,1,0,0,0,28,0,0,0,73,0,110,0,118,0,97,0,108,0,105,0,100,0,32,0,108,0,101,0,110,0,103,0,116,0,104,0,65,176,1,11,53,38,0,0,0,1,0,0,0,1,0,0,0,38,0,0,0,126,0,108,0,105,0,98,0,47,0,97,0,114,0,114,0,97,0,121,0,98,0,117,0,102,0,102,0,101,0,114,0,46,0,116,0,115,0,65,240,1,11,51,36,0,0,0,1,0,0,0,1,0,0,0,36,0,0,0,73,0,110,0,100,0,101,0,120,0,32,0,111,0,117,0,116,0,32,0,111,0,102,0,32,0,114,0,97,0,110,0,103,0,101,0,65,176,2,11,51,36,0,0,0,1,0,0,0,1,0,0,0,36,0,0,0,126,0,108,0,105,0,98,0,47,0,116,0,121,0,112,0,101,0,100,0,97,0,114,0,114,0,97,0,121,0,46,0,116,0,115,0,65,240,2,11,53,7,0,0,0,16,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,145,4,0,0,2,0,0,0,49,0,0,0,2,0,0,0,17,1,0,0,2,0,0,0,16,0,34,16,115,111,117,114,99,101,77,97,112,112,105,110,103,85,82,76,16,46,47,114,97,98,105,110,46,119,97,115,109,46,109,97,112]);return instantiate(new Response(new Blob([Q],{type:"application/wasm"})),J)}loadWebAssembly.supported="undefined"!=typeof WebAssembly;var rabinWasm=loadWebAssembly;let Rabin=rabin$1,getRabin=rabinWasm,create=async(J,Q,tt,te,tr)=>{let tn=await getRabin();return new Rabin(tn,J,Q,tt,te,tr)};var src$1={Rabin:Rabin,create:create};async function*rabinChunker(J,Q){let tt,te,tr;if(Q.minChunkSize&&Q.maxChunkSize&&Q.avgChunkSize)tr=Q.avgChunkSize,tt=Q.minChunkSize,te=Q.maxChunkSize;else{if(!Q.avgChunkSize)throw errCode(Error("please specify an average chunk size"),"ERR_INVALID_AVG_CHUNK_SIZE");tt=(tr=Q.avgChunkSize)/3,te=tr+tr/2}if(tt<16)throw errCode(Error("rabin min must be greater than 16"),"ERR_INVALID_MIN_CHUNK_SIZE");te<tt&&(te=tt),tr<tt&&(tr=tt);let tn=Math.floor(Math.log2(tr));for await(let tr of rabin(J,{min:tt,max:te,bits:tn,window:Q.window,polynomial:Q.polynomial}))yield tr}async function*rabin(J,Q){let tt=await src$1.create(Q.bits,Q.min,Q.max,Q.window),te=new BufferList_1;for await(let Q of J){te.append(Q);let J=tt.fingerprint(Q);for(let Q=0;Q<J.length;Q++){let tt=J[Q],tr=te.slice(0,tt);te.consume(tt),yield tr}}te.length&&(yield te.slice(0))}async function*fixedSizeChunker(J,Q){let tt=new BufferList_1,te=0,tr=!1,tn=Q.maxChunkSize;for await(let Q of J)for(tt.append(Q),te+=Q.length;te>=tn;)if(yield tt.slice(0,tn),tr=!0,tn===tt.length)tt=new BufferList_1,te=0;else{let J=new BufferList_1;J.append(tt.shallowSlice(tn)),tt=J,te-=tn}tr&&!te||(yield tt.slice(0,te))}let identity$2=from$1({prefix:"\x00",name:"identity",encode:J=>toString$1(J),decode:J=>fromString$3(J)});var identityBase=Object.freeze({__proto__:null,identity:identity$2});let base2=rfc4648({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1});var base2$1=Object.freeze({__proto__:null,base2:base2});let base8=rfc4648({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3});var base8$1=Object.freeze({__proto__:null,base8:base8});let base10=baseX({prefix:"9",name:"base10",alphabet:"0123456789"});var base10$1=Object.freeze({__proto__:null,base10:base10});let base16=rfc4648({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),base16upper=rfc4648({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4});var base16$1=Object.freeze({__proto__:null,base16:base16,base16upper:base16upper});let base36=baseX({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),base36upper=baseX({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var base36$1=Object.freeze({__proto__:null,base36:base36,base36upper:base36upper});let base64=rfc4648({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),base64pad=rfc4648({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),base64url=rfc4648({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),base64urlpad=rfc4648({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});var base64$1=Object.freeze({__proto__:null,base64:base64,base64pad:base64pad,base64url:base64url,base64urlpad:base64urlpad});let alphabet=Array.from("\uD83D\uDE80\uD83E\uDE90☄\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09☀\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02❤\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09☺\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E✌✨\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D❣\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33✋\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13⭐✅\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6✔\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90☹\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20☝\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B⚽\uD83E\uDD19☕\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81⚡\uD83C\uDF1E\uD83C\uDF88❌✊\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C✈\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74▶➡❓\uD83D\uDC8E\uD83D\uDCB8⬇\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A⚠\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37☎\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51❄\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42"),alphabetBytesToChars=alphabet.reduce((J,Q,tt)=>(J[tt]=Q,J),[]),alphabetCharsToBytes=alphabet.reduce((J,Q,tt)=>(J[Q.codePointAt(0)]=tt,J),[]);function encode$2(J){return J.reduce((J,Q)=>J+=alphabetBytesToChars[Q],"")}function decode$2(J){let Q=[];for(let tt of J){let J=alphabetCharsToBytes[tt.codePointAt(0)];if(void 0===J)throw Error(`Non-base256emoji character: ${tt}`);Q.push(J)}return new Uint8Array(Q)}let base256emoji=from$1({prefix:"\uD83D\uDE80",name:"base256emoji",encode:encode$2,decode:decode$2});var base256emoji$1=Object.freeze({__proto__:null,base256emoji:base256emoji});let code$2=0,name$1="identity",encode$1=coerce,digest=J=>create$4(code$2,encode$1(J)),identity={code:code$2,name:name$1,encode:encode$1,digest:digest};var identity$1=Object.freeze({__proto__:null,identity:identity});new TextEncoder,new TextDecoder;let bases={...identityBase,...base2$1,...base8$1,...base10$1,...base16$1,...base32$1,...base36$1,...base58,...base64$1,...base256emoji$1};function asUint8Array(J){return null!=globalThis.Buffer?new Uint8Array(J.buffer,J.byteOffset,J.byteLength):J}function allocUnsafe(J=0){return null!=globalThis.Buffer&&null!=globalThis.Buffer.allocUnsafe?asUint8Array(globalThis.Buffer.allocUnsafe(J)):new Uint8Array(J)}function createCodec(J,Q,tt,te){return{name:J,prefix:Q,encoder:{name:J,prefix:Q,encode:tt},decoder:{decode:te}}}let string=createCodec("utf8","u",J=>"u"+new TextDecoder("utf8").decode(J),J=>(new TextEncoder).encode(J.substring(1))),ascii=createCodec("ascii","a",J=>{let Q="a";for(let tt=0;tt<J.length;tt++)Q+=String.fromCharCode(J[tt]);return Q},J=>{let Q=allocUnsafe((J=J.substring(1)).length);for(let tt=0;tt<J.length;tt++)Q[tt]=J.charCodeAt(tt);return Q}),BASES={utf8:string,"utf-8":string,hex:bases.base16,latin1:ascii,ascii:ascii,binary:ascii,...bases};function fromString(J,Q="utf8"){let tt=BASES[Q];if(!tt)throw Error(`Unsupported encoding "${Q}"`);return"utf8"!==Q&&"utf-8"!==Q||null==globalThis.Buffer||null==globalThis.Buffer.from?tt.decoder.decode(`${tt.prefix}${J}`):asUint8Array(globalThis.Buffer.from(J,"utf-8"))}var fromString$1=Object.freeze({__proto__:null,fromString:fromString});async function*validateChunks(J){for await(let Q of J){if(void 0===Q.length)throw errCode(Error("Content was invalid"),"ERR_INVALID_CONTENT");if("string"==typeof Q||Q instanceof String)yield fromString(Q.toString());else if(Array.isArray(Q))yield Uint8Array.from(Q);else{if(!(Q instanceof Uint8Array))throw errCode(Error("Content was invalid"),"ERR_INVALID_CONTENT");yield Q}}}function isIterable(J){return Symbol.iterator in J}function isAsyncIterable(J){return Symbol.asyncIterator in J}function contentAsAsyncIterable(J){try{if(J instanceof Uint8Array)return async function*(){yield J}();if(isIterable(J))return async function*(){yield*J}();if(isAsyncIterable(J))return J}catch{throw errCode(Error("Content was invalid"),"ERR_INVALID_CONTENT")}throw errCode(Error("Content was invalid"),"ERR_INVALID_CONTENT")}async function*dagBuilder(J,Q,tt){for await(let te of J)if(te.path&&("./"===te.path.substring(0,2)&&(tt.wrapWithDirectory=!0),te.path=te.path.split("/").filter(J=>J&&"."!==J).join("/")),te.content){let J,tr;J="function"==typeof tt.chunker?tt.chunker:"rabin"===tt.chunker?rabinChunker:fixedSizeChunker,tr="function"==typeof tt.chunkValidator?tt.chunkValidator:validateChunks;let tn={path:te.path,mtime:te.mtime,mode:te.mode,content:J(tr(contentAsAsyncIterable(te.content),tt),tt)};yield()=>fileBuilder(tn,Q,tt)}else{if(!te.path)throw Error("Import candidate must have content or path or both");{let J={path:te.path,mtime:te.mtime,mode:te.mode};yield()=>dirBuilder(J,Q,tt)}}}class Dir{constructor(J,Q){this.options=Q||{},this.root=J.root,this.dir=J.dir,this.path=J.path,this.dirty=J.dirty,this.flat=J.flat,this.parent=J.parent,this.parentKey=J.parentKey,this.unixfs=J.unixfs,this.mode=J.mode,this.mtime=J.mtime,this.cid=void 0,this.size=void 0}async put(J,Q){}get(J){return Promise.resolve(this)}async *eachChildSeries(){}async *flush(J){}}class DirFlat extends Dir{constructor(J,Q){super(J,Q),this._children={}}async put(J,Q){this.cid=void 0,this.size=void 0,this._children[J]=Q}get(J){return Promise.resolve(this._children[J])}childCount(){return Object.keys(this._children).length}directChildrenCount(){return this.childCount()}onlyChild(){return this._children[Object.keys(this._children)[0]]}async *eachChildSeries(){let J=Object.keys(this._children);for(let Q=0;Q<J.length;Q++){let tt=J[Q];yield{key:tt,child:this._children[tt]}}}async *flush(J){let Q=Object.keys(this._children),tt=[];for(let te=0;te<Q.length;te++){let tr=this._children[Q[te]];if(tr instanceof Dir)for await(let Q of tr.flush(J))tr=Q,yield tr;null!=tr.size&&tr.cid&&tt.push({Name:Q[te],Tsize:tr.size,Hash:tr.cid})}let te=new UnixFS({type:"directory",mtime:this.mtime,mode:this.mode}),tr={Data:te.marshal(),Links:tt},tn=encode$4(prepare(tr)),ti=await persist(tn,J,this.options),to=tn.length+tr.Links.reduce((J,Q)=>J+(null==Q.Tsize?0:Q.Tsize),0);this.cid=ti,this.size=to,yield{cid:ti,unixfs:te,path:this.path,size:to}}}let BITS_PER_BYTE=7;var sparseArray=class{constructor(){this._bitArrays=[],this._data=[],this._length=0,this._changedLength=!1,this._changedData=!1}set(J,Q){let tt=this._internalPositionFor(J,!1);if(void 0===Q)-1!==tt&&(this._unsetInternalPos(tt),this._unsetBit(J),this._changedLength=!0,this._changedData=!0);else{let te=!1;-1===tt?(tt=this._data.length,this._setBit(J),this._changedData=!0):te=!0,this._setInternalPos(tt,J,Q,te),this._changedLength=!0}}unset(J){this.set(J,void 0)}get(J){this._sortData();let Q=this._internalPositionFor(J,!0);if(-1!==Q)return this._data[Q][1]}push(J){return this.set(this.length,J),this.length}get length(){if(this._sortData(),this._changedLength){let J=this._data[this._data.length-1];this._length=J?J[0]+1:0,this._changedLength=!1}return this._length}forEach(J){let Q=0;for(;Q<this.length;)J(this.get(Q),Q,this),Q++}map(J){let Q=0,tt=Array(this.length);for(;Q<this.length;)tt[Q]=J(this.get(Q),Q,this),Q++;return tt}reduce(J,Q){let tt=0,te=Q;for(;tt<this.length;)te=J(te,this.get(tt),tt),tt++;return te}find(J){let Q,tt,te=0;for(;te<this.length&&!Q;)Q=J(tt=this.get(te)),te++;return Q?tt:void 0}_internalPositionFor(J,Q){let tt=this._bytePosFor(J,Q);if(tt>=this._bitArrays.length)return -1;let te=this._bitArrays[tt],tr=J-tt*BITS_PER_BYTE;return(te&1<<tr)>0?this._bitArrays.slice(0,tt).reduce(popCountReduce,0)+popCount(te&~(4294967295<<tr+1))-1:-1}_bytePosFor(J,Q){let tt=Math.floor(J/BITS_PER_BYTE),te=tt+1;for(;!Q&&this._bitArrays.length<te;)this._bitArrays.push(0);return tt}_setBit(J){let Q=this._bytePosFor(J,!1);this._bitArrays[Q]|=1<<J-Q*BITS_PER_BYTE}_unsetBit(J){let Q=this._bytePosFor(J,!1);this._bitArrays[Q]&=~(1<<J-Q*BITS_PER_BYTE)}_setInternalPos(J,Q,tt,te){let tr=this._data,tn=[Q,tt];if(te)this._sortData(),tr[J]=tn;else{if(tr.length){if(tr[tr.length-1][0]>=Q)tr.push(tn);else if(tr[0][0]<=Q)tr.unshift(tn);else{let J=Math.round(tr.length/2);this._data=tr.slice(0,J).concat(tn).concat(tr.slice(J))}}else this._data.push(tn);this._changedData=!0,this._changedLength=!0}}_unsetInternalPos(J){this._data.splice(J,1)}_sortData(){this._changedData&&this._data.sort(sortInternal),this._changedData=!1}bitField(){let J=[],Q,tt=8,te=0,tr=0,tn=this._bitArrays.slice();for(;tn.length||te;){0===te&&(Q=tn.shift(),te=7);let ti=Math.min(te,tt);tr|=(Q&~(255<<ti))<<8-tt,Q>>>=ti,te-=ti,(tt-=ti)&&(te||tn.length)||(J.push(tr),tr=0,tt=8)}for(var ti=J.length-1;ti>0&&0===J[ti];ti--)J.pop();return J}compactArray(){return this._sortData(),this._data.map(valueOnly)}};function popCountReduce(J,Q){return J+popCount(Q)}function popCount(J){let Q=J;return Q-=Q>>1&1431655765,16843009*((Q=(858993459&Q)+(Q>>2&858993459))+(Q>>4)&252645135)>>24}function sortInternal(J,Q){return J[0]-Q[0]}function valueOnly(J){return J[1]}var require$$1$1=getAugmentedNamespace(fromString$1);let SparseArray=sparseArray,{fromString:uint8ArrayFromString}=require$$1$1;class Bucket$1{constructor(J,Q,tt=0){this._options=J,this._popCount=0,this._parent=Q,this._posAtParent=tt,this._children=new SparseArray,this.key=null}async put(J,Q){let tt=await this._findNewBucketAndPos(J);await tt.bucket._putAt(tt,J,Q)}async get(J){let Q=await this._findChild(J);if(Q)return Q.value}async del(J){let Q=await this._findPlace(J),tt=Q.bucket._at(Q.pos);tt&&tt.key===J&&Q.bucket._delAt(Q.pos)}leafCount(){return this._children.compactArray().reduce((J,Q)=>Q instanceof Bucket$1?J+Q.leafCount():J+1,0)}childrenCount(){return this._children.length}onlyChild(){return this._children.get(0)}*eachLeafSeries(){let J=this._children.compactArray();for(let Q of J)Q instanceof Bucket$1?yield*Q.eachLeafSeries():yield Q;return[]}serialize(J,Q){return Q(this._children.reduce((tt,te,tr)=>(te&&(te instanceof Bucket$1?tt.push(te.serialize(J,Q)):tt.push(J(te,tr))),tt),[]))}asyncTransform(J,Q){return asyncTransformBucket(this,J,Q)}toJSON(){return this.serialize(mapNode,reduceNodes)}prettyPrint(){return JSON.stringify(this.toJSON(),null,"  ")}tableSize(){return Math.pow(2,this._options.bits)}async _findChild(J){let Q=await this._findPlace(J),tt=Q.bucket._at(Q.pos);if(!(tt instanceof Bucket$1))return tt&&tt.key===J?tt:void 0}async _findPlace(J){let Q=this._options.hash("string"==typeof J?uint8ArrayFromString(J):J),tt=await Q.take(this._options.bits),te=this._children.get(tt);return te instanceof Bucket$1?te._findPlace(Q):{bucket:this,pos:tt,hash:Q,existingChild:te}}async _findNewBucketAndPos(J){let Q=await this._findPlace(J);if(Q.existingChild&&Q.existingChild.key!==J){let J=new Bucket$1(this._options,Q.bucket,Q.pos);Q.bucket._putObjectAt(Q.pos,J);let tt=await J._findPlace(Q.existingChild.hash);return tt.bucket._putAt(tt,Q.existingChild.key,Q.existingChild.value),J._findNewBucketAndPos(Q.hash)}return Q}_putAt(J,Q,tt){this._putObjectAt(J.pos,{key:Q,value:tt,hash:J.hash})}_putObjectAt(J,Q){this._children.get(J)||this._popCount++,this._children.set(J,Q)}_delAt(J){if(-1===J)throw Error("Invalid position");this._children.get(J)&&this._popCount--,this._children.unset(J),this._level()}_level(){if(this._parent&&this._popCount<=1){if(1===this._popCount){let J=this._children.find(exists);if(J&&!(J instanceof Bucket$1)){let Q=J.hash;Q.untake(this._options.bits);let tt={pos:this._posAtParent,hash:Q,bucket:this._parent};this._parent._putAt(tt,J.key,J.value)}}else this._parent._delAt(this._posAtParent)}}_at(J){return this._children.get(J)}}function exists(J){return!!J}function mapNode(J,Q){return J.key}function reduceNodes(J){return J}async function asyncTransformBucket(J,Q,tt){let te=[];for(let tr of J._children.compactArray())if(tr instanceof Bucket$1)await asyncTransformBucket(tr,Q,tt);else{let tt=await Q(tr);te.push({bitField:J._children.bitField(),children:tt})}return tt(te)}var bucket=Bucket$1,consumableHash={exports:{}};let START_MASKS=[255,254,252,248,240,224,192,128],STOP_MASKS=[1,3,7,15,31,63,127,255];var consumableBuffer=class{constructor(J){this._value=J,this._currentBytePos=J.length-1,this._currentBitPos=7}availableBits(){return this._currentBitPos+1+8*this._currentBytePos}totalBits(){return 8*this._value.length}take(J){let Q=J,tt=0;for(;Q&&this._haveBits();){let J=this._value[this._currentBytePos],te=this._currentBitPos+1,tr=Math.min(te,Q);tt=(tt<<tr)+byteBitsToInt(J,te-tr,tr),Q-=tr,this._currentBitPos-=tr,this._currentBitPos<0&&(this._currentBitPos=7,this._currentBytePos--)}return tt}untake(J){for(this._currentBitPos+=J;this._currentBitPos>7;)this._currentBitPos-=8,this._currentBytePos+=1}_haveBits(){return this._currentBytePos>=0}};function byteBitsToInt(J,Q,tt){return(J&maskFor(Q,tt))>>>Q}function maskFor(J,Q){return START_MASKS[J]&STOP_MASKS[Math.min(Q+J-1,7)]}function concat(J,Q){Q||(Q=J.reduce((J,Q)=>J+Q.length,0));let tt=allocUnsafe(Q),te=0;for(let Q of J)tt.set(Q,te),te+=Q.length;return asUint8Array(tt)}var concat$1=Object.freeze({__proto__:null,concat:concat}),require$$1=getAugmentedNamespace(concat$1);let ConsumableBuffer=consumableBuffer,{concat:uint8ArrayConcat}=require$$1;function wrapHash$1(J){return function(Q){return Q instanceof InfiniteHash?Q:new InfiniteHash(Q,J)}}class InfiniteHash{constructor(J,Q){if(!(J instanceof Uint8Array))throw Error("can only hash Uint8Arrays");this._value=J,this._hashFn=Q,this._depth=-1,this._availableBits=0,this._currentBufferIndex=0,this._buffers=[]}async take(J){let Q=J;for(;this._availableBits<Q;)await this._produceMoreBits();let tt=0;for(;Q>0;){let J=this._buffers[this._currentBufferIndex],te=Math.min(J.availableBits(),Q);tt=(tt<<te)+J.take(te),Q-=te,this._availableBits-=te,0===J.availableBits()&&this._currentBufferIndex++}return tt}untake(J){let Q=J;for(;Q>0;){let J=this._buffers[this._currentBufferIndex],tt=Math.min(J.totalBits()-J.availableBits(),Q);J.untake(tt),Q-=tt,this._availableBits+=tt,this._currentBufferIndex>0&&J.totalBits()===J.availableBits()&&(this._depth--,this._currentBufferIndex--)}}async _produceMoreBits(){this._depth++;let J=this._depth?uint8ArrayConcat([this._value,Uint8Array.from([this._depth])]):this._value,Q=await this._hashFn(J),tt=new ConsumableBuffer(Q);this._buffers.push(tt),this._availableBits+=tt.availableBits()}}consumableHash.exports=wrapHash$1,consumableHash.exports.InfiniteHash=InfiniteHash;let Bucket=bucket,wrapHash=consumableHash.exports;function createHAMT(J){if(!J||!J.hashFn)throw Error("please define an options.hashFn");let Q={bits:J.bits||8,hash:wrapHash(J.hashFn)};return new Bucket(Q)}var src={createHAMT:createHAMT,Bucket:Bucket};class DirSharded extends Dir{constructor(J,Q){super(J,Q),this._bucket=src.createHAMT({hashFn:Q.hamtHashFn,bits:Q.hamtBucketBits})}async put(J,Q){await this._bucket.put(J,Q)}get(J){return this._bucket.get(J)}childCount(){return this._bucket.leafCount()}directChildrenCount(){return this._bucket.childrenCount()}onlyChild(){return this._bucket.onlyChild()}async *eachChildSeries(){for await(let{key:J,value:Q}of this._bucket.eachLeafSeries())yield{key:J,child:Q}}async *flush(J){for await(let Q of flush(this._bucket,J,this,this.options))yield{...Q,path:this.path}}}async function*flush(J,Q,tt,te){let tr=J._children,tn=[],ti=0;for(let J=0;J<tr.length;J++){let tt=tr.get(J);if(!tt)continue;let to=J.toString(16).toUpperCase().padStart(2,"0");if(tt instanceof src.Bucket){let J;for await(let tr of(await flush(tt,Q,null,te)))J=tr;if(!J)throw Error("Could not flush sharded directory, no subshard found");tn.push({Name:to,Tsize:J.size,Hash:J.cid}),ti+=J.size}else if("function"==typeof tt.value.flush){let J;let te=tt.value;for await(let tt of te.flush(Q))J=tt,yield J;let tr=to+tt.key;tn.push({Name:tr,Tsize:J.size,Hash:J.cid}),ti+=J.size}else{let J=tt.value;if(!J.cid)continue;let Q=to+tt.key,te=J.size;tn.push({Name:Q,Tsize:te,Hash:J.cid}),ti+=te}}let to=Uint8Array.from(tr.bitField().reverse()),ts=new UnixFS({type:"hamt-sharded-directory",data:to,fanout:J.tableSize(),hashType:te.hamtHashCode,mtime:tt&&tt.mtime,mode:tt&&tt.mode}),ta=encode$4(prepare({Data:ts.marshal(),Links:tn})),tl=await persist(ta,Q,te),tu=ta.length+ti;yield{cid:tl,unixfs:ts,size:tu}}async function flatToShard(J,Q,tt,te){let tr=Q;Q instanceof DirFlat&&Q.directChildrenCount()>=tt&&(tr=await convertToShard(Q,te));let tn=tr.parent;if(tn){if(tr!==Q){if(J&&(J.parent=tr),!tr.parentKey)throw Error("No parent key found");await tn.put(tr.parentKey,tr)}return flatToShard(tr,tn,tt,te)}return tr}async function convertToShard(J,Q){let tt=new DirSharded({root:J.root,dir:!0,parent:J.parent,parentKey:J.parentKey,path:J.path,dirty:J.dirty,flat:!1,mtime:J.mtime,mode:J.mode},Q);for await(let{key:Q,child:te}of J.eachChildSeries())await tt.put(Q,te);return tt}let toPathComponents$1=(J="")=>(J.trim().match(/([^\\^/]|\\\/)+/g)||[]).filter(Boolean);async function addToTree(J,Q,tt){let te=toPathComponents$1(J.path||""),tr=te.length-1,tn=Q,ti="";for(let to=0;to<te.length;to++){let ts=te[to];ti+=`${ti?"/":""}${ts}`;let ta=to===tr;if(tn.dirty=!0,tn.cid=void 0,tn.size=void 0,ta)await tn.put(ts,J),Q=await flatToShard(null,tn,tt.shardSplitThreshold,tt);else{let J=await tn.get(ts);J&&J instanceof Dir||(J=new DirFlat({root:!1,dir:!0,parent:tn,parentKey:ts,path:ti,dirty:!0,flat:!0,mtime:J&&J.unixfs&&J.unixfs.mtime,mode:J&&J.unixfs&&J.unixfs.mode},tt)),await tn.put(ts,J),tn=J}}return Q}async function*flushAndYield(J,Q){J instanceof Dir?yield*J.flush(Q):J&&J.unixfs&&J.unixfs.isDirectory()&&(yield J)}async function*treeBuilder(J,Q,tt){let te=new DirFlat({root:!0,dir:!0,path:"",dirty:!0,flat:!0},tt);for await(let Q of J)Q&&(te=await addToTree(Q,te,tt),Q.unixfs&&Q.unixfs.isDirectory()||(yield Q));if(tt.wrapWithDirectory)yield*flushAndYield(te,Q);else for await(let J of te.eachChildSeries())J&&(yield*flushAndYield(J.child,Q))}async function*importer(J,Q,tt={}){let te;let tr=defaultOptions$1(tt);for await(let tn of(te="function"==typeof tt.dagBuilder?tt.dagBuilder:dagBuilder,("function"==typeof tt.treeBuilder?tt.treeBuilder:treeBuilder)(itParallelBatch(te(Symbol.asyncIterator in J||Symbol.iterator in J?J:[J],Q,tr),tr.fileImportConcurrency),Q,tr)))yield{cid:tn.cid,path:tn.path,unixfs:tn.unixfs,size:tn.size}}async function*browserReadableStreamToIt$1(J,Q={}){let tt=J.getReader();try{for(;;){let J=await tt.read();if(J.done)return;yield J.value}}finally{!0!==Q.preventCancel&&tt.cancel(),tt.releaseLock()}}var browserReadablestreamToIt=browserReadableStreamToIt$1;let browserReadableStreamToIt=browserReadablestreamToIt;function blobToIt(J){return"function"==typeof J.stream?browserReadableStreamToIt(J.stream()):browserReadableStreamToIt(new Response(J).body)}var blobToIt_1=blobToIt;function peekableIterator(J){let[Q,tt]=J[Symbol.asyncIterator]?[J[Symbol.asyncIterator](),Symbol.asyncIterator]:[J[Symbol.iterator](),Symbol.iterator],te=[];return{peek:()=>Q.next(),push:J=>{te.push(J)},next:()=>te.length?{done:!1,value:te.shift()}:Q.next(),[tt](){return this}}}var itPeekable=peekableIterator;let map=async function*(J,Q){for await(let tt of J)yield Q(tt)};var itMap=map;function isBytes$1(J){return ArrayBuffer.isView(J)||J instanceof ArrayBuffer}function isBlob$1(J){return J.constructor&&("Blob"===J.constructor.name||"File"===J.constructor.name)&&"function"==typeof J.stream}function isFileObject(J){return"object"==typeof J&&(J.path||J.content)}let isReadableStream=J=>J&&"function"==typeof J.getReader;async function*toAsyncIterable(J){yield J}async function normaliseContent(J){if(isBytes$1(J))return toAsyncIterable(toBytes(J));if("string"==typeof J||J instanceof String)return toAsyncIterable(toBytes(J.toString()));if(isBlob$1(J))return blobToIt_1(J);if(isReadableStream(J)&&(J=browserReadablestreamToIt(J)),Symbol.iterator in J||Symbol.asyncIterator in J){let Q=itPeekable(J),{value:tt,done:te}=await Q.peek();if(te)return toAsyncIterable(new Uint8Array(0));if(Q.push(tt),Number.isInteger(tt))return toAsyncIterable(Uint8Array.from(await itAll(Q)));if(isBytes$1(tt)||"string"==typeof tt||tt instanceof String)return itMap(Q,toBytes)}throw errCode(Error(`Unexpected input: ${J}`),"ERR_UNEXPECTED_INPUT")}function toBytes(J){return J instanceof Uint8Array?J:ArrayBuffer.isView(J)?new Uint8Array(J.buffer,J.byteOffset,J.byteLength):J instanceof ArrayBuffer?new Uint8Array(J):Array.isArray(J)?Uint8Array.from(J):fromString(J.toString())}async function*normaliseCandidateSingle(J,Q){if(null==J)throw errCode(Error(`Unexpected input: ${J}`),"ERR_UNEXPECTED_INPUT");if("string"==typeof J||J instanceof String)yield toFileObject$1(J.toString(),Q);else if(isBytes$1(J)||isBlob$1(J))yield toFileObject$1(J,Q);else{if(isReadableStream(J)&&(J=browserReadablestreamToIt(J)),Symbol.iterator in J||Symbol.asyncIterator in J){let tt=itPeekable(J),{value:te,done:tr}=await tt.peek();if(tr)return void(yield{content:[]});if(tt.push(te),Number.isInteger(te)||isBytes$1(te)||"string"==typeof te||te instanceof String)return void(yield toFileObject$1(tt,Q));throw errCode(Error("Unexpected input: multiple items passed - if you are using ipfs.add, please use ipfs.addAll instead"),"ERR_UNEXPECTED_INPUT")}if(!isFileObject(J))throw errCode(Error('Unexpected input: cannot convert "'+typeof J+'" into ImportCandidate'),"ERR_UNEXPECTED_INPUT");yield toFileObject$1(J,Q)}}async function toFileObject$1(J,Q){let{path:tt,mode:te,mtime:tr,content:tn}=J,ti={path:tt||"",mode:parseMode(te),mtime:parseMtime(tr)};return tn?ti.content=await Q(tn):tt||(ti.content=await Q(J)),ti}function normaliseInput$1(J){return normaliseCandidateSingle(J,normaliseContent)}async function*normaliseCandidateMultiple(J,Q){if("string"==typeof J||J instanceof String||isBytes$1(J)||isBlob$1(J)||J._readableState)throw errCode(Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"),"ERR_UNEXPECTED_INPUT");if(isReadableStream(J)&&(J=browserReadablestreamToIt(J)),Symbol.iterator in J||Symbol.asyncIterator in J){let tt=itPeekable(J),{value:te,done:tr}=await tt.peek();if(tr)return void(yield*[]);if(tt.push(te),Number.isInteger(te))throw errCode(Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"),"ERR_UNEXPECTED_INPUT");if(te._readableState)return void(yield*itMap(tt,J=>toFileObject({content:J},Q)));if(isBytes$1(te))return void(yield toFileObject({content:tt},Q));if(isFileObject(te)||te[Symbol.iterator]||te[Symbol.asyncIterator]||isReadableStream(te)||isBlob$1(te))return void(yield*itMap(tt,J=>toFileObject(J,Q)))}if(isFileObject(J))throw errCode(Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"),"ERR_UNEXPECTED_INPUT");throw errCode(Error("Unexpected input: "+typeof J),"ERR_UNEXPECTED_INPUT")}async function toFileObject(J,Q){let{path:tt,mode:te,mtime:tr,content:tn}=J,ti={path:tt||"",mode:parseMode(te),mtime:parseMtime(tr)};return tn?ti.content=await Q(tn):tt||(ti.content=await Q(J)),ti}function normaliseInput(J){return normaliseCandidateMultiple(J,normaliseContent)}function isBytes(J){return ArrayBuffer.isView(J)||J instanceof ArrayBuffer}function isBlob(J){return!!J.constructor&&("Blob"===J.constructor.name||"File"===J.constructor.name)&&"function"==typeof J.stream}function isSingle(J){return"string"==typeof J||J instanceof String||isBytes(J)||isBlob(J)||"_readableState"in J}function getNormaliser(J){return isSingle(J)?normaliseInput$1(J):normaliseInput(J)}function notFoundError(J){return errCode(J=J||Error("Not Found"),"ERR_NOT_FOUND")}function abortedError(J){return errCode(J=J||Error("Aborted"),"ERR_ABORTED")}var ErrorsImport=Object.freeze({__proto__:null,notFoundError:notFoundError,abortedError:abortedError});let drain=async J=>{for await(let Q of J);};var itDrain=drain;let filter=async function*(J,Q){for await(let tt of J)await Q(tt)&&(yield tt)};var itFilter=filter;let take=async function*(J,Q){let tt=0;if(!(Q<1)){for await(let te of J)if(yield te,++tt===Q)return}};var itTake=take;let sortAll=(J,Q)=>(async function*(){let tt=await itAll(J);yield*tt.sort(Q)})();class BaseBlockstore{open(){return Promise.reject(Error(".open is not implemented"))}close(){return Promise.reject(Error(".close is not implemented"))}put(J,Q,tt){return Promise.reject(Error(".put is not implemented"))}get(J,Q){return Promise.reject(Error(".get is not implemented"))}has(J,Q){return Promise.reject(Error(".has is not implemented"))}delete(J,Q){return Promise.reject(Error(".delete is not implemented"))}async *putMany(J,Q={}){for await(let{key:tt,value:te}of J)await this.put(tt,te,Q),yield{key:tt,value:te}}async *getMany(J,Q={}){for await(let tt of J)yield this.get(tt,Q)}async *deleteMany(J,Q={}){for await(let tt of J)await this.delete(tt,Q),yield tt}batch(){let J=[],Q=[];return{put(Q,tt){J.push({key:Q,value:tt})},delete(J){Q.push(J)},commit:async tt=>{await itDrain(this.putMany(J,tt)),J=[],await itDrain(this.deleteMany(Q,tt)),Q=[]}}}async *_all(J,Q){throw Error("._all is not implemented")}async *_allKeys(J,Q){throw Error("._allKeys is not implemented")}query(J,Q){let tt=this._all(J,Q);if(null!=J.prefix&&(tt=itFilter(tt,Q=>Q.key.toString().startsWith(J.prefix||""))),Array.isArray(J.filters)&&(tt=J.filters.reduce((J,Q)=>itFilter(J,Q),tt)),Array.isArray(J.orders)&&(tt=J.orders.reduce((J,Q)=>sortAll(J,Q),tt)),null!=J.offset){let Q=0;tt=itFilter(tt,()=>Q++>=(J.offset||0))}return null!=J.limit&&(tt=itTake(tt,J.limit)),tt}queryKeys(J,Q){let tt=this._allKeys(J,Q);if(null!=J.prefix&&(tt=itFilter(tt,Q=>Q.toString().startsWith(J.prefix||""))),Array.isArray(J.filters)&&(tt=J.filters.reduce((J,Q)=>itFilter(J,Q),tt)),Array.isArray(J.orders)&&(tt=J.orders.reduce((J,Q)=>sortAll(J,Q),tt)),null!=J.offset){let Q=0;tt=itFilter(tt,()=>Q++>=J.offset)}return null!=J.limit&&(tt=itTake(tt,J.limit)),tt}}class MemoryBlockStore extends BaseBlockstore{constructor(){super(),this.store=new Map}async *blocks(){for(let[J,Q]of this.store.entries())yield{cid:CID.parse(J),bytes:Q}}put(J,Q){return this.store.set(J.toString(),Q),Promise.resolve()}get(J){let Q=this.store.get(J.toString());if(!Q)throw Error(`block with cid ${J.toString()} no found`);return Promise.resolve(Q)}has(J){return Promise.resolve(this.store.has(J.toString()))}close(){return this.store.clear(),Promise.resolve()}}let unixfsImporterOptionsDefault={cidVersion:1,chunker:"fixed",maxChunkSize:262144,hasher:sha256,rawLeaves:!0,wrapWithDirectory:!0,maxChildrenPerNode:174};async function pack({input:J,blockstore:Q,hasher:tt,maxChunkSize:te,maxChildrenPerNode:tr,wrapWithDirectory:tn,rawLeaves:ti}){let to;if(!J||Array.isArray(J)&&!J.length)throw Error("missing input file(s)");let ts=Q||new MemoryBlockStore,ta=await itLast(pipe$1(getNormaliser(J),J=>importer(J,ts,{...unixfsImporterOptionsDefault,hasher:tt||unixfsImporterOptionsDefault.hasher,maxChunkSize:te||unixfsImporterOptionsDefault.maxChunkSize,maxChildrenPerNode:tr||unixfsImporterOptionsDefault.maxChildrenPerNode,wrapWithDirectory:!1!==tn&&unixfsImporterOptionsDefault.wrapWithDirectory,rawLeaves:null==ti?unixfsImporterOptionsDefault.rawLeaves:ti})));if(!ta||!ta.cid)throw Error("given input could not be parsed correctly");let tl=ta.cid,{writer:tu,out:tf}=await CarWriter.create([tl]),th=tf[Symbol.asyncIterator]();return{root:tl,out:{[Symbol.asyncIterator](){if(null!=to)throw Error("Multiple iterator not supported");return to=(async()=>{for await(let J of ts.blocks())await tu.put(J);await tu.close(),Q||await ts.close()})(),{async next(){let J=await th.next();return J.done&&await to,J}}}}}}let MAX_HEADER_LENGTH=2e3,THROW_ON_MAX_HEADER_LENGTH_EXCEEDED=!1;function hasRel(J){return J&&J.rel}function intoRels(J,Q){return Q.rel.split(/\s+/).forEach(function(tt){J[tt]=Object.assign({},Q,{rel:tt})}),J}function createObjects(J,Q){let tt=Q.match(/\s*(.+)\s*=\s*"?([^"]+)"?/);return tt&&(J[tt[1]]=tt[2]),J}function parseLink(J){try{let Q=J.match(/<?([^>]*)>(.*)/),tt=Q[1],te=Q[2].split(";"),tr={},tn=new URL(tt,"https://example.com");for(let[J,Q]of tn.searchParams)tr[J]=Q;te.shift();let ti=te.reduce(createObjects,{});return(ti=Object.assign({},tr,ti)).url=tt,ti}catch{return null}}function checkHeader(J,Q){if(!J)return!1;let tt=(Q=Q||{}).maxHeaderLength||MAX_HEADER_LENGTH,te=Q.throwOnMaxHeaderLengthExceeded||THROW_ON_MAX_HEADER_LENGTH_EXCEEDED;if(J.length>tt){if(te)throw Error("Input string too long, it should be under "+tt+" characters.");return!1}return!0}function parseLinkHeader(J,Q){return checkHeader(J,Q)?J.split(/,\s*</).map(parseLink).filter(hasRel).reduce(intoRels,{}):null}let CID_CBOR_TAG$1=42;function cidDecoder$1(J){if(0!==J[0])throw Error("Invalid CID for CBOR tag 42; expected leading 0x00");return CID.decode(J.subarray(1))}let decodeOptions$1={allowIndefinite:!1,allowUndefined:!1,allowNaN:!1,allowInfinity:!1,allowBigInt:!0,strict:!0,useMaps:!1,tags:[]};decodeOptions$1.tags[CID_CBOR_TAG$1]=cidDecoder$1;let code$1=113,decode$1=J=>decode$6(J,decodeOptions$1),hashFn=async function(J){return(await murmur3128.encode(J)).slice(0,8).reverse()},addLinksToHamtBucket=(J,Q,tt)=>Promise.all(J.map(J=>{if(null==J.Name)throw Error("Unexpected Link without a Name");if(2===J.Name.length){let te=parseInt(J.Name,16);return Q._putObjectAt(te,new src.Bucket({hash:tt._options.hash,bits:tt._options.bits},Q,te))}return tt.put(J.Name.substring(2),!0)})),toPrefix=J=>J.toString(16).toUpperCase().padStart(2,"0").substring(0,2),toBucketPath=J=>{let Q=J.bucket,tt=[];for(;Q._parent;)tt.push(Q),Q=Q._parent;return tt.push(Q),tt.reverse()},findShardCid=async(J,Q,tt,te,tr)=>{if(!te){let J=src.createHAMT({hashFn:hashFn});te={rootBucket:J,hamtDepth:1,lastBucket:J}}await addLinksToHamtBucket(J.Links,te.lastBucket,te.rootBucket);let tn=await te.rootBucket._findNewBucketAndPos(Q),ti=toPrefix(tn.pos),to=toBucketPath(tn);to.length>te.hamtDepth&&(te.lastBucket=to[te.hamtDepth],ti=toPrefix(te.lastBucket._posAtParent));let ts=J.Links.find(J=>{if(null==J.Name)return!1;let tt=J.Name.substring(0,2),te=J.Name.substring(2);return tt===ti&&(!te||te===Q)});return ts?null!=ts.Name&&ts.Name.substring(2)===Q?ts.Hash:(te.hamtDepth++,findShardCid(J=decode$4(await tt.get(ts.Hash,tr)),Q,tt,te,tr)):null};function extractDataFromBlock(J,Q,tt,te){let tr=Q+J.length;return tt>=tr||te<Q?new Uint8Array(0):(te>=Q&&te<tr&&(J=J.slice(0,te-Q)),tt>=Q&&tt<tr&&(J=J.slice(tt-Q)),J)}let validateOffsetAndLength=(J,Q,tt)=>{if(Q||(Q=0),Q<0)throw errCode(Error("Offset must be greater than or equal to 0"),"ERR_INVALID_PARAMS");if(Q>J)throw errCode(Error("Offset must be less than the file size"),"ERR_INVALID_PARAMS");if(tt||0===tt||(tt=J-Q),tt<0)throw errCode(Error("Length must be greater than or equal to 0"),"ERR_INVALID_PARAMS");return Q+tt>J&&(tt=J-Q),{offset:Q,length:tt}};async function*emitBytes(J,Q,tt,te,tr=0,tn){let ti;if(Q instanceof Uint8Array){let J=extractDataFromBlock(Q,tr,tt,te);return J.length&&(yield J),tr+=J.length}if(null==Q.Data)throw errCode(Error("no data in PBNode"),"ERR_NOT_UNIXFS");try{ti=UnixFS.unmarshal(Q.Data)}catch(J){throw errCode(J,"ERR_NOT_UNIXFS")}if(ti.data&&ti.data.length){let J=extractDataFromBlock(ti.data,tr,tt,te);J.length&&(yield J),tr+=ti.data.length}let to=tr;for(let ts=0;ts<Q.Links.length;ts++){let ta=Q.Links[ts],tl=tr+ti.blockSizes[ts];if(tt>=to&&tt<tl||te>to&&te<=tl||tt<to&&te>tl){let Q;let ti=await J.get(ta.Hash,{signal:tn.signal});switch(ta.Hash.code){case code$5:Q=await decode$4(ti);break;case code$4:Q=ti;break;case code$1:Q=await decode$1(ti);break;default:throw Error(`Unsupported codec: ${ta.Hash.code}`)}for await(let ti of emitBytes(J,Q,tt,te,tr,tn))tr+=ti.length,yield ti}tr=tl,to=tl+1}}let fileContent=(J,Q,tt,te,tr,tn,ti)=>function(J={}){let te=tt.fileSize();if(void 0===te)throw Error("File was a directory");let{offset:tr,length:tn}=validateOffsetAndLength(te,J.offset,J.length);return emitBytes(ti,Q,tr,tr+tn,0,J)},directoryContent=(J,Q,tt,te,tr,tn,ti)=>async function*(J={}){let tt=J.offset||0,to=J.length||Q.Links.length,ts=Q.Links.slice(tt,to);for(let Q of ts){let tt=await tr(Q.Hash,Q.Name||"",`${te}/${Q.Name||""}`,[],tn+1,ti,J);tt.entry&&(yield tt.entry)}},hamtShardedDirectoryContent=(J,Q,tt,te,tr,tn,ti)=>function(J={}){return listDirectory(Q,te,tr,tn,ti,J)};async function*listDirectory(J,Q,tt,te,tr,tn){let ti=J.Links;for(let to of ti){let ti=null!=to.Name?to.Name.substring(2):null;if(ti){let J=await tt(to.Hash,ti,`${Q}/${ti}`,[],te+1,tr,tn);yield J.entry}else for await(let ti of listDirectory(J=decode$4(await tr.get(to.Hash)),Q,tt,te,tr,tn))yield ti}}let findLinkCid=(J,Q)=>{let tt=J.Links.find(J=>J.Name===Q);return tt&&tt.Hash},contentExporters={raw:fileContent,file:fileContent,directory:directoryContent,"hamt-sharded-directory":hamtShardedDirectoryContent,metadata:(J,Q,tt,te,tr,tn,ti)=>()=>[],symlink:(J,Q,tt,te,tr,tn,ti)=>()=>[]},unixFsResolver=async(J,Q,tt,te,tr,tn,ti,to)=>{let ts,ta;let tl=decode$4(await ti.get(J,to));if(Q||(Q=J.toString()),null==tl.Data)throw errCode(Error("no data in PBNode"),"ERR_NOT_UNIXFS");try{ts=UnixFS.unmarshal(tl.Data)}catch(J){throw errCode(J,"ERR_NOT_UNIXFS")}if(tt||(tt=Q),te.length){let J;if(!(J=ts&&"hamt-sharded-directory"===ts.type?await findShardCid(tl,te[0],ti):findLinkCid(tl,te[0])))throw errCode(Error("file does not exist"),"ERR_NOT_FOUND");let Q=te.shift();ta={cid:J,toResolve:te,name:Q||"",path:`${tt}/${Q}`}}return{entry:{type:ts.isDirectory()?"directory":"file",name:Q,path:tt,cid:J,content:contentExporters[ts.type](J,tl,ts,tt,tr,tn,ti),unixfs:ts,depth:tn,node:tl,size:ts.fileSize()},next:ta}},rawContent$1=J=>async function*(Q={}){let{offset:tt,length:te}=validateOffsetAndLength(J.length,Q.offset,Q.length);yield extractDataFromBlock(J,0,tt,tt+te)},resolve$3=async(J,Q,tt,te,tr,tn,ti,to)=>{if(te.length)throw errCode(Error(`No link named ${tt} found in raw node ${J}`),"ERR_NOT_FOUND");let ts=await ti.get(J,to);return{entry:{type:"raw",name:Q,path:tt,cid:J,content:rawContent$1(ts),depth:tn,size:ts.length,node:ts}}},resolve$2=async(J,Q,tt,te,tr,tn,ti,to)=>{let ts=await ti.get(J),ta=decode$1(ts),tl=ta,tu=tt;for(;te.length;){let tr=te[0];if(!(tr in tl))throw errCode(Error(`No property named ${tr} found in cbor node ${J}`),"ERR_NO_PROP");{te.shift(),tu=`${tu}/${tr}`;let ti=CID.asCID(tl[tr]);if(ti)return{entry:{type:"object",name:Q,path:tt,cid:J,node:ts,depth:tn,size:ts.length,content:async function*(){yield ta}},next:{cid:ti,name:tr,path:tu,toResolve:te}};tl=tl[tr]}}return{entry:{type:"object",name:Q,path:tt,cid:J,node:ts,depth:tn,size:ts.length,content:async function*(){yield ta}}}},rawContent=J=>async function*(Q={}){let{offset:tt,length:te}=validateOffsetAndLength(J.length,Q.offset,Q.length);yield extractDataFromBlock(J,0,tt,tt+te)},resolve$1=async(J,Q,tt,te,tr,tn,ti,to)=>{if(te.length)throw errCode(Error(`No link named ${tt} found in raw node ${J}`),"ERR_NOT_FOUND");let ts=await decode$8(J.multihash.bytes);return{entry:{type:"identity",name:Q,path:tt,cid:J,content:rawContent(ts.digest),depth:tn,size:ts.digest.length,node:ts.digest}}},resolvers={[code$5]:unixFsResolver,[code$4]:resolve$3,[code$1]:resolve$2,[identity.code]:resolve$1};function resolve(J,Q,tt,te,tr,tn,ti){let to=resolvers[J.code];if(!to)throw errCode(Error(`No resolver for code ${J.code}`),"ERR_NO_RESOLVER");return to(J,Q,tt,te,resolve,tr,tn,ti)}let toPathComponents=(J="")=>(J.trim().match(/([^\\^/]|\\\/)+/g)||[]).filter(Boolean),cidAndRest=J=>{if(J instanceof Uint8Array)return{cid:CID.decode(J),toResolve:[]};let Q=CID.asCID(J);if(Q)return{cid:Q,toResolve:[]};if("string"==typeof J){0===J.indexOf("/ipfs/")&&(J=J.substring(6));let Q=toPathComponents(J);return{cid:CID.parse(Q[0]),toResolve:Q.slice(1)}}throw errCode(Error(`Unknown path type ${J}`),"ERR_BAD_PATH")};async function*walkPath(J,Q,tt={}){let{cid:te,toResolve:tr}=cidAndRest(J),tn=te.toString(),ti=tn,to=tr.length;for(;;){let ts=await resolve(te,tn,ti,tr,to,Q,tt);if(!ts.entry&&!ts.next)throw errCode(Error(`Could not resolve ${J}`),"ERR_NOT_FOUND");if(ts.entry&&(yield ts.entry),!ts.next)return;tr=ts.next.toResolve,te=ts.next.cid,tn=ts.next.name,ti=ts.next.path}}async function exporter(J,Q,tt={}){let te=await itLast(walkPath(J,Q,tt));if(!te)throw errCode(Error(`Could not resolve ${J}`),"ERR_NOT_FOUND");return te}async function*recursive(J,Q,tt={}){let te=await exporter(J,Q,tt);if(te&&(yield te,"directory"===te.type))for await(let J of async function* J(Q,tt){for await(let te of Q.content(tt))yield te,te instanceof Uint8Array||"directory"===te.type&&(yield*J(te,tt))}(te,tt))yield J}function equals(J,Q){if(J===Q)return!0;if(J.byteLength!==Q.byteLength)return!1;for(let tt=0;tt<J.byteLength;tt++)if(J[tt]!==Q[tt])return!1;return!0}class VerifyingGetOnlyBlockStore extends BaseBlockstore{constructor(J){super(),this.store=J}async get(J){let Q=await this.store.get(J);if(!Q)throw Error(`Incomplete CAR. Block missing for CID ${J}`);if(!isValid({cid:J,bytes:Q}))throw Error(`Invalid CAR. Hash of block data does not match CID ${J}`);return Q}static fromBlockstore(J){return new VerifyingGetOnlyBlockStore(J)}static fromCarReader(J){return new VerifyingGetOnlyBlockStore({get:async Q=>{let tt=await J.get(Q);return null==tt?void 0:tt.bytes}})}}async function isValid({cid:J,bytes:Q}){return equals((await sha256.digest(Q)).digest,J.multihash.digest)}async function*unpackStream(J,{roots:Q,blockstore:tt}={}){let te=await CarBlockIterator.fromIterable(asAsyncIterable(J)),tr=tt||new MemoryBlockStore;for await(let J of te)await tr.put(J.cid,J.bytes);let tn=VerifyingGetOnlyBlockStore.fromBlockstore(tr);for(let J of(Q&&0!==Q.length||(Q=await te.getRoots()),Q))yield*recursive(J,tn)}function asAsyncIterable(J){return Symbol.asyncIterator in J?J:browserReadablestreamToIt(J)}let readonly=({enumerable:J=!0,configurable:Q=!1}={})=>({enumerable:J,configurable:Q,writable:!1}),links=function*(J,Q){if(null!=J&&!(J instanceof Uint8Array))for(let[tt,te]of Object.entries(J)){let J=[...Q,tt];if(null!=te&&"object"==typeof te){if(Array.isArray(te))for(let[Q,tt]of te.entries()){let te=[...J,Q],tr=CID.asCID(tt);tr?yield[te.join("/"),tr]:"object"==typeof tt&&(yield*links(tt,te))}else{let Q=CID.asCID(te);Q?yield[J.join("/"),Q]:yield*links(te,J)}}}},tree=function*(J,Q){if(null!=J)for(let[tt,te]of Object.entries(J)){let J=[...Q,tt];if(yield J.join("/"),!(null==te||te instanceof Uint8Array||"object"!=typeof te||CID.asCID(te))){if(Array.isArray(te))for(let[Q,tt]of te.entries()){let te=[...J,Q];yield te.join("/"),"object"!=typeof tt||CID.asCID(tt)||(yield*tree(tt,te))}else yield*tree(te,J)}}},get=(J,Q)=>{let tt=J;for(let[J,te]of Q.entries()){if(null==(tt=tt[te]))throw Error(`Object has no property at ${Q.slice(0,J+1).map(J=>`[${JSON.stringify(J)}]`).join("")}`);let tr=CID.asCID(tt);if(tr)return{value:tr,remaining:Q.slice(J+1).join("/")}}return{value:tt}};class Block{constructor({cid:J,bytes:Q,value:tt}){if(!J||!Q||void 0===tt)throw Error("Missing required argument");this.cid=J,this.bytes=Q,this.value=tt,this.asBlock=this,Object.defineProperties(this,{cid:readonly(),bytes:readonly(),value:readonly(),asBlock:readonly()})}links(){return links(this.value,[])}tree(){return tree(this.value,[])}get(J="/"){return get(this.value,J.split("/").filter(Boolean))}}let CID_CBOR_TAG=42;function cidEncoder(J){if(J.asCID!==J)return null;let Q=CID.asCID(J);if(!Q)return null;let tt=new Uint8Array(Q.bytes.byteLength+1);return tt.set(Q.bytes,1),[new Token(Type.tag,CID_CBOR_TAG),new Token(Type.bytes,tt)]}function undefinedEncoder(){throw Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded")}function numberEncoder(J){if(Number.isNaN(J))throw Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");if(J===1/0||J===-1/0)throw Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");return null}let encodeOptions={float64:!0,typeEncoders:{Object:cidEncoder,undefined:undefinedEncoder,number:numberEncoder}};function cidDecoder(J){if(0!==J[0])throw Error("Invalid CID for CBOR tag 42; expected leading 0x00");return CID.decode(J.subarray(1))}let decodeOptions={allowIndefinite:!1,allowUndefined:!1,allowNaN:!1,allowInfinity:!1,allowBigInt:!0,strict:!0,useMaps:!1,tags:[]};decodeOptions.tags[CID_CBOR_TAG]=cidDecoder;let name="dag-cbor",code=113,encode=J=>encode$6(J,encodeOptions),decode=J=>decode$6(J,decodeOptions);var cbor=Object.freeze({__proto__:null,name:name,code:code,encode:encode,decode:decode});class TreewalkCarSplitter{constructor(J,Q,tt={}){if("number"!=typeof Q||Q<=0)throw Error("invalid target chunk size");this._reader=J,this._targetSize=Q,this._decoders=[pb,raw,cbor,...tt.decoders||[]]}async *cars(){let J;let Q=await this._reader.getRoots();if(1!==Q.length)throw Error(`unexpected number of roots: ${Q.length}`);for await(let tt of this._cars(Q[0]))J=tt.channel,tt.out&&(yield tt.out);if(!J)throw Error("missing CAR writer channel");J.writer.close(),yield J.out}async _get(J){let Q=await this._reader.get(J);if(!Q)throw Error(`missing block for ${J}`);let{bytes:tt}=Q,te=this._decoders.find(Q=>Q.code===J.code);if(!te)throw Error(`missing decoder for ${J.code}`);return new Block({cid:J,bytes:tt,value:te.decode(tt)})}async *_cars(J,Q=[],tt){let te=await this._get(J);if((tt=tt||Object.assign(CarWriter.create(J),{size:0})).size>0&&tt.size+te.bytes.byteLength>=this._targetSize){tt.writer.close();let{out:J}=tt;tt=newCar(Q),yield{channel:tt,out:J}}for(let[,J]of(Q=Q.concat(te),tt.size+=te.bytes.byteLength,tt.writer.put(te),te.links()))for await(let te of this._cars(J,Q,tt))tt=te.channel,yield te;if(!tt)throw Error("missing CAR writer channel");yield{channel:tt}}static async fromIterable(J,Q,tt){let te=await CarReader.fromIterable(J);return new TreewalkCarSplitter(te,Q,tt)}static async fromBlob(J,Q,tt){let te=await J.arrayBuffer(),tr=await CarReader.fromBytes(new Uint8Array(te));return new TreewalkCarSplitter(tr,Q,tt)}}function newCar(J){let Q=Object.assign(CarWriter.create(J[0].cid),{size:J.reduce((J,Q)=>J+Q.bytes.byteLength,0)});for(let tt of J)Q.writer.put(tt);return Q}async function getFilesFromPath(){throw Error("Unsupported in this environment")}async function*filesFromPath(){throw Error("Unsupported in this environment")}var throttledQueue$1={exports:{}};!function(J,Q){function tt(J,Q,tt){void 0===tt&&(tt=!1),tt&&(Q/=J,J=1);var te,tr=[],tn=0,ti=0,to=function(){var tt=tn+Q,ts=Date.now();if(ts<tt)return void 0!==te&&clearTimeout(te),void(te=setTimeout(to,tt-ts));tn=ts,ti=0;for(var ta=0,tl=tr.splice(0,J);ta<tl.length;ta++){var tu=tl[ta];ti++,tu()}te=tr.length?setTimeout(to,Q):void 0};return function(tt){return new Promise(function(ts,ta){var tl=function(){return Promise.resolve().then(tt).then(ts).catch(ta)},tu=Date.now();void 0===te&&tu-tn>Q&&(tn=tu,ti=0),ti++<J?tl():(tr.push(tl),void 0===te&&(te=setTimeout(to,tn+Q-tu)))})}}Object.defineProperty(Q,"__esModule",{value:!0}),J.exports=tt,Q.default=tt}(throttledQueue$1,throttledQueue$1.exports);var throttledQueue=getDefaultExportFromCjs(throttledQueue$1.exports);let fetch=globalThis.fetch,Blob$1=globalThis.Blob,File=globalThis.File,Blockstore=MemoryBlockStore,MAX_PUT_RETRIES=5,MAX_CONCURRENT_UPLOADS=3,DEFAULT_CHUNK_SIZE=52428800,MAX_BLOCK_SIZE=1048576,MAX_CHUNK_SIZE=104857600,RATE_LIMIT_REQUESTS=30,RATE_LIMIT_PERIOD=1e4;function createRateLimiter(){let J=throttledQueue(RATE_LIMIT_REQUESTS,RATE_LIMIT_PERIOD);return()=>J(()=>{})}let globalRateLimiter=createRateLimiter();class Web3Storage{constructor({token:J,endpoint:Q=new URL("https://api.web3.storage"),rateLimiter:tt,fetch:te=fetch}){this.token=J,this.endpoint=Q,this.rateLimiter=tt||createRateLimiter(),this.fetch=te}static headers(J){if(!J)throw Error("missing token");return{Authorization:`Bearer ${J}`,"X-Client":"web3.storage/js"}}static async put({endpoint:J,token:Q,rateLimiter:tt=globalRateLimiter,fetch:te=fetch},tr,{onRootCidReady:tn,onStoredChunk:ti,maxRetries:to=MAX_PUT_RETRIES,maxChunkSize:ts=DEFAULT_CHUNK_SIZE,wrapWithDirectory:ta=!0,name:tl,signal:tu}={}){if(ts>=MAX_CHUNK_SIZE||ts<MAX_BLOCK_SIZE)throw Error("maximum chunk size must be less than 100MiB and greater than or equal to 1MB");let tf=new Blockstore;try{let{out:th,root:tc}=await pack({input:Array.from(tr).map(toImportCandidate),blockstore:tf,wrapWithDirectory:ta,maxChunkSize:MAX_BLOCK_SIZE,maxChildrenPerNode:1024});tn&&tn(tc.toString());let td=await CarReader.fromIterable(th);return await Web3Storage.putCar({endpoint:J,token:Q,rateLimiter:tt,fetch:te},td,{onStoredChunk:ti,maxRetries:to,maxChunkSize:ts,name:tl,signal:tu})}finally{await tf.close()}}static async putCar({endpoint:J,token:Q,rateLimiter:tt=globalRateLimiter,fetch:te=fetch},tr,{name:tn,onStoredChunk:ti,maxRetries:to=MAX_PUT_RETRIES,maxChunkSize:ts=DEFAULT_CHUNK_SIZE,decoders:ta,signal:tl}={}){if(ts>=MAX_CHUNK_SIZE||ts<MAX_BLOCK_SIZE)throw Error("maximum chunk size must be less than 100MiB and greater than or equal to 1MB");let tu=ts,tf=new URL("car",J),th={...Web3Storage.headers(Q),"Content-Type":"application/vnd.ipld.car",...tn?{"X-Name":encodeURIComponent(tn)}:{}},tc=await tr.getRoots();if(null==tc[0])throw Error("missing root CID");if(tc.length>1)throw Error("too many roots");let td=tc[0].toString(),tp=new TreewalkCarSplitter(tr,tu,{decoders:ta}),ty=transform(MAX_CONCURRENT_UPLOADS,async J=>{let Q=[];for await(let tt of J)Q.push(tt);let tr=new Blob$1(Q,{type:"application/vnd.ipld.car"}),tn=tr;parseInt(globalThis.process?.versions?.node)>18&&(tn=await tn.arrayBuffer());let ts=await pRetry$1(async()=>{let J;await tt();try{J=await te(tf.toString(),{method:"POST",headers:th,body:tn,signal:tl})}catch(J){throw tl&&tl.aborted?new AbortError_1(J):J}if(429===J.status)throw Error("rate limited");let Q=await J.json();if(!J.ok)throw Error(Q.message);if(Q.cid!==td)throw Error(`root CID mismatch, expected: ${td}, received: ${Q.cid}`);return Q.cid},{retries:to});return ti&&ti(tr.size),ts});for await(let J of ty(tp.cars()));return td}static async get({endpoint:J,token:Q,rateLimiter:tt=globalRateLimiter,fetch:te=fetch},tr,tn={}){let ti=new URL(`car/${tr}`,J);await tt();let to=await te(ti.toString(),{method:"GET",headers:Web3Storage.headers(Q),signal:tn.signal});if(429===to.status)throw Error("rate limited");return toWeb3Response(to)}static async delete({endpoint:J,token:Q,rateLimiter:tt=globalRateLimiter},te,tr={}){throw console.log("Not deleting",te,J,Q,tt,tr),Error(".delete not implemented yet")}static async status({endpoint:J,token:Q,rateLimiter:tt=globalRateLimiter,fetch:te=fetch},tr,tn={}){let ti=new URL(`status/${tr}`,J);await tt();let to=await te(ti.toString(),{method:"GET",headers:Web3Storage.headers(Q),signal:tn.signal});if(429===to.status)throw Error("rate limited");if(404!==to.status){if(!to.ok)throw Error(to.statusText);return to.json()}}static async *list(J,{before:Q=(new Date).toISOString(),maxResults:tt=1/0,signal:te}={}){let tr=0,tn=tt>100?100:tt;for await(let ti of paginator(async function({endpoint:J,token:Q,rateLimiter:tt=globalRateLimiter,fetch:tr=fetch},{before:tn,size:ti}){let to=new URLSearchParams({before:tn,size:ti.toString()}),ts=new URL(`user/uploads?${to}`,J);return await tt(),tr(ts.toString(),{method:"GET",headers:{...Web3Storage.headers(Q),"Access-Control-Request-Headers":"Link"},signal:te})},J,{before:Q,size:tn})){if(!ti.ok){if(429===ti.status)throw Error("rate limited");let J=await ti.json();throw Error(`${ti.status} ${ti.statusText} ${J?"- "+J.message:""}`)}let J=await ti.json();for(let Q of J){if(++tr>tt)return;yield Q}}}put(J,Q){return Web3Storage.put(this,J,Q)}putCar(J,Q){return Web3Storage.putCar(this,J,Q)}get(J,Q){return Web3Storage.get(this,J,Q)}delete(J,Q){return Web3Storage.delete(this,J,Q)}status(J,Q){return Web3Storage.status(this,J,Q)}list(J){return Web3Storage.list(this,J)}}async function toWeb3File({content:J,path:Q,cid:tt}){let te=[];for await(let Q of J())te.push(Q);let tr=new File(te,toFilenameWithPath(Q));return Object.assign(tr,{cid:tt.toString()})}function toFilenameWithPath(J){let Q=J.indexOf("/");return -1===Q?J:J.substring(Q+1)}function toWeb3Response(J){let Q=Object.assign(J,{unixFsIterator:async function*(){if(!J.ok)throw Error(`Response was not ok: ${J.status} ${J.statusText} - Check for { "ok": false } on the Response object before calling .unixFsIterator`);if(!J.body)throw Error("No body on response");let Q=new Blockstore;try{for await(let tt of unpackStream(J.body,{blockstore:Q}))yield tt}finally{await Q.close()}},files:async()=>{if(!J.ok)throw Error(`Response was not ok: ${J.status} ${J.statusText} - Check for { "ok": false } on the Response object before calling .files`);let tt=[];for await(let J of Q.unixFsIterator()){if("directory"===J.type)continue;let Q=await toWeb3File(J);tt.push(Q)}return tt}});return Q}function toImportCandidate(J){let Q;return{path:J.name,get content(){return Q=Q||J.stream()}}}async function*paginator(J,Q,tt){let te=await J(Q,tt);yield te;let tr=parseLinkHeader(te.headers.get("Link")||"");for(;tr&&tr.next;)te=await J(Q,tr.next),yield te,tr=parseLinkHeader(te.headers.get("Link")||"")}}}]);